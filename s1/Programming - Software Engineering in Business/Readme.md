# Θεωρία JAVA

## Απόκρυψη πληροφοριών

Η δεσμευμένη λέξη **private** ενισχύει την αρχή της απόκρυψης πληροφοριών (information hiding), σύμφωνα με την οποία οι εσωτερικές λεπτομέρειες της υλοποίησης μιας κλάσης πρέπει να κρύβονται από άλλες κλάσεις.

Πότε όμως δηλώνουμε κάθε ένα από τα στοιχεία αυτά **public** και πότε **private**;

* Μια μέθοδος που δηλώνεται ως public είναι δυνατόν να προσπελαστεί από οποιαδήποτε άλλη κλάση, όπου και αν βρίσκεται αυτή (είτε ανήκει στο ίδιο πακέτο είτε όχι).   
* Μια μέθοδος που δηλώνεται ως private μπορεί να προσπελαστεί και να χρησιμοποιηθεί μόνο από τα αντικείμενα της κλάσης μέσα στην οποία δηλώνεται. Μια μέθοδος που δηλώνεται ως private μπορεί για παράδειγμα να χρησιμοποιείται για την υλοποίηση ενός τμήματος μιας πολύπλοκης διαδικασίας ή μιας διαδικασίας με μεγάλη έκταση και στη συνέχεια να καλείται από κάποια άλλη μέθοδο της ίδιας κλάσης.   
* Τα πεδία μιας κλάσης πρέπει πάντα να δηλώνονται private, έτσι ώστε να μην παραβιάζεται η αρχή της απόκρυψης πληροφοριών.

## Μεταβλητές και σταθερές κλάσεων

Η δεσμευμένη λέξη **static** χρησιμοποιείται για τη δήλωση μεταβλητών κλάσης (class variables), ή αλλιώς στατικών μεταβλητών (static variables). Οι μεταβλητές κλάσεις είναι πεδία που αποθηκεύονται στην ίδια την κλάση και όχι σε ένα αντικείμενο. Κάθε στιγμή δηλαδή κατά τη διάρκεια εκτέλεσης ενός προγράμματος υπάρχει ένα μόνο αντίγραφο μιας μεταβλητής κλάσης ανεξάρτητα από τον αριθμό των στιγμιοτύπων/αντικειμένων της.
πχ
```
public class BouncingBall
{
    private static final int gravity = 3;
    private int xPosition;
    private int yPosition;
    //τα υπόλοιπα πεδία και οι μέθοδοι παραλείπονται
}
```

Η δεσμευμένη λέξη **final** χρησιμοποιείται συχνά για τον ορισμό σταθερών (constants), η τιμή των οποίων παραμένει αμετάβλητη σε όλη τη διάρκεια εκτέλεσης ενός προγράμματος. Η δήλωση σταθερών στη Java γίνεται με τη δεσμευμένη λέξη final.

Για παράδειγμα, με την εντολή

    private final int size = 10;

ορίζεται μια σταθερά με όνομα size και τιμή 10.

Πολλές φορές μια σταθερά χρησιμοποιείται από όλα τα στιγμιότυπα μιας κλάσης. Σε αυτή την περίπτωση δηλώνουμε μια σταθερά κλάσης (class constant) συνδυάζοντας τις δεσμευμένες λέξεις static και final, όπως στην περίπτωση της gravity παραπάνω.

   private static final int gravity = 3;

## Κληρονομικότητα

Στην ουσία, η **κληρονομικότητα** (inheritance) μας επιτρέπει να ορίσουμε μια κλάση ως επέκταση μιας άλλης.

Στην περίπτωση αυτή η κλάση που επεκτείνεται από κάποια άλλη ονομάζεται **γονική κλάση** (parent class) ή **υπερκλάση** (superclass).

Αντίθετα, μια κλάση που επεκτείνει κάποια άλλη, κληρονομεί δηλαδή όλα τα πεδία και τις μεθόδους από αυτή, ονομάζεται **θυγατρική κλάση** (child class) ή **υποκλάση** (subclass).

Η δεσμευμένη λέξη **extends** ορίζει μια σχέση κληρονομικότητας.

Οι υπερκλάσεις άλλων κλάσεων (δεν δημιουργούν αντικείμενα), ονομάζονται **αφηρημένες** κλάσεις.

### Κληρονομικότητα και δικαιώματα πρόσβασης

- Τα μέλη (members) των κλάσεων που ορίζονται ως public είτε στην υπερκλάση είτε στην υποκλάση θα είναι προσπελάσιμα σε αντικείμενα άλλων κλάσεων, ενώ τα μέλη που ορίζονται ως private δεν θα είναι προσπελάσιμα.   

- Στην πραγματικότητα, ο κανόνας αυτός ισχύει και μεταξύ μιας υποκλάσης και της υπερκλάσης της: μια υποκλάση δεν μπορεί να προσπελάσει μέλη της υπερκλάσης που έχουν δηλωθεί ως private.    

- Συνεπώς, αν μια υποκλάση πρέπει να είναι σε θέση να προσπελάζει ή να αλλάζει πεδία της υπερκλάσης που έχουν δηλωθεί ως private τότε θα πρέπει η υπερκλάση να παρέχει τις κατάλληλες μεθόδους πρόσβασης ή/και μετάλλαξης.   

- Μια υποκλάση μπορεί να καλεί οποιαδήποτε public μέθοδο της υπερκλάσης της σαν να ήταν δική της – δεν χρειάζονται μεταβλητές.

### Πλεονεκτήματα της κληρονομικότητας

- Αποφυγή πανομοιότυπων τμημάτων κώδικα.   

- Επαναχρησιμοποίηση κώδικα.   

- Ευκολότερη συντήρηση.   

- Επεκτασιμότητα.   

## Στατικός και δυναμικός τύπος

* Ο δηλωμένος τύπος της μεταβλητής λέγεται στατικός τύπος (static type), γιατί δηλώνεται στον πηγαίο κώδικα – τη στατική αναπαράσταση του προγράμματος.    

* Ο τύπος του αντικειμένου που αποθηκεύεται σε μια μεταβλητή ονομάζεται δυναμικός τύπος (dynamic type), γιατί εξαρτάται από αναθέσεις που γίνονται κατά το χρόνο εκτέλεσης — τη δυναμική συμπεριφορά ενός προγράμματος.

```
Vehicle v1 = new Car();
```

- ο στατικός τύπος της μεταβλητής v1 είναι Vehicle    
- ο δυναμικός τύπος της v1 είναι Car

Ο δυναμικός τύπος συχνά προσδιορίζεται μόνο κατά το χρόνο εκτέλεσης.

## Υποσκέλιση (overriding) ή επανορισμός (redefinition)

Η υποσκέλιση είναι μια περίπτωση στην οποία μια μέθοδος ορίζεται σε κάποια υπερκλάση και ταυτόχρονα στην υποκλάση ορίζεται μια άλλη μέθοδος με την ίδια ακριβώς υπογραφή.

## Δυναμική αναζήτηση μεθόδων

Ο έλεγχος τύπων χρησιμοποιεί το στατικό τύπο, αλλά κατά το χρόνο εκτέλεσης εκτελούνται οι μέθοδοι που καθορίζει ο δυναμικός τύπος.

## Κλήση της super σε μεθόδους

Αυτό που θέλουμε να πετύχουμε είναι, για κάθε κλήση μιας μεθόδου της υπερκλάσης.

πχ **super.όνομα-μεθόδου(παράμετροι)**

## Προστατευμένη πρόσβαση

Η προστατευμένη πρόσβαση (protected) επιτρέπει την προσπέλαση των πεδίων και των μεθόδων μέσα σε μια κλάση και από όλες τις υποκλάσεις της, αλλά όχι από άλλες κλάσεις.

### Υποτύποι και εντολές ανάθεσης

Μια μεταβλητή μπορεί να αναφέρεται σε αντικείμενα του δηλωμένου τύπου της ή οποιουδήποτε υποτύπου του δηλωμένου τύπου της.

πχ   
Vehicle v1 = new Vehicle();   
Vehicle v2 = new Car();   
Vehicle v3 = new Bicycle();   

## Πολυμορφικές μεταβλητές

Οι μεταβλητές που αποθηκεύουν τύπους αντικειμένων στη Java ονομάζονται **πολυμορφικές μεταβλητές** (polymorphic variables).

Ο όρος ‘πολυμορφικές’ αναφέρεται στο γεγονός ότι μια μεταβλητή μπορεί να αποθηκεύσει αντικείμενα διάφορων τύπων (του τύπου της μεταβλητής ή οποιουδήποτε υποτύπου του δηλωμένου τύπου).

## Πολυμορφισμός μεθόδων

Μια πολυμορφική μεταβλητή είναι μια μεταβλητή που μπορεί να αποθηκεύσει αντικείμενα διάφορων τύπων (κάθε μεταβλητή αντικειμένου στη Java είναι πολυμορφική).

Με παρόμοιο τρόπο, οι κλήσεις μεθόδων στη Java είναι πολυμορφικές, αφού μπορούν να ενεργοποιούν διαφορετικές μεθόδους σε διαφορετικές στιγμές.

## ΣΥΝΤΑΚΤΙΚΟ

Έλεγχος ισότητας αλφαριθμητικών if (string1.equals(string2))   
Αν δεν θέλουμε να λαμβάνονται υπόψη πεζά-κεφαλαία τότε κάνουμε χρήση της equalsIngnoreCase()   
Μετατροπή κεφαλαίων toLowerCase()   
πεζά: toUpperCase()   

Μετατροπή άλλων τύπων σε αλφαριθμητικό: String st1 = String.valueOf(22);   
Μετατροπή αλφαριθμητικών σε άλλους τύπους:   
int i = Integer.parseInt("22");   
double d = Double.parseDouble("22.2");   
μεταβλητή_float = Float.parseFloat(αλφαριθμητικό);   

// Διάβασμα από πληκτρολόγιο:   
Scanner input = new Scanner(System.in);

// nextLine: διαβάζει αλφαριθμητικό που εισήγαγε ο χρήστης   
String owner = input.nextLine(); 

// διαβάζει αλφαριθμητικό 
boolean flag = input.nextBoolean();

// Διαβάζουμε τον αριθμό  από το πληκτρολόγιο  
int num = input.nextInt();

//Αν μετά από διάβασμα αριθμού ή λογικής τιμής ακολουθεί διάβασμα αλφαριθμητικής τιμής θυμηθείτε να «καθαρίσετε» τον input buffer. Καθαρίζουμε τον buffer για να μην διαβαστεί κατά λάθος το Enter του προηγούμενου input. Αλλιώς θα δείχνει num φορές το Enter a note?    
**input.nextLine();** // SOS καθαρισμός του Buffer της αλλαγής γραμμής
