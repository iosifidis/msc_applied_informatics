# **Βασικές Αρχές Λειτουργίας RDBMS**

**1. Γιατί Χρησιμοποιούμε ένα ΣΔΒΔ (DBMS); (Διαφάνεια 1)**

Ανεξάρτητα από το μοντέλο (Σχεσιακό, NoSQL κ.λπ.), τα ΣΔΒΔ προσφέρουν σημαντικά πλεονεκτήματα σε σχέση με την απευθείας διαχείριση αρχείων:

*   **Ανεξαρτησία Δεδομένων και Αποτελεσματική Προσπέλαση:** Διαχωρίζει τη λογική οργάνωση (πώς ο χρήστης "βλέπει" τα δεδομένα) από τη φυσική αποθήκευση (πώς τα δεδομένα είναι στο δίσκο). Το ΣΔΒΔ παρέχει μηχανισμούς για γρήγορη προσπέλαση (π.χ. ευρετήρια).
*   **Μειωμένος Χρόνος Ανάπτυξης Εφαρμογών:** Οι προγραμματιστές δεν χρειάζεται να γράψουν τον κώδικα για τη διαχείριση αρχείων, ευρετήρια, ακεραιότητα, κ.λπ. Το ΣΔΒΔ παρέχει έτοιμα εργαλεία.
*   **Ακεραιότητα και Ασφάλεια Δεδομένων:** Το ΣΔΒΔ επιβάλλει κανόνες ακεραιότητας (π.χ. μοναδικά κλειδιά, αναφορική ακεραιότητα - foreign keys), διαχειρίζεται δικαιώματα πρόσβασης.
*   **Ενιαία Διαχείριση Δεδομένων:** Παρέχει ένα κεντρικοποιημένο σημείο για τη διαχείριση, αντίγραφα ασφαλείας, παρακολούθηση, κ.λπ.
*   **Ταυτόχρονη Προσπέλαση (Concurrent Access), Ανάκτηση από Καταρρεύσεις (Recovery):** Κρίσιμες δυνατότητες για πολυ-χρηστικά περιβάλλοντα. Επιτρέπει σε πολλούς χρήστες να εργάζονται ταυτόχρονα (με έλεγχο), και διασφαλίζει ότι τα δεδομένα παραμένουν σε συνεπή κατάσταση ακόμη και μετά από σφάλματα συστήματος/υλικού (μέσω ACID).

**2. Δομή ενός Τυπικού ΣΔΒΔ (Διαφάνεια 2)**

Ένα RDBMS έχει συνήθως μια πολυεπίπεδη (layered) αρχιτεκτονική. Τα κάτω επίπεδα αλληλεπιδρούν με τα μέσα αποθήκευσης (δίσκοι), ενώ τα άνω επίπεδα με τις εφαρμογές και τους χρήστες.

*   **Disk Space Management:** Διαχείριση χώρου στον δίσκο (ανάγνωση/γραφή σελίδων).
*   **Buffer Management:** Διαχείριση της Ενδιάμεσης Μνήμης (Buffer Pool) στην RAM. Τα δεδομένα πρέπει να μεταφερθούν στην RAM για επεξεργασία (βλ. Διαφάνεια 7).
*   **Files and Access Methods:** Οργάνωση δεδομένων σε "αρχεία" (π.χ. Heap Files, Sorted Files - βλ. Διαφάνειες 6, 9, 10) και παροχή μεθόδων προσπέλασης (π.χ. σάρωση αρχείου, χρήση ευρετηρίων - βλ. Διαφάνειες 8, 11-15).
*   **Relational Operators:** Υλοποίηση των πράξεων της σχεσιακής άλγεβρας (π.χ. Select, Project, Join, Aggregate) που εκτελούνται πάνω στα δεδομένα (βλ. Διαφάνειες 19-22).
*   **Query Optimization and Execution:** Μετατρέπει τα δηλωτικά ερωτήματα (π.χ. SQL) σε ένα εκτελέσιμο πλάνο χρησιμοποιώντας τους διαθέσιμους σχεσιακούς τελεστές και μεθόδους προσπέλασης. Επιλέγει το βέλτιστο πλάνο.
*   **Concurrency Control & Recovery:** Αυτοί οι κρίσιμοι μηχανισμοί διαπερνούν (interleave) τα υπόλοιπα επίπεδα, ιδιαίτερα αυτά που αλληλεπιδρούν με τον δίσκο και την ενδιάμεση μνήμη. Εγγυώνται τις ιδιότητες ACID (βλ. Διαφάνειες 23-38).

**3. Αποθήκευση Δεδομένων: Δίσκοι και Αρχεία (Κεφάλαιο 9, Διαφάνειες 3-6)**

*   **Φυσική Οργάνωση:** Τα δεδομένα αποθηκεύονται σε *σελίδες* (pages) στα μέσα αποθήκευσης (δίσκους). Οι σελίδες έχουν σταθερό μέγεθος.
*   **Εγγραφές Μεταβλητού Μήκους (Variable-Length Records):** Πώς αποθηκεύουμε δεδομένα όπου το μέγεθος κάθε εγγραφής μπορεί να διαφέρει (π.χ. πεδία Varchar, NULL).
    *   **Μορφοποίηση 1 (Διαχωριστικά):** Τα πεδία διαχωρίζονται με ειδικά σύμβολα. Απλή υλοποίηση, αλλά αναποτελεσματική για απευθείας προσπέλαση σε συγκεκριμένο πεδίο και για χειρισμό NULLs.
    *   **Μορφοποίηση 2 (Πίνακας Offset):** Στην αρχή της εγγραφής αποθηκεύεται το πλήθος των πεδίων, και μετά ένας πίνακας offset (διευθύνσεων) για κάθε πεδίο. Αποτελεσματική για απευθείας προσπέλαση, καλή διαχείριση NULLs. (Διαφάνεια 4)
*   **Μορφοποίηση Σελίδων (Page Organization):** Πώς τοποθετούμε τις εγγραφές μέσα σε μια σελίδα.
    *   Για εγγραφές *σταθερού* μήκους, η σελίδα μπορεί να χωριστεί σε slots σταθερού μεγέθους.
    *   Για εγγραφές *μεταβλητού* μήκους (αλλά και σταθερού), χρησιμοποιείται συχνά ένας **slot directory** στο τέλος της σελίδας. Κάθε είσοδος στον κατάλογο δείχνει την αρχή μιας εγγραφής στην σελίδα. (Διαφάνεια 5)
    *   **Σημαντικό:** Η χρήση slot directory επιτρέπει στις εγγραφές να μετακινηθούν μέσα στη σελίδα (π.χ. για αποκατάσταση χώρου από διαγραφές) χωρίς να αλλάξει το αναγνωριστικό τους (Record ID - Rid), το οποίο αποτελείται από <page_id, slot_number>. Αυτό είναι σημαντικό για τα ευρετήρια που δείχνουν σε Rids.
*   **Οργάνωση Αρχείων (File Organization):** Πώς οργανώνουμε τις σελίδες για να αποτελέσουν ένα "αρχείο" (table) στον δίσκο.
    *   **Αρχείο Σωρού (Heap File):** Η απλούστερη οργάνωση. Οι σελίδες του αρχείου δεν έχουν συγκεκριμένη διάταξη (τα δεδομένα δεν είναι ταξινομημένα) και οι νέες εγγραφές απλώς προστίθενται όπου υπάρχει διαθέσιμος χώρος. Απαιτεί πλήρη σάρωση (scan) για να βρεθεί μια συγκεκριμένη εγγραφή εκτός αν χρησιμοποιηθεί ευρετήριο. Για τη διαχείριση ελεύθερου χώρου στις σελίδες, ένα αρχείο σωρού μπορεί να διατηρεί έναν **κατάλογο σελίδων** (directory of pages), ο οποίος είναι πολύ μικρότερος από το να παρακολουθεί όλες τις εγγραφές. (Διαφάνιση 6, 9)
    *   **Ταξινομημένο Αρχείο (Sorted File):** Οι εγγραφές διατηρούνται ταξινομημένες βάσει της τιμής ενός ή περισσοτέρων πεδίων. Ιδανικό για ταχεία ανάκτηση βάσει του πεδίου ταξινόμησης και για εύρος (range) ερωτημάτων. Η εισαγωγή νέων εγγραφών μπορεί να είναι ακριβή, καθώς απαιτεί τη διατήρηση της ταξινόμησης. (Διαφάνεια 10)

**4. Ευρετηριοποίηση (Indexing) (Κεφάλαιο 8, Διαφάνειες 8, 11-15)**

Τα ευρετήρια (indexes) είναι δομές δεδομένων που χρησιμοποιούνται για την ταχεία εύρεση εγγραφών χωρίς να απαιτείται πλήρης σάρωση του αρχείου. Στα RDBMS, δείχνουν συνήθως στο Rid της εγγραφής (ειδικά οι secondary indexes).

*   **B+ Tree Indexes:**
    *   Είναι οι πιο συνηθισμένοι τύποι ευρετηρίων.
    *   Είναι δομές δέντρων πολλαπλών επιπέδων, όπου οι κόμβοι (nodes) αποθηκεύουν κλειδιά (keys) και δείκτες (pointers) προς άλλους κόμβους ή προς δεδομένα.
    *   Τα δεδομένα (ή οι Rids τους) βρίσκονται μόνο στα φύλλα (leaf nodes) του δέντρου. Τα φύλλα συνήθως συνδέονται μεταξύ τους για να επιτρέπουν αποδοτικές σαρώσεις εύρους τιμών.
    *   Ιδανικά για **ερωτήματα ισότητας (=)** και **ερωτήματα εύρους (>, <, >=, <=)**.
    *   Μπορούν να είναι **Primary/Clustered** (αν τα δεδομένα *ίδια* είναι ταξινομημένα βάσει του κλειδιού του ευρετηρίου - π.χ. ταξινομημένο αρχείο) ή **Secondary/Unclustered** (αν το ευρετήριο δείχνει στο Rid της εγγραφής και τα δεδομένα είναι οργανωμένα αλλού, π.χ. Heap File).
    *   (Διαφάνεια 11, 13, 14)
*   **Hash Indexes:**
    *   Χρησιμοποιούν μια συνάρτηση κατακερματισμού (hash function) για να αντιστοιχίσουν κλειδιά σε "κάδους" (buckets) ή θέσεις αποθήκευσης.
    *   Ιδανικά για **ερωτήματα ισότητας (=)**. Πολύ γρήγορα αν το hash function διανέμει ομοιόμορφα τα κλειδιά.
    *   **Δεν** είναι κατάλληλα για ερωτήματα εύρους, καθώς η σειρά των κλειδιών χάνεται στην κατακερματισμένη διάταξη.
    *   Όπως τα B+trees, μπορούν να είναι primary ή secondary.
    *   (Διαφάνεια 12, 15)

**5. Εξωτερική Ταξινόμηση (External Sorting) (Κεφάλαιο 13, Διαφάνειες 17-18)**

Όταν τα δεδομένα που θέλουμε να ταξινομήσουμε είναι μεγαλύτερα από την διαθέσιμη RAM (ενδιάμεση μνήμη), χρησιμοποιούμε **Εξωτερική Ταξινόμηση**. Ο πιο κοινός αλγόριθμος είναι ο **Εξωτερικός Αλγόριθμος Ταξινόμησης/Συγχώνευσης (External Merge Sort)**.

*   Βασική Ιδέα:
    1.  **Pass 0 (Δημιουργία Runs):** Διάβασε blocks δεδομένων (μέχρι τη χωρητικότητα B της ενδιάμεσης μνήμης), ταξινόμησε τα blocks αυτά στην μνήμη, και γράψε τα ως "sorted runs" (ταξινομημένες ακολουθίες) στον δίσκο.
    2.  **Επόμενα Passes (Συγχώνευση - Merging):** Διάβασε B-1 ταξινομημένους runs από τον δίσκο, συγχώνευσε τους σε ένα μεγαλύτερο ταξινομημένο run στην μνήμη, και γράψε αυτό το run στον δίσκο. Επανάλαβε μέχρι να μείνει μόνο ένας run, ο οποίος είναι το τελικό ταξινομημένο αρχείο.
*   Το κόστος (σε I/O operations) εξαρτάται από το πλήθος των περασμάτων, το οποίο με τη σειρά του εξαρτάται από το μέγεθος των δεδομένων (N σελίδες) και τη διαθέσιμη μνήμη (B σελίδες).

**6. Υπολογισμός Σχεσιακών Πράξεων (Relational Operators) (Κεφάλαιο 14, Διαφάνειες 19-22)**

Τα RDBMS πρέπει να υλοποιήσουν αποτελεσματικά τις πράξεις της σχεσιακής άλγεβρας για δεδομένα που βρίσκονται κυρίως στον δίσκο. Μία από τις πιο πολύπλοκες και κρίσιμες πράξεις είναι η **Σύζευξη (Join)**. Υπάρχουν διάφοροι αλγόριθμοι σύζευξης, καθένας με διαφορετικό κόστος σε I/O, ανάλογα με το μέγεθος των πινάκων και τη διαθέσιμη μνήμη:

*   **Σύζευξη με Εμφωλευμένους Βρόχους (Nested Loop Join):** Ο πιο απλός, αλλά συχνά ο πιο αργός. Για κάθε εγγραφή του ενός πίνακα, σάρωσε ολόκληρο τον άλλο πίνακα για ταιριάσματα. Η **Σύζευξη με Εμφωλευμένους Βρόχους κατά Μπλοκ (Block Nested Loop Join)** βελτιώνει την προσπέλαση διαβάζοντας blocks του ενός πίνακα στην μνήμη αντί για μία-μία εγγραφή. (Διαφάνεια 20)
*   **Σύζευξη με Ταξινόμηση και Συγχώνευση (Sort-Merge Join):** Ταξινόμησε και τους δύο πίνακες στο join key, και μετά συγχώνευσε τους ταξινομημένους πίνακες (σαν external merge sort) βρίσκοντας ταιριάσματα. Συχνά πιο αποδοτικός από τον Block Nested Loop Join για μεγάλους πίνακες. (Διαφάνεια 21)
*   **Σύζευξη με Κατακερματισμό (Hash Join):** Χρησιμοποίησε hash function για να χωρίσεις τους πίνακες σε buckets (partitioning phase), και μετά εφάρμοσε hash table για να βρεις ταιριάσματα σε κάθε bucket (probing phase). Αποτελεσματικός για equality joins. (Διαφάνεια 22)

**7. Έλεγχος Ταυτοχρονισμού (Concurrency Control) (Κεφάλαιο 17, Διαφάνειες 23-28)**

Όταν πολλοί χρήστες/εφαρμογές προσπελαύνουν ταυτόχρονα τη βάση δεδομένων (παράλληλη εκτέλεση συναλλαγών), μπορεί να προκύψουν προβλήματα συνοχής. Ο **Έλεγχος Ταυτοχρονισμού** διασφαλίζει ότι το αποτέλεσμα είναι ίδιο σαν να εκτελούνταν οι συναλλαγές σειριακά.

*   **Χρονοπρογράμματα (Schedules):** Η διάταξη με την οποία οι ενέργειες (π.χ. Read, Write, Commit, Abort) των παράλληλων συναλλαγών εκτελούνται στο χρόνο.
*   **Συγκρουσιακώς Σειριοποιησιμότητα (Conflict Serializability):** Ένα χρονοπρόγραμμα θεωρείται "καλό" αν είναι συγκρουσιακώς ισοδύναμο με κάποιο σειριακό χρονοπρόγραμμα. Δύο ενέργειες (από διαφορετικές συναλλαγές) είναι συγκρουσιακές αν προσπελαύνουν το *ίδιο* στοιχείο δεδομένων και τουλάχιστον μία από αυτές είναι εγγραφή (Write). (Διαφάνεια 24)
*   Ένα χρονοπρόγραμμα είναι συγκρουσιακώς σειριοποιήσιμο **αν και μόνο αν** το **γράφημα προτεραιότητας (Precedence Graph)** δεν έχει κύκλους. Ένας κόμβος στο γράφημα είναι μια συναλλαγή, και μια ακμή T_i -> T_j σημαίνει ότι μια ενέργεια του T_i συγκρούστηκε με μια ενέργεια του T_j και η ενέργεια του T_i εκτελέστηκε πρώτη. (Διαφάνεια 25, 28)
*   **Πρωτόκολλο Κλειδώματος Δυο-Φάσεων (Two-Phase Locking - 2PL):**
    *   Ένα ευρέως χρησιμοποιούμενο πρωτόκολλο ελέγχου ταυτοχρονισμού.
    *   Κάθε συναλλαγή πρέπει να αποκτά κλειδαριά (lock) σε ένα στοιχείο δεδομένων πριν το προσπελάσει: Shared (S) lock για Read, Exclusive (X) lock για Write. Ένα X lock αποκλείει όλα τα άλλα locks, ένα S lock επιτρέπει άλλα S locks.
    *   Έχει δύο φάσεις: **Growing Phase** (η συναλλαγή αποκτά locks, δεν αποδεσμεύει) και **Shrinking Phase** (η συναλλαγή αποδεσμεύει locks, δεν αποκτά νέα).
    *   **Σημαντικό:** Το 2PL **εγγυάται** συγκρουσιακή σειριοποιησιμότητα. (Διαφάνεια 26, 27)

**8. Επαναφορά του Συστήματος (Recovery) (Κεφάλαιο 18, Διαφάνειες 29-38)**

Ο **Διαχειριστής Επαναφοράς (Recovery Manager)** είναι υπεύθυνος για την αποκατάσταση της βάσης σε συνεπή κατάσταση μετά από μια κατάρρευση του συστήματος (crash), διασφαλίζοντας κυρίως την **Ατομικότητα (Atomicity)** και την **Μονιμότητα (Durability)** των συναλλαγών.

*   **Βασική Τεχνική: Διατήρηση Ιστορικού / Logging:**
    *   Κάθε αλλαγή στα δεδομένα καταγράφεται σε ένα **Ιστορικό (Log)** πριν (WAL) ή κατά την εφαρμογή της αλλαγής στη σελίδα δεδομένων.
    *   Το log είναι μια σειριακή ακολουθία από **Log Records**, αποθηκευμένα σε σταθερό μέσο (π.χ. ξεχωριστός δίσκος).
    *   Κάθε log record έχει ένα μοναδικό **LSN (Log Sequence Number)** που αυξάνει συνέχεια.
    *   Οι log records περιέχουν πληροφορίες για την αλλαγή (XID, pageID, offset, length) και δεδομένα για **UNDO** (παλιά τιμή - before-image) και **REDO** (νέα τιμή - after-image). (Διαφάνεια 32, 35)
    *   Κάθε σελίδα δεδομένων στον δίσκο περιέχει επίσης ένα **pageLSN**, το LSN της *τελευταίας* log record που την τροποποίησε. (Διαφάνεια 34)
    *   Το σύστημα παρακολουθεί το **flushedLSN**, το μεγαλύτερο LSN που έχει γραφεί οριστικά στο log στον δίσκο. (Διαφάνεια 34)
*   **Πρωτόκολλο Write-Ahead Logging (WAL):**
    *   **Κανόνας 1:** Μία αλλαγμένη σελίδα δεδομένων δεν μπορεί να γραφεί στον δίσκο *πριν* το αντίστοιχο log record (της αλλαγής) γραφεί οριστικά στο log στον δίσκο (pageLSN <= flushedLSN). Αυτό εξασφαλίζει ότι αν μια αλλαγή είναι στο δίσκο (ως μέρος μιας σελίδας δεδομένων), γνωρίζουμε πώς να την αναιρέσουμε ή να την επαναλάβουμε (το log record υπάρχει). (Εγγυάται Atomicity)
    *   **Κανόνας 2:** Όλα τα log records μιας συναλλαγής πρέπει να γραφούν στο log στον δίσκο *πριν* γραφεί η log record **Commit** της ίδιας συναλλαγής στο log στον δίσκο. Αυτό εξασφαλίζει ότι αν μια συναλλαγή δηλωθεί ως Committed, όλες της οι αλλαγές έχουν καταγραφεί στο log και μπορούν να εφαρμοστούν μετά την κατάρρευση (REDO). (Εγγυάται Durability)
    *   Ο αλγόριθμος **ARIES** (Analysis, Redo, Undo) είναι ένα πρωτόκολλο που ακολουθεί τους κανόνες WAL.
*   **Φάσεις Επαναφοράς (μετά την Κατάρρευση - κατά ARIES):**
    1.  **Analysis (Ανάλυση):** Ξεκινώντας από το τελευταίο **σημείο ελέγχου (checkpoint)**, όπου καταγράφεται η κατάσταση του συστήματος (π.χ. ενεργές συναλλαγές, ποιες σελίδες ήταν "dirty" στην μνήμη), σκανάρει το log **προς τα εμπρός** μέχρι το σημείο της κατάρρευσης. Σκοπός: να εντοπιστούν ποιες συναλλαγές ολοκληρώθηκαν (Committed/Aborted) και ποιες ήταν ακόμα ενεργές (Active) κατά την κατάρρευση, και να δημιουργηθεί ένας πίνακας με τις "dirty" σελίδες και το earliest LSN που χρειάζεται για την επαναφορά τους (recLSN). (Διαφάνεια 37)
    2.  **REDO (Επανεκτέλεση):** Σκανάρει το log **προς τα εμπρός**, ξεκινώντας από το earliest LSN που εντοπίστηκε στην φάση Analysis. Εφαρμόζει *ξανά* όλες τις αλλαγές που βλέπει στο log (ανεξαρτήτως αν η συναλλαγή ολοκληρώθηκε ή απέτυχε, ακόμη και αν είναι CLR), εκτός αν η σελίδα στην οποία αναφέρεται η αλλαγή έχει pageLSN μεγαλύτερο ή ίσο από το LSN του log record (σημαίνει ότι η αλλαγή έχει ήδη εφαρμοστεί οριστικά στον δίσκο). Σκοπός: να επαναφέρει τη βάση στην κατάσταση που βρισκόταν ακριβώς πριν την κατάρρευση. (Διαφάνεια 37)
    3.  **UNDO (Αναίρεση):** Σκανάρει το log **προς τα πίσω**, ξεκινώντας από το σημείο κατάρρευσης. Για κάθε συναλλαγή που βρέθηκε ως "Active" στην φάση Analysis, αναιρεί (UNDO) τις ενέργειές της με αντίστροφη σειρά (από το μεγαλύτερο LSN προς το μικρότερο). Κάθε UNDO ενέργεια γράφει στο log ένα **Compensation Log Record (CLR)** *πριν* εφαρμοστεί η αναίρεση στην σελίδα. Σκοπός: να αναιρεθούν οι μη-ολοκληρωμένες αλλαγές, φέρνοντας την βάση σε συνεπή κατάσταση. (Διαφάνεια 37)

**Σύνδεση με NoSQL / Υπολογιστικό Νέφος:**

Αυτοί οι λεπτομερείς μηχανισμοί (indexing, join algorithms, 2PL concurrency control, ARIES recovery) είναι θεμελιώδεις για την παροχή ACID εγγυήσεων στα παραδοσιακά RDBMS. Όταν όμως μιλάμε για κατανεμημένα συστήματα σε Web-scale (Big Data, Cloud), όπως τα NoSQL, κάποιοι από αυτούς τους μηχανισμούς γίνονται "ακριβοί" ή μη πρακτικοί, ειδικά όταν αντιμετωπίζουν διαμερίσεις δικτύου (Partition Tolerance στο CAP Theorem).

Για παράδειγμα:
*   Οι κατανεμημένες συναλλαγές με αυστηρό 2PL σε πολλά nodes είναι πολύπλοκες και ακριβές (επηρεάζουν Availability). Τα NoSQL συχνά χαλαρώνουν την Isolation (I) ή την Consistency (C) για να επιτύχουν καλύτερη Διαθεσιμότητα (A) και Κλιμακούμενοτητα (Horizontal Scalability).
*   Οι JOINs σε κατανεμημένα δεδομένα (ιδιαίτερα μεταξύ διαφορετικών shards) είναι δύσκολοι και δαπανηροί στα NoSQL, γι' αυτό συχνά προτιμάται η απο-κανονικοποίηση (Denormalization) και η συσσώματωση (Aggregation) των δεδομένων.
*   Οι μηχανισμοί Recovery όπως το ARIES είναι σχεδιασμένοι κυρίως για single-node ή share-everything/share-disk συστήματα. Σε κατανεμημένα, share-nothing περιβάλλοντα, η ανάκτηση πρέπει να διαχειριστεί βλάβες σε πολλούς κόμβους ταυτόχρονα, οδηγώντας σε διαφορετικές προσεγγίσεις (π.χ. Replication based recovery).
