# **Κατανεμημένες Βάσεις Δεδομένων (Distributed Databases)**  

**1. Εισαγωγή στις Κατανεμημένες Βάσεις Δεδομένων (Διαφάνειες 1-3)**

*   **Ορισμός:** Σε μια κατανεμημένη βάση δεδομένων, τα δεδομένα αποθηκεύονται σε *πολλαπλούς κόμβους (sites)*, όπου ο καθένας διαχειρίζεταιται από ένα ΣΔΒΔ που μπορεί να λειτουργεί *ανεξάρτητα*. Οι κόμβοι επικοινωνούν μέσω δικτύου.
*   **Ιδανικοί Στόχοι (του "παραδοσιακού" μοντέλου κατανεμημένων RDBMS):**
    *   **Distributed Data Independence (Κατανεμημένη Ανεξαρτησία Δεδομένων):** Οι χρήστες/εφαρμογές *δεν* θα πρέπει να γνωρίζουν πού βρίσκονται φυσικά τα δεδομένα. Επέκταση της Φυσικής και Λογικής Ανεξαρτησίας Δεδομένων του κεντρικού RDBMS.
    *   **Distributed Transaction Atomicity (Ατομικότητα Κατανεμημένων Συναλλαγών):** Οι χρήστες θα πρέπει να μπορούν να γράφουν συναλλαγές (Xacts) που προσπελαύνουν δεδομένα σε *πολλούς κόμβους* με την ίδια ευκολία και εγγύηση ACID (ιδιαίτερα Atomicity) όπως οι συναλλαγές που αφορούν έναν μόνο κόμβο (local Xacts).
*   **Σύγχρονες Τάσεις και Πραγματικότητα:** Στα πιο σύγχρονα, *ολικά* κατανεμημένα συστήματα (ειδικά σε γεωγραφικά διασκορπισμένους κόμβους, όπως στο Cloud):
    *   Οι ιδιότητες Distributed Data Independence και Distributed Transaction Atomicity **δεν υποστηρίζονται αποδοτικά**.
    *   Αυτές οι ιδιότητες **μπορεί να μην είναι καν επιθυμητές**, λόγω της πολυπλοκότητας και του λειτουργικού overhead (π.χ. κόστους επικοινωνίας, διαχείρισης σφαλμάτων) που συνεπάγονται για την απόκρυψη της τοποθεσίας των δεδομένων από τον χρήστη/εφαρμογή.
    *   Αυτό εξηγεί εν μέρει γιατί πολλά συστήματα NoSQL αναγκάζουν τον χρήστη/προγραμματιστή να έχει **επίγνωση** της κατανομής των δεδομένων και να χειριστεί ο ίδιος ζητήματα συνέπειας και διαθεσιμότητας (σε αντίθεση με το ιδανικό του παραδοσιακού κατανεμημένου RDBMS).

**2. Τύποι και Αρχιτεκτονικές (Διαφάνειες 4-5)**

*   **Τύποι Κατανεμημένων Βάσεων:**
    *   **Ομογενείς (Homogeneous):** Όλοι οι κόμβοι τρέχουν το *ίδιο* ΣΔΒΔ. Η διαχείριση είναι απλούστερη.
    *   **Ετερογενείς (Heterogeneous):** Διαφορετικοί κόμβοι τρέχουν *διαφορετικά* ΣΔΒΔ (είτε διαφορετικά RDBMS, είτε συνδυασμό RDBMS και non-relational DBMSs). Απαιτούν επιπλέον λογισμικό "πύλης" (Gateway) ή middleware για διαλειτουργικότητα. Πιο σύνθετη διαχείριση.
*   **Αρχιτεκτονικές Κατανεμημένων ΣΔΒΔ:**
    *   **Client-Server:** Ένας client στέλνει ένα ερώτημα σε ένα *μοναδικό* server κόμβο (ίσως αυτόν που έχει τα δεδομένα). Όλη η επεξεργασία (join, filter κλπ.) γίνεται στον server. Μπορεί να είναι "λεπτοί" (thin clients - λίγη λογική, βασίζονται στον server) ή "παχείς" (fat clients - περισσότερη λογική, π.χ. client-side caching).
    *   **Collaborating-Server:** Ένα ερώτημα μπορεί να εκτείνεται σε *πολλαπλούς κόμβους*. Οι server κόμβοι συνεργάζονται μεταξύ τους για την εκτέλεση του ερωτήματος (π.χ. ένας server ζητά δεδομένα ή υπο-αποτελέσματα από άλλους servers). Αυτό επιτρέπει πιο σύνθετη κατανεμημένη επεξεργασία (π.χ. εκτέλεση μέρους του ερωτήματος σε έναν κόμβο, άλλου μέρους σε άλλον). Αυτή η αρχιτεκτονική μοιάζει περισσότερο με την προσέγγιση που βρίσκουμε σε κατανεμημένα συστήματα Big Data.

**3. Αποθήκευση Δεδομένων: Κατακερματισμός και Αναπαραγωγή (Διαφάνεια 6)**

*   **Κατακερματισμός (Fragmentation):** Διαμέριση μιας σχεσιακής σχέσης (πίνακα) σε μικρότερα κομμάτια που αποθηκεύονται σε διαφορετικούς κόμβους.
    *   **Οριζόντιος Κατακερματισμός (Horizontal):** Ο πίνακας διαμερίζεται βάσει των γραμμών. Κάθε κομμάτι περιέχει ένα υποσύνολο των γραμμών. Τα υποσύνολα είναι συνήθως *ξένα μεταξύ τους* (disjoint).
    *   **Κάθετος Κατακερματισμός (Vertical):** Ο πίνακας διαμερίζεται βάσει των στηλών. Κάθε κομμάτι περιέχει ένα υποσύνολο των στηλών *συν* το TID (Tuple ID) για να είναι δυνατή η ανασύνθεση (lossless-join) του πίνακα με σύζευξη στα TID.
*   **Αναπαραγωγή (Replication):** Αποθήκευση αντιγράφων (copies) ολόκληρων ή μερών μιας σχέσης (fragment) σε *πολλαπλούς* κόμβους.
    *   **Πλεονεκτήματα:** Αυξημένη διαθεσιμότητα (αν ένας κόμβος με ένα αντίγραφο αποτύχει, άλλα αντίγραφα είναι διαθέσιμα). Ταχύτερη εκτέλεση ερωτημάτων (οι αναγνώσεις μπορούν να εξυπηρετηθούν από τον κοντινότερο ή λιγότερο φορτωμένο κόμβο που έχει ένα αντίγραφο).
    *   **Συγχρονισμένη vs. Ασύγχρονη (Synchronous vs. Asynchronous):** Διαφέρουν στην *επικαιρότητα* (how current) των αντιγράφων.
        *   **Συγχρονισμένη Αναπαραγωγή:** Όλα τα αντίγραφα διατηρούνται *εντελώς συγχρονισμένα*. Μια ενημέρωση πρέπει να εφαρμοστεί (ή να επιβεβαιωθεί) σε όλα (ή σε ένα quorum) τα αντίγραφα *πριν* η συναλλαγή ολοκληρωθεί (commit). Παρέχει ισχυρή συνέπεια αλλά είναι ακριβή και ευάλωτη σε αποτυχίες (βλ. παρακάτω).
        *   **Ασύγχρονη Αναπαραγωγή:** Τα αντίγραφα ενημερώνονται περιοδικά, με κάποια καθυστέρηση. Τα διάφορα αντίγραφα *μπορεί να μην είναι συγχρονισμένα* για κάποιο χρονικό διάστημα. Οι χρήστες/εφαρμογές *πρέπει να γνωρίζουν* την πιθανότητα ανάγνωσης παλιών (stale) δεδομένων. Μοιάζει με την Eventual Consistency των NoSQL. Πιο αποδοτική και ανθεκτική σε αποτυχίες δικτύου.

**4. Διαχείριση Κατανεμημένου Καταλόγου (Distributed Catalog Management) (Διαφάνεια 7)**

Ο κατάλογος (catalog) ή μεταδεδομένα (metadata) της βάσης περιγράφει τα αντικείμενα (σχέσεις, κατακερματισμοί, αντίγραφα, ευρετήρια κλπ.). Σε ένα κατανεμημένο σύστημα, ο κατάλογος πρέπει επίσης να είναι κατανεμημένος και να παρακολουθεί πώς τα δεδομένα (fragments, replicas) διανέμονται στους κόμβους.

*   Κάθε αντίγραφο (replica) κάθε κατακερματισμού (fragment) πρέπει να έχει ένα **όνομα**. Για τη διατήρηση της **τοπικής αυτονομίας (local autonomy)** κάθε κόμβου, ένα όνομα μπορεί να είναι της μορφής `<τοπικό-όνομα, κόμβος-γέννησης>` (<local-name, birth-site>).
*   Κάθε κόμβος διατηρεί τον **κατάλογο του κόμβου (Site Catalog)** του: Περιγράφει *όλα* τα αντικείμενα που βρίσκονται *σε αυτόν* τον κόμβο και παρακολουθεί τα αντίγραφα σχέσεων που *δημιουργήθηκαν* σε αυτόν τον κόμβο.
*   Για να βρει κανείς μια σχέση, ψάχνει στον κατάλογο του κόμβου *γέννησής* της.
*   Ο κόμβος γέννησης (birth-site) μιας σχέσης **ποτέ δεν αλλάζει**, ακόμα και αν η σχέση μετακινηθεί ή αναπαραχθεί αλλού. Αυτό παρέχει ένα σταθερό σημείο εκκίνησης για την αναζήτηση των πληροφοριών της σχέσης.

**5. Εκτέλεση Κατανεμημένων Ερωτημάτων (Distributed Queries) (Διαφάνειες 8-11)**

Η εκτέλεση ενός ερωτήματος σε κατανεμημένα δεδομένα είναι πιο πολύπλοκη από ό,τι σε κεντρικό σύστημα, καθώς περιλαμβάνει κόστη **επικοινωνίας** (shipping data/results between sites).

*   **Παραδείγματα Αναλόγως του Κατακερματισμού/Αναπαραγωγής:**
    *   **Οριζόντιος Κατακερματισμός:** Ένα aggregate (π.χ. AVG) σε έναν πίνακα κατακερματισμένο οριζόντια, απαιτεί υπολογισμό του aggregate σε κάθε κόμβο (SUM, COUNT) και μετά συνδυασμό των υπο-αποτελεσμάτων στον κόμβο που ζήτησε το ερώτημα. Αν το `WHERE` clause του ερωτήματος "ταιριάζει" με το κριτήριο κατακερματισμού, ίσως χρειάζεται να προσπελαστεί μόνο ένας κόμβος.
    *   **Κάθετος Κατακερματισμός:** Ένα ερώτημα που χρειάζεται στήλες από διαφορετικούς κατακερματισμούς (Fragments) του ίδιου πίνακα, απαιτεί την ανασύνθεση (reconstruction) του πίνακα με Join στα TID *πριν* την αξιολόγηση του ερωτήματος. Αυτό συνεπάγεται αποστολή δεδομένων και υπολογιστικό κόστος Join.
    *   **Αναπαραγωγή:** Αν ο πίνακας είναι πλήρως αναπαραγόμενος, ο κόμβος εκτέλεσης του ερωτήματος μπορεί απλώς να επιλέξει το αντίγραφο σε έναν κόμβο (π.χ. τον τοπικό, αν υπάρχει, ή τον πλησιέστερο) και να εκτελέσει το ερώτημα εκεί. Η επιλογή γίνεται βάσει κόστους (τοπικού κόστους επεξεργασίας + κόστους αποστολής αποτελέσματος στον client).
*   **Κατανεμημένες Συζεύξεις (Distributed Joins) (Διαφάνειες 9-11):** Η σύζευξη πινάκων που βρίσκονται σε διαφορετικούς κόμβους είναι μια από τις πιο ακριβές πράξεις. Βασικές στρατηγικές:
    *   **Fetch as Needed (Προσκόμιση Όταν Χρειάζεται):** Χρησιμοποίησε αλγόριθμο Join όπως ο Nested Loop Join. Για κάθε εγγραφή του εξωτερικού πίνακα (outer, π.χ. Sailors στη London), πήγαινε και ψάξε για ταιριάσματα στον εσωτερικό πίνακα (inner, Reserves στο Paris). Αν ο Sailors είναι μικρός και ο Reserves μεγάλος, και τα κόστη επικοινωνίας (S, Shipping) είναι συγκριτικά με τα κόστη δίσκου (D, Disk I/O), αυτό μπορεί να είναι πολύ ακριβό, καθώς για κάθε γραμμή Sailor στέλνεις request για γραμμές Reserves στο Paris.
    *   **Ship to One Site (Αποστολή σε Ένα Κόμβο):** Μετακίνησε έναν ή και τους δύο πίνακες σε έναν κόμβο και εκτέλεσε το Join εκεί χρησιμοποιώντας κάποιον τοπικό αλγόριθμο (π.χ. Sort-Merge, Hash Join). Αν ο ένας πίνακας είναι πολύ μικρός, στέλνεις τον μικρό στον κόμβο που έχει τον μεγάλο. Αν και οι δύο είναι μεγάλοι, μπορεί να συμφέρει να στείλεις *και τους δύο* στον κόμβο όπου ζητήθηκε το αποτέλεσμα του ερωτήματος και να κάνεις το Join εκεί. Το κόστος εξαρτάται από τα μεγέθη των πινάκων και τα κόστη επικοινωνίας.
    *   **Semijoin (Ημι-σύζευξη):** Βελτιστοποίηση για μείωση του όγκου δεδομένων που αποστέλλονται. Π.χ. για Join R `bowtie` S (R στη London, S στο Paris), αντί να στείλεις ολόκληρο τον R στο Paris:
        1.  Στη London: Κράτησε μόνο τις στήλες του R που συμμετέχουν στο Join και φτιάξε μια προβολή (`project` R onto join columns).
        2.  Στη London: Στείλε αυτή την *προβολή* (συνήθως πολύ μικρότερη από ολόκληρο τον R) στο Paris.
        3.  Στο Paris: Κάνε Join την προβολή του R με τον S. Αυτό "μειώνει" τον S, κρατώντας μόνο τις γραμμές του S που έχουν ταίρι στον R. Το αποτέλεσμα λέγεται `reduction` του S ως προς R.
        4.  Στο Paris: Στείλε αυτό το `reduction` του S (μικρότερο από τον αρχικό S) στη London.
        5.  Στη London: Κάνε το τελικό Join του αρχικού R με το `reduction` του S.
        Στόχος: να ανταλλάξεις το κόστος αποστολής ενός ολόκληρου πίνακα με το κόστος αποστολής μιας μικρότερης προβολής + ενός μικρότερου reduction. Ιδιαίτερα χρήσιμο αν υπάρχει `SELECT` clause στον έναν πίνακα που μειώνει τις γραμμές πριν το Join, και το αποτέλεσμα του ερωτήματος ζητείται στον κόμβο που βρίσκεται ο άλλος πίνακας.
    *   **Bloomjoin:** Παρόμοια ιδέα με το Semijoin, αλλά αντί να στείλεις την προβολή, στέλνεις ένα **bit-vector** (Bloom Filter) που αντιπροσωπεύει τα κλειδιά Join ενός πίνακα. Ο άλλος κόμβος χρησιμοποιεί αυτό το bit-vector για να φιλτράρει ( discard tuples) τις δικές του γραμμές. Το bit-vector είναι ακόμα πιο φθηνό στην αποστολή, αλλά το φιλτράρισμα *δεν είναι τέλειο* (μπορεί να υπάρχουν false positives - να περάσουν γραμμές που δεν έχουν πραγματικό ταίρι, αν και όχι false negatives - καμία γραμμή με ταίρι δεν χάνεται). Πρέπει μετά να γίνει το τελικό Join για να επιβεβαιωθούν τα ταιριάσματα.
*   **Βελτιστοποίηση Κατανεμημένων Ερωτημάτων (Distributed Query Optimization) (Διαφάνεια 12):** Ακολουθεί τη φιλοσοφία του cost-based optimization των κεντρικών συστημάτων (εξέταση όλων των δυνατών σχεδίων εκτέλεσης, επιλογή του φθηνότερου). Οι διαφορές:
    1.  **Κόστος Επικοινωνίας:** Τα κόστη αποστολής δεδομένων/αποτελεσμάτων μεταξύ κόμβων πρέπει να ληφθούν υπόψη και συνήθως είναι τα κυρίαρχα.
    2.  **Τοπική Αυτονομία:** Ο κεντρικός "βελτιστοποιητής" παράγει ένα *καθολικό πλάνο (global plan)*, αλλά οι *τοπικοί βελτιστοποιητές* στους server κόμβους μπορούν να προσαρμόσουν/βελτιώσουν τοπικά μέρη του πλάνου.
    3.  **Νέες Μέθοδοι Join:** Οι αλγόριθμοι όπως Semijoin και Bloomjoin προσθέτουν νέες εναλλακτικές στα πλάνα εκτέλεσης.

**6. Ενημέρωση Κατανεμημένων Δεδομένων και Αναπαραγωγή (Διαφάνειες 13-21)**

Η ενημέρωση δεδομένων σε κατανεμημένα συστήματα, ειδικά όταν υπάρχουν αντίγραφα (replication), δημιουργεί προκλήσεις για τη διατήρηση της συνέπειας.

*   **Συγχρονισμένη Αναπαραγωγή (Synchronous Replication) (Διαφάνειες 13-15):**
    *   Όλα τα αντίγραφα (ή fragments) που επηρεάζονται από μια ενημέρωση **πρέπει να ενημερωθούν (ή να επιβεβαιώσουν την ετοιμότητα)** *πριν* η συναλλαγή (Xact) ολοκληρωθεί (commit).
    *   Η κατανομή δεδομένων **είναι αόρατη** (transparent) στους χρήστες.
    *   **Μειονεκτήματα/Κόστος:** Απαιτεί **κατανεμημένο κλείδωμα (distributed locking)** σε *όλα* τα επηρεαζόμενα αντίγραφα πριν από την commit phase. Αν ένας κόμβος ή μια σύνδεση αποτύχει, η συναλλαγή **μπλοκάρει** (blocked) και δεν μπορεί να ολοκληρωθεί μέχρι να αποκατασταθεί. Ακόμη και χωρίς αποτυχίες, το commit απαιτεί ένα **ακριβό πρωτόκολλο commit (commit protocol)** με πολλές ανταλλαγές μηνυμάτων (messages).
    *   **Στρατηγικές:**
        *   **Voting (Ψηφοφορία):** Μια συναλλαγή γράφει σε *πλειοψηφία (majority)* αντιγράφων για να τροποποιήσει ένα αντικείμενο. Διαβάζει από *αρκετά* αντίγραφα για να είναι σίγουρη ότι έχει τουλάχιστον το πιο πρόσφατο. Κάθε αντίγραφο έχει αριθμό έκδοσης (version number). Συνήθως *μη ελκυστική* καθώς οι αναγνώσεις είναι συνηθισμένες και γίνονται πιο αργές.
        *   **Read-any Write-all (Διάβασε οποιοδήποτε, Γράψε σε όλα):** Μια ενημέρωση πρέπει να εφαρμοστεί σε **όλα** τα αντίγραφα πριν το commit. Μια ανάγνωση μπορεί να γίνει από **οποιοδήποτε** αντίγραφο. Πιο αργές εγγραφές, ταχύτερες αναγνώσεις σε σχέση με το Voting. Η πιο κοινή προσέγγιση σε συγχρονισμένη αναπαραγωγή.
    *   **Σημαντικό:** Λόγω του υψηλού κόστους και της ευπάθειας σε αποτυχίες, η συγχρονισμένη αναπαραγωγή **δεν είναι πλέον ευρέως διαδεδομένη** για μεγάλα κατανεμημένα συστήματα.

*   **Ασύγχρονη Αναπαραγωγή (Asynchronous Replication) (Διαφάνειες 13, 16-21):**
    *   Επιτρέπει στη συναλλαγή (Xact) που κάνει την τροποποίηση να ολοκληρωθεί (commit) *πριν* όλα τα αντίγραφα έχουν ενημερωθεί.
    *   Τα αντίγραφα ενημερώνονται **περιοδικά**. Μπορεί να υπάρχουν χρονικές περίοδοι που τα αντίγραφα **δεν είναι συγχρονισμένα (out-of-sync)**.
    *   Οι χρήστες/εφαρμογές **πρέπει να γνωρίζουν** την πιθανότητα ανάγνωσης παλιών δεδομένων και **δεν είναι αόρατη** η κατανομή των δεδομένων. Αυτή η προσέγγιση ακολουθείται από τα περισσότερα σύγχρονα συστήματα (συμβιβασμός CAP: προτεραιότητα σε Availability+Partition Tolerance έναντι Consistency).
    *   **Δύο Βασικές Προσεγγίσεις:**
        *   **Primary Site Replication (Αναπαραγωγή Κύριου Κόμβου) (Διαφάνειες 18-20):** Ένα αντίγραφο μιας σχέσης ορίζεται ως ο **κύριος κόμβος (primary) ή master copy**. Τα αντίγραφα σε άλλους κόμβους (δευτερεύοντες κόμβοι - secondary copies) **δεν μπορούν να ενημερωθούν απευθείας**. Ο primary κόμβος "δημοσιεύει" (publishes) τις αλλαγές. Οι δευτερεύοντες κόμβοι "εγγράφονται" (subscribe) για να λαμβάνουν αυτές τις αλλαγές (συχνά για υποσύνολα των δεδομένων - fragments).
            *   **Διάδοση Αλλαγών (Change Propagation):** Γίνεται σε δύο βήματα:
                1.  **Capture (Σύλληψη):** Καταγραφή των αλλαγών που έγιναν στον primary κόμβο από ολοκληρωμένες (committed) συναλλαγές. Μπορεί να γίνει:
                    *   **Log-Based Capture:** Χρησιμοποιεί το log του RDBMS (αυτό που χρησιμοποιείται για recovery) για να παράγει έναν πίνακα με αλλαγμένα δεδομένα (Change Data Table - CDT). Αποτελεσματικό αλλά βασίζεται στις ιδιαιτερότητες του log του κάθε RDBMS.
                    *   **Procedural Capture:** Μια διαδικασία (π.χ. trigger) καλείται αυτόματα όταν γίνονται αλλαγές και συλλαμβάνει τα δεδομένα (συχνά ως ένα στιγμιότυπο - snapshot). Πιο ευέλικτη, αλλά συνήθως λιγότερο αποδοτική.
                2.  **Apply (Εφαρμογή):** Οι δευτερεύοντες κόμβοι λαμβάνουν περιοδικά (με χρονοδιακόπτη ή όποτε οριστεί) τις αλλαγές (ως snapshots ή από το CDT) από τον primary κόμβο και ενημερώνουν τα αντίγραφά τους. Αν το αντίγραφο είναι μια **υλοποιημένη όψη (materialized view)** του primary, η αναπαραγωγή ισοδυναμεί με σταδιακή ενημέρωση (incrementally updating) της materialized view. Log-based capture με συνεχή εφαρμογή ελαχιστοποιεί την καθυστέρηση (delay), ενώ Procedural capture με application-driven apply είναι πιο ευέλικτη.
        *   **Peer-to-Peer Replication (Αναπαραγωγή Peer-to-Peer) (Διαφάνεια 17):** Περισσότερα από ένα αντίγραφα ενός αντικειμένου μπορούν να είναι **master copies** (ή "updatable"). Οι αλλαγές σε ένα master πρέπει να διαδίδονται στα άλλα.
            *   **Πρόκληση:** Αν δύο master αντίγραφα αλλάξουν με τρόπο που δημιουργεί **σύγκρουση (conflicting manner)** (π.χ. διαφορετική αλλαγή στο ίδιο στοιχείο από διαφορετικές συναλλαγές σε διαφορετικούς master κόμβους), αυτό πρέπει να **επιλυθεί (resolved)** με κάποιον μηχανισμό (π.χ. rule-based, timestamp-based, user-defined).
            *   Λειτουργεί καλύτερα **όταν δεν προκύπτουν συγκρούσεις** (π.χ. κάθε master κόμβος κατέχει ένα ξένο υποσύνολο δεδομένων, ή τα δικαιώματα ενημέρωσης για ένα αντικείμενο ανήκουν σε ένα μόνο master κόμβο κάθε φορά). Μοιάζει με το μοντέλο Dynamo της Amazon και την ανάγκη επίλυσης συγκρούσεων.
    *   **Αποθήκες Δεδομένων (Data Warehousing) (Διαφάνεια 21):** Οι αποθήκες δεδομένων, που συγκεντρώνουν δεδομένα από πολλές πηγές σε έναν κεντρικό χώρο για αναλυτικά ερωτήματα, μπορούν να θεωρηθούν ως μια ειδική περίπτωση **ασύγχρονης αναπαραγωγής**. Οι πηγές δεδομένων είναι συχνά ετερογενείς (διαφορετικά RDBMS). Βασική έμφαση δίνεται στο **"καθάρισμα" (cleaning) των δεδομένων** και την επίλυση αναντιστοιχιών κατά τη δημιουργία αντιγράφων στην αποθήκη. Procedural capture και application-driven apply είναι κατάλληλες για αυτό το περιβάλλον, επιτρέποντας custom μετασχηματισμούς (ETL - Extract, Transform, Load).

**7. Κατανεμημένος Έλεγχος Συναλλαγών (Distributed Transaction Control) (Διαφάνειες 22-31)**

Για να διασφαλιστούν οι ιδιότητες ACID, ιδίως Atomicity και Isolation, σε συναλλαγές που αφορούν πολλούς κόμβους (κατανεμημένες συναλλαγές), χρειάζονται εξειδικευμένοι μηχανισμοί.

*   **Κατανεμημένο Κλείδωμα (Distributed Locking) (Διαφάνεια 22):** Πώς διαχειριζόμαστε κλειδαριές (locks) για αντικείμενα που βρίσκονται σε πολλούς κόμβους;
    *   **Centralized (Κεντρικοποιημένο):** Ένας κόμβος διαχειρίζεται *όλες* τις κλειδαριές για όλα τα αντικείμενα. **Ευάλωτο σε αποτυχία ενός και μόνου κόμβου** (Single Point of Failure).
    *   **Primary Copy (Κύριου Αντιγράφου):** Όλο το κλείδωμα για ένα αντικείμενο γίνεται στον κόμβο που διατηρεί το **κύριο αντίγραφο** (primary copy) του αντικειμένου αυτού. Η ανάγνωση ενός αντικειμένου απαιτεί προσπέλαση στον κόμβο κλειδώματος (primary) *και* στον κόμβο όπου βρίσκεται το αντίγραφο.
    *   **Fully Distributed (Πλήρως Κατανεμημένο):** Το κλείδωμα για ένα αντίγραφο γίνεται στον κόμβο όπου βρίσκεται το αντίγραφο. Η εγγραφή (write) σε ένα αντικείμενο απαιτεί την απόκτηση κλειδαριών **σε όλους τους κόμβους** που έχουν αντίγραφο του αντικειμένου.
*   **Ανίχνευση Κατανεμημένου Νεκρού Κλειδώματος (Distributed Deadlock Detection) (Διαφάνεια 23):** Όταν πολλές κατανεμημένες συναλλαγές μπλοκάρουν η μία την άλλη περιμένοντας κλειδαριές σε διαφορετικούς κόμβους, μπορεί να προκύψει ένα "καθολικό" νεκρό κλείδωμα (global deadlock) ακόμα και αν οι "τοπικοί" πίνακες αναμονής για κλειδαριές (local waits-for graphs) σε κάθε κόμβο *δεν* περιέχουν κύκλους. Λύσεις:
    *   **Centralized:** Ένας κόμβος συλλέγει τους τοπικούς πίνακες αναμονής και ελέγχει για καθολικούς κύκλους. Ακριβό και Single Point of Failure.
    *   **Hierarchical:** Οι κόμβοι οργανώνονται σε ιεραρχία. Οι τοπικοί πίνακες αποστέλλονται στον γονέα στην ιεραρχία για ανίχνευση.
    *   **Timeout (Λήξη Προθεσμίας):** Η συναλλαγή εγκαταλείπεται (abort) αν περιμένει για κλειδαριά "πολύ καιρό". Απλό και συνηθισμένο σε κατανεμημένα συστήματα (και πολλά NoSQL), αλλά μπορεί να οδηγήσει σε λανθασμένες εγκαταλείψεις συναλλαγών (spurious aborts) που δεν ήταν πραγματικά σε νεκρό κλείδωμα.
*   **Κατανεμημένη Επαναφορά (Distributed Recovery) (Διαφάνειες 24-31):** Νέες προκλήσεις: αποτυχίες συνδέσεων δικτύου και απομακρυσμένων κόμβων. Για να επιτευχθεί η Ατομικότητα Κατανεμημένων Συναλλαγών ("όλες οι υπο-συναλλαγές σε διαφορετικούς κόμβους ολοκληρώνονται, ή καμία"), απαιτείται ένα **πρωτόκολλο commit**. Κάθε κόμβος διατηρεί το δικό του log, και οι ενέργειες του πρωτοκόλλου commit επίσης καταγράφονται.
    *   **Two-Phase Commit (2PC - Πρωτόκολλο Commit Δύο Φάσεων) (Διαφάνειες 25-30):** Το κλασικό πρωτόκολλο για διασφάλιση Atomicity σε κατανεμημένες συναλλαγές. Μια συναλλαγή έχει έναν **συντονιστή (coordinator)** στον κόμβο που ξεκίνησε και **υφισταμένους (subordinates)** στους κόμβους όπου εκτελούνται υπο-συναλλαγές.
        *   **Φάση 1: Ψηφοφορία (Voting Phase):**
            *   Ο συντονιστής στέλνει μήνυμα `prepare` σε κάθε υφιστάμενο.
            *   Ο υφιστάμενος λαμβάνει το `prepare`, εξασφαλίζει ότι μπορεί να ολοκληρωθεί η υπο-συναλλαγή του (π.χ. αποκτά όλες τις απαραίτητες κλειδαριές, γράφει τις αλλαγές στο log με WAL), γράφει στο log ένα log record `prepare` ή `abort` (αν δεν μπορεί να προετοιμαστεί). Στέλνει μήνυμα `yes` (μπορώ να ολοκληρώσω) ή `no` (δεν μπορώ να ολοκληρώσω, θα εγκαταλείψω) στον συντονιστή. Κάθε μήνυμα αντικατοπτρίζει μια απόφαση που έχει καταγραφεί στο log.
        *   **Φάση 2: Τερματισμός (Termination Phase):**
            *   Ο συντονιστής περιμένει τις απαντήσεις από όλους τους υφισταμένους.
            *   Εάν **όλοι** ψήφισαν `yes` (ομόφωνα), ο συντονιστής γράφει στο log ένα record `commit` και στέλνει μήνυμα `commit` σε όλους τους υφισταμένους.
            *   Εάν **έστω και ένας** ψήφισε `no` ή δεν απάντησε εγκαίρως, ο συντονιστής γράφει στο log ένα record `abort` και στέλνει μήνυμα `abort` σε όλους τους υφισταμένους.
            *   Οι υφιστάμενοι λαμβάνουν το μήνυμα commit/abort από τον συντονιστή, γράφουν το αντίστοιχο record στο δικό τους log (`commit` ή `abort`), και εφαρμόζουν (redo) ή αναιρούν (undo) τις αλλαγές της υπο-συναλλαγής. Στέλνουν `ack` (acknowledgement) στον συντονιστή.
            *   Ο συντονιστής γράφει στο log record `end` όταν λάβει `ack` από όλους τους υφισταμένους.
    *   **Προκλήσεις και Σημαντικά Σημεία για το 2PC:**
        *   **Blocking (Μπλοκάρισμα) (Διαφάνεια 28-29):** Αν ο συντονιστής αποτύχει *μετά* που όλοι οι υφιστάμενοι ψήφισαν `yes` αλλά *πριν* προλάβει ο συντονιστής να γράψει το record `commit/abort` στο log του, οι υφιστάμενοι που ψήφισαν `yes` **μπλοκάρουν** και δεν μπορούν να ολοκληρώσουν (commit/abort) μέχρι ο συντονιστής να αποκατασταθεί και να στείλει το τελικό μήνυμα. Αυτό παραβιάζει την Availability στην παρουσία διαμερίσεων/αποτυχιών, εξηγώντας εν μέρει γιατί τα συστήματα AP/BASE αποφεύγουν το κλασικό 2PC.
        *   **Αποκατάσταση Μετά από Αποτυχία (Restart After Failure) (Διαφάνεια 27):** Οι κόμβοι που αποκαθίστανται μετά από crash χρησιμοποιούν το τοπικό log για να διαπιστώσουν την κατάσταση των υπο-συναλλαγών τους (ή αν ήταν συντονιστές) και να συνεχίσουν την εκτέλεση του πρωτοκόλλου 2PC (redo/undo, επικοινωνία με άλλους κόμβους). Η λογική επαναφοράς μετά από crash σε ένα κόμβο 2PC είναι αρκετά πολύπλοκη.
    *   **2PC with Presumed Abort (2PC με Υποτιθέμενη Εγκατάλειψη) (Διαφάνεια 31):** Μια βελτιστοποίηση για μείωση των μηνυμάτων και του κόστους logging στην περίπτωση **abort** (που θεωρείται πιο συχνή ή λιγότερο κρίσιμη από το commit). Αν ο συντονιστής αποφασίσει να εγκαταλείψει (abort), δεν περιμένει acks από τους υφισταμένους και μπορεί να "ξεχάσει" τη συναλλαγή νωρίτερα. Αν ένας κόμβος ανακαλύψει μετά από crash ότι δεν υπάρχει record για μια συναλλαγή στο log, "υποθέτει" ότι εγκαταλείφθηκε.
        *   Άλλη βελτιστοποίηση: Υπο-συναλλαγές που είναι *μόνο αναγνώστες* (read-only) δεν χρειάζονται να συμμετέχουν στη Φάση 2. Απαντούν με `reader` αντί για `yes` στο `prepare` και ο συντονιστής τις αγνοεί στη δεύτερη φάση.

**8. Σύνοψη (Διαφάνεια 32)**

*   Τα Παράλληλα ΣΔΒΔ (που λειτουργούν σε έναν κόμβο με πολλαπλούς επεξεργαστές) σχεδιάζονται για κλιμακούμενες επιδόσεις. Οι σχεσιακοί τελεστές είναι κατάλληλοι για παράλληλη εκτέλεση (pipeline and partitioned parallelism).
*   Τα Κατανεμημένα ΣΔΒΔ προσφέρουν τοπική αυτονομία και κατανεμημένη διαχείριση.
*   Η σχεδίαση κατανεμημένων συστημάτων **αναγκάζει να επανεξεταστούν** οι τεχνικές αποθήκευσης, διαχείρισης καταλόγου, ελέγχου ταυτοχρονισμού και επαναφοράς. Οι επιλογές που γίνονται (π.χ. στους αλγόριθμους Join, τα πρωτόκολλα Replication, Commit και Deadlock Detection) επηρεάζουν άμεσα τις εγγυήσεις που μπορεί να παρέχει το σύστημα (π.χ. σε επίπεδο ACID/BASE και CAP Theorem).

**Σημαντικό για το Μάθημα:**

Η κατανόηση των προκλήσεων (επικοινωνία, συνέπεια αντιγράφων, κατανεμημένες συναλλαγές/locks/deadlocks/recovery) και των λύσεων (fragmentation, replication types, distributed joins, 2PC) που παρουσιάζονται σε αυτή την ενότητα, είναι κρίσιμη για να εκτιμήσουμε τους λόγους που τα σύγχρονα συστήματα (όπως πολλά NoSQL και συστήματα Big Data) υιοθετούν συχνά πιο "χαλαρά" μοντέλα συνέπειας (Eventual Consistency), διαφορετικές τεχνικές αποθήκευσης (Schema-less, different data models), και απλούστερους μηχανισμούς διαχείρισης συναλλαγών και επαναφοράς. Αυτοί οι "συμβιβασμοί" γίνονται για να επιτευχθεί το απαραίτητο επίπεδο οριζόντιας κλιμακούμενοτητας (horizontal scalability) και υψηλής διαθεσιμότητας (high availability) σε περιβάλλοντα Cloud και Big Data.
