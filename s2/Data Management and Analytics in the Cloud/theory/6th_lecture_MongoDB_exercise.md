# 🧪 Άσκηση MongoDB

### 🟩 Επίπεδο 1 – Βασικά Ερωτήματα (Queries)

1. **Εισαγωγή εγγράφου**:
   - Καταχώρησε το εξής έγγραφο στη συλλογή `students`:
   ```json
   {
     "name": "Γιάννης Παπαδόπουλος",
     "age": 23,
     "department": "Πληροφορική",
     "grades": [7.5, 8.0, 9.2]
   }
   ```

```javascript
db.students.insertOne(
  {
    "name": "Γιάννης Παπαδόπουλος",
    "age": 23,
    "department": "Πληροφορική",
    "grades": [7.5, 8.0, 9.2]
  }
);
```

2. **Αναζήτηση**:
   - Βρες όλους τους φοιτητές που σπουδάζουν "Πληροφορική".

```javascript
db.students.find({ "department": "Πληροφορική" });
```

3. **Προβολή συγκεκριμένων πεδίων**:
   - Εμφάνισε μόνο τα ονόματα και τις ηλικίες των φοιτητών, χωρίς το `_id`.

```javascript
db.students.find({}, { "name": 1, "age": 1, "_id": 0 });
```

4. **Ταξινόμηση**:
   - Ταξινόμησε τους φοιτητές κατά ηλικία (φθίνουσα σειρά).

```javascript
db.students.find().sort({ "age": -1 }); // -1 για φθίνουσα, 1 για αύξουσα
```

5. **Φιλτράρισμα**:
   - Βρες όσους έχουν βαθμό μεγαλύτερο του 8 σε τουλάχιστον ένα μάθημα.

```javascript
db.students.find({ "grades": { $gt: 8 } });
```

---

### 🟨 Επίπεδο 2 – Σύνθετα Ερωτήματα και Ενημερώσεις

6. **Ενημέρωση**:
   - Πρόσθεσε νέο μάθημα `"Databases"` στο πεδίο `courses` για τη φοιτήτρια με όνομα "Μαρία Νικολάου".

```javascript
db.students.updateOne(
  { "name": "Μαρία Νικολάου" },
  { $addToSet: { "courses": "Databases" } }
);
```

7. **Αύξηση τιμής**:
   - Αυξήστε την ηλικία κατά 1 για όλους τους φοιτητές άνω των 25.

```javascript
db.students.updateMany(
  { "age": { $gt: 25 } },
  { $inc: { "age": 1 } }
);
```

8. **Διαγραφή**:
   - Διέγραψε όλους τους φοιτητές που έχουν μέσο όρο βαθμολογίας < 5.

*Σημείωση:* Η MongoDB δεν υποστηρίζει απευθείας υπολογισμό μέσου όρου μέσα σε ένα φίλτρο `deleteMany`. Αυτό απαιτεί συνδυασμό aggregation για την εύρεση των σχετικών `_id`'s και στη συνέχεια `deleteMany`.

**Βήμα 1: Βρες τους `_id` των φοιτητών με μέσο όρο βαθμολογίας < 5.**
```javascript
let studentIdsToDelete = db.students.aggregate([
  {
    $addFields: {
      averageGrade: { $avg: "$grades" }
    }
  },
  {
    $match: {
      averageGrade: { $lt: 5 }
    }
  },
  {
    $project: { _id: 1 } // Μόνο το _id μας ενδιαφέρει
  }
]).map(doc => doc._id); // Εξάγει έναν πίνακα με τα _id
printjson(studentIdsToDelete); // Για να δεις τα IDs
```

**Βήμα 2: Διέγραψε τους φοιτητές χρησιμοποιώντας τα `_id` που βρέθηκαν.**
```javascript
if (studentIdsToDelete.length > 0) {
  db.students.deleteMany({ "_id": { $in: studentIdsToDelete } });
  print("Διαγράφηκαν " + studentIdsToDelete.length + " φοιτητές.");
} else {
  print("Δεν βρέθηκαν φοιτητές με μέσο όρο βαθμολογίας < 5 για διαγραφή.");
}
```

9. **Σύνθετη Αναζήτηση**:
   - Βρες όσους είναι στο Τμήμα "Ηλεκτρολόγων Μηχανικών" ή είναι κάτω των 21 ετών.

```javascript
db.students.find(
  {
    $or: [
      { "department": "Ηλεκτρολόγων Μηχανικών" },
      { "age": { $lt: 21 } }
    ]
  }
);
```

10. **Εγγραφή μόνο αν δεν υπάρχει**:
   - Εισήγαγε έναν φοιτητή μόνο αν δεν υπάρχει άλλος με το ίδιο `AM` (Αριθμός Μητρώου).

*Προϋπόθεση:* Για να λειτουργήσει αξιόπιστα αυτό, θα πρέπει να υπάρχει ένα **μοναδικό ευρετήριο (unique index)** στο πεδίο `AM`.
```javascript
// Βήμα 1: Δημιουργία μοναδικού ευρετηρίου στο πεδίο AM (μόνο μια φορά)
db.students.createIndex({ "AM": 1 }, { unique: true });

// Βήμα 2: Εισαγωγή/Ενημέρωση με upsert και $setOnInsert
// Αυτό θα εισάγει το έγγραφο μόνο αν δεν υπάρχει φοιτητής με AM: "2023001"
// Αν υπάρχει, δεν θα γίνει τίποτα (δεν θα ενημερώσει ούτε θα εισάγει).
db.students.updateOne(
  { "AM": "2023001" }, // Κριτήριο αναζήτησης
  {
    $setOnInsert: { // Αυτά τα πεδία ορίζονται μόνο αν γίνει Εισαγωγή (Insert)
      "name": "Νέος Φοιτητής Πληροφορικής",
      "age": 20,
      "department": "Πληροφορική",
      "grades": [7.0, 7.0, 7.0]
    }
  },
  { upsert: true } // Αν δεν βρεθεί έγγραφο, εισήγαγε το
);
```
**Δοκιμή:**
*   Την πρώτη φορά που θα το τρέξετε, θα εισαχθεί.
*   Τη δεύτερη φορά, επειδή υπάρχει ήδη φοιτητής με AM "2023001" (Μαρία Νικολάου), το `updateOne` θα βρει το έγγραφο, αλλά το `$setOnInsert` δεν θα κάνει τίποτα, καθώς δεν πρόκειται για νέα εισαγωγή. Η Μαρία έχει ήδη AM "2022001" και ο Νέος Φοιτητής AM "2023001".
*   Αν επιχειρήσετε να εισάγετε άλλον φοιτητή με AM "2023001" *χωρίς* το `$setOnInsert` και το unique index, θα πάρετε σφάλμα διπλότυπου κλειδιού.


---

### 🟥 Επίπεδο 3 – Aggregation και Μοντελοποίηση

11. **Μέσος όρος βαθμών ανά φοιτητή**:
   - Χρησιμοποίησε aggregation για να υπολογίσεις τον μέσο όρο βαθμών για κάθε φοιτητή.

```javascript
db.students.aggregate([
  {
    $addFields: { // Προσθέτει ένα νέο πεδίο "averageGrade" σε κάθε έγγραφο
      averageGrade: { $avg: "$grades" }
    }
  },
  {
    $project: { // Επιλέγει ποια πεδία θα εμφανίσει
      name: 1,
      department: 1,
      averageGrade: 1,
      _id: 0 // Αφαιρεί το _id από την έξοδο
    }
  }
]);
```

12. **Πλήθος φοιτητών ανά τμήμα**:
   - Πόσοι φοιτητές υπάρχουν ανά τμήμα;

```javascript
db.students.aggregate([
  {
    $group: { // Ομαδοποιεί τα έγγραφα
      _id: "$department", // Ομαδοποίηση βάσει του πεδίου 'department'
      count: { $sum: 1 } // Μετράει κάθε έγγραφο στην ομάδα
    }
  },
  {
    $sort: {
      count: -1 // Προαιρετική ταξινόμηση κατά αριθμό φοιτητών (φθίνουσα)
    }
  }
]);
```

13. **Top 3 φοιτητές με βάση τον μέσο όρο**:
   - Επιστροφή των 3 καλύτερων φοιτητών ως προς τον μέσο όρο βαθμών.

```javascript
db.students.aggregate([
  {
    $addFields: {
      averageGrade: { $avg: "$grades" } // Υπολογισμός μέσου όρου
    }
  },
  {
    $sort: {
      averageGrade: -1 // Ταξινόμηση φθίνουσα βάσει μέσου όρου
    }
  },
  {
    $limit: 3 // Περιορισμός στα 3 κορυφαία αποτελέσματα
  },
  {
    $project: {
      name: 1,
      department: 1,
      averageGrade: 1,
      _id: 0
    }
  }
]);
```

14. **Ενσωμάτωση Δεδομένων**:
   - Μοντελοποίησε έναν φοιτητή που έχει:
     - προσωπικά στοιχεία
     - λίστα μαθημάτων (με κωδικό & τίτλο)
     - λίστα βαθμών (με κωδικό μαθήματος & βαθμό)

```javascript
// Ένα παράδειγμα εγγράφου φοιτητή με ενσωματωμένα δεδομένα:
{
  "name": "Άννα Παπαδάκη",
  "age": 22,
  "department": "Ηλεκτρολόγων Μηχανικών",
  "AM": "2023007",
  "personalInfo": { // Ενσωματωμένο υπο-έγγραφο
    "address": {
      "street": "Ηρώων Πολυτεχνείου 10",
      "city": "Αθήνα",
      "zip": "15773"
    },
    "phone": "6981234567",
    "email": "anna.p@example.com"
  },
  "coursesEnrolled": [ // Ενσωματωμένος πίνακας υπο-εγγράφων για μαθήματα
    { "code": "EE101", "title": "Εισαγωγή στα Ηλεκτρονικά", "credits": 6 },
    { "code": "MA201", "title": "Ανάλυση ΙΙ", "credits": 7 },
    { "code": "CS305", "title": "Δομές Δεδομένων", "credits": 5 }
  ],
  "gradesDetails": [ // Ενσωματωμένος πίνακας υπο-εγγράφων για βαθμούς
    { "courseCode": "EE101", "grade": 7.5, "semester": "Fall 2023" },
    { "courseCode": "MA201", "grade": 6.8, "semester": "Fall 2023" },
    { "courseCode": "CS305", "grade": 8.0, "semester": "Spring 2024" }
  ]
}
```
**Πότε είναι κατάλληλο:** Όταν τα ενσωματωμένα δεδομένα είναι στενά συνδεδεμένα με το "γονικό" έγγραφο, έχουν μικρή πιθανότητα να αλλάξουν ανεξάρτητα και η πρόσβαση σε αυτά γίνεται κυρίως μέσω του γονικού εγγράφου. Αποφεύγει τα "joins" (όπως το `$lookup`), οδηγώντας σε ταχύτερες αναγνώσεις.

15. **Διαχωρισμός και Αναφορά (Linking)**:
   - Δημιούργησε δύο collections: `students` και `courses`.
   - Το έγγραφο του φοιτητή περιέχει μόνο τους `course_ids`.
   - Στη συνέχεια, με χρήση aggregation, παρουσίασε τον φοιτητή μαζί με τις πλήρεις πληροφορίες των μαθημάτων του.

**Βήμα 1: Δημιουργία `courses` collection και εισαγωγή δεδομένων.**
```javascript
db.courses.insertMany([
  { _id: ObjectId("65c6c0b396b26d83a1a0f8b1"), "code": "CS101", "title": "Εισαγωγή στην Πληροφορική", "credits": 6 },
  { _id: ObjectId("65c6c0b396b26d83a1a0f8b2"), "code": "MA201", "title": "Γραμμική Άλγεβρα", "credits": 7 },
  { _id: ObjectId("65c6c0b396b26d83a1a0f8b3"), "code": "EE301", "title": "Ψηφιακά Συστήματα", "credits": 6 }
]);
```
*Σημείωση:* Τα `ObjectId`'s είναι παραδείγματα. Θα δημιουργηθούν αυτόματα αν δεν τα ορίσετε. Μπορείτε να τα βρείτε στην έξοδο των `insertMany` ή `insertOne`.

**Βήμα 2: Ενημέρωση ή εισαγωγή εγγράφων `students` με αναφορές (`ObjectId`) στα μαθήματα.**
*Προσοχή:* Θα πρέπει να υπάρχουν τα `ObjectId`'s των μαθημάτων που εισάγατε παραπάνω.
```javascript
db.students.updateOne(
  { "name": "Γιάννης Παπαδόπουλος" },
  { $set: {
      "enrolledCourseIds": [
        ObjectId("65c6c0b396b26d83a1a0f8b1"), // CS101
        ObjectId("65c6c0b396b26d83a1a0f8b2")  // MA201
      ]
    }
  }
);

db.students.updateOne(
  { "name": "Μαρία Νικολάου" },
  { $set: {
      "enrolledCourseIds": [
        ObjectId("65c6c0b396b26d83a1a0f8b1"), // CS101
        ObjectId("65c6c0b396b26d83a1a0f8b3")  // EE301
      ]
    }
  }
);
```

**Βήμα 3: Χρήση του `$lookup` (aggregation join) για να παρουσιάσεις τον φοιτητή μαζί με τις πλήρεις πληροφορίες των μαθημάτων του.**
```javascript
db.students.aggregate([
  {
    $lookup: {
      from: "courses",             // Η συλλογή με την οποία θέλουμε να κάνουμε join
      localField: "enrolledCourseIds", // Το πεδίο στο τρέχον έγγραφο (students) που περιέχει τα IDs
      foreignField: "_id",         // Το πεδίο στο έγγραφο της 'courses' συλλογής που αντιστοιχεί στα IDs
      as: "enrolledCourseDetails"  // Το όνομα του νέου πίνακα που θα περιέχει τα αντιστοιχισμένα έγγραφα μαθημάτων
    }
  },
  {
    $project: { // Προβολή των επιθυμητών πεδίων
      name: 1,
      department: 1,
      enrolledCourseDetails: { code: 1, title: 1, credits: 1 }, // Επιλέγουμε συγκεκριμένα πεδία από τα ενσωματωμένα μαθήματα
      _id: 0
    }
  }
]);
```
**Πότε είναι κατάλληλο:** Όταν τα δεδομένα έχουν σχέση ένα-προς-πολλά ή πολλά-προς-πολλά, όταν τα ενσωματωμένα δεδομένα αλλάζουν συχνά και ανεξάρτητα (π.χ., πληροφορίες μαθήματος που μπορεί να ενημερωθούν μία φορά και να επηρεάσουν πολλούς φοιτητές), ή όταν το ενσωματωμένο σύνολο δεδομένων μπορεί να γίνει πολύ μεγάλο.

---

## 💬 Extra (Σκέψου και απάντησε)

### 1. Πότε θα χρησιμοποιήσεις ενσωμάτωση (embedding) και πότε σύνδεση (linking) σε μία εφαρμογή τύπου e-commerce;

**Ενσωμάτωση (Embedding):**
Θα χρησιμοποιούσα ενσωμάτωση όταν:
1.  **Στενή Σχέση και Συχνή Πρόσβαση Μαζί:** Τα δεδομένα είναι πάντα απαραίτητα μαζί και δεν υπάρχει λόγος να τα διαχωρίσουμε.
    *   **Παράδειγμα:** Τα **στοιχεία γραμμής παραγγελίας (line items)** μέσα σε ένα έγγραφο `Order`. Μια παραγγελία έχει πάντα συγκεκριμένα προϊόντα με συγκεκριμένες ποσότητες και τιμές (που ίσχυαν τη στιγμή της παραγγελίας). Αυτές οι πληροφορίες δεν αλλάζουν μετά την παραγγελία και δεν είναι λογικό να τις αναζητήσεις ποτέ ανεξάρτητα από την παραγγελία.
    ```json
    // Order Document
    {
      "orderId": "ORD123",
      "customerId": "CUST001",
      "orderDate": ISODate("2023-10-26T10:00:00Z"),
      "items": [ // Embedded array of documents
        { "productId": "PROD001", "name": "Laptop XYZ", "quantity": 1, "price": 1200.00 },
        { "productId": "PROD002", "name": "Mouse ABC", "quantity": 2, "price": 25.00 }
      ],
      "totalAmount": 1250.00
    }
    ```
2.  **Περιορισμένο Μέγεθος:** Το ενσωματωμένο σύνολο δεδομένων είναι σχετικά μικρό και δεν αναμένεται να αυξηθεί πολύ.
    *   **Παράδειγμα:** Οι **διευθύνσεις αποστολής/χρέωσης** ενός χρήστη. Ένας χρήστης συνήθως δεν έχει δεκάδες διευθύνσεις.
    ```json
    // User Document
    {
      "userId": "USER001",
      "name": "John Doe",
      "addresses": [ // Embedded array of documents
        { "type": "shipping", "street": "123 Main St", "city": "Anytown" },
        { "type": "billing", "street": "456 Oak Ave", "city": "Anytown" }
      ]
    }
    ```

**Σύνδεση (Linking/Referencing):**
Θα χρησιμοποιούσα σύνδεση όταν:
1.  **Ανεξάρτητη Ζωή και Συχνές Αλλαγές:** Τα δεδομένα έχουν ανεξάρτητη ζωή, αλλάζουν συχνά και ανεξάρτητα από το "γονικό" έγγραφο, και η ενημέρωση τους πρέπει να γίνεται μόνο σε ένα σημείο.
    *   **Παράδειγμα:** Τα **στοιχεία προϊόντος** (π.χ., τιμή, περιγραφή, διαθεσιμότητα). Αν η τιμή ενός προϊόντος αλλάξει, δεν θέλουμε να ενημερώσουμε χιλιάδες παραγγελίες που το περιέχουν. Μόνο το βασικό έγγραφο του προϊόντος χρειάζεται ενημέρωση.
    ```json
    // Product Document
    { "productId": "PROD001", "name": "Laptop XYZ", "description": "Powerful laptop...", "currentPrice": 1250.00 }

    // Order Item (linking to Product)
    {
      "orderId": "ORD123",
      "items": [
        { "productId": "PROD001", "quantity": 1, "priceAtOrder": 1200.00 } // priceAtOrder is embedded for historical data
      ]
    }
    ```
2.  **Μεγάλο Μέγεθος ή Απεριόριστη Αύξηση:** Το ενσωματωμένο σύνολο δεδομένων μπορεί να γίνει πολύ μεγάλο.
    *   **Παράδειγμα:** Οι **αξιολογήσεις (reviews)** ενός προϊόντος. Ένα δημοφιλές προϊόν μπορεί να έχει χιλιάδες αξιολογήσεις. Δεν θα ενσωματώναμε όλες τις αξιολογήσεις μέσα στο έγγραφο του προϊόντος.
    ```json
    // Product Document
    { "productId": "PROD001", "name": "Laptop XYZ", "averageRating": 4.5 }

    // Review Document (in a separate collection)
    { "reviewId": "REV001", "productId": "PROD001", "userId": "USER001", "rating": 5, "comment": "Great product!" }
    ```
3.  **Πολύπλοκες Σχέσεις (π.χ., πολλά-προς-πολλά):** Όταν πολλά έγγραφα αναφέρονται σε πολλά άλλα έγγραφα.
    *   **Παράδειγμα:** **Προϊόντα και Κατηγορίες**. Ένα προϊόν μπορεί να ανήκει σε πολλές κατηγορίες, και μια κατηγορία περιέχει πολλά προϊόντα.

### 2. Τι προβλήματα μπορεί να δημιουργήσει η απουσία σχήματος (schema-less) σε μεγάλες ομάδες ανάπτυξης;

Ενώ η ευελιξία του schema-less μοντέλου της MongoDB είναι ένα πλεονέκτημα, σε μεγάλες ομάδες ανάπτυξης και σε σύνθετα έργα μπορεί να οδηγήσει σε σημαντικά προβλήματα:

1.  **Ασυνέπεια Δεδομένων (Data Inconsistency):**
    *   Διαφορετικοί προγραμματιστές μπορεί να αποθηκεύουν το ίδιο λογικό πεδίο με διαφορετικά ονόματα (π.χ., `userAge` vs `age`), διαφορετικούς τύπους δεδομένων (π.χ., `age` ως string vs number), ή διαφορετικές δομές (π.χ., `address` ως string vs embedded document).
    *   Αυτό καθιστά την αναζήτηση, την επεξεργασία και την ανάλυση δεδομένων εξαιρετικά δύσκολη και επιρρεπή σε λάθη.

2.  **Έλλειψη Εγκυρότητας Δεδομένων (Lack of Data Validation):**
    *   Χωρίς ένα καθορισμένο σχήμα, δεν υπάρχει ενσωματωμένος μηχανισμός για την επιβολή της εγκυρότητας των δεδομένων κατά την εισαγωγή. Αυτό σημαίνει ότι "βρώμικα" δεδομένα μπορούν εύκολα να εισαχθούν στη βάση.
    *   Οι έλεγχοι εγκυρότητας μεταφέρονται στην εφαρμογή, αυξάνοντας την πολυπλοκότητα και τον κίνδυνο λαθών.

3.  **Προβλήματα Κατά την Ανάπτυξη (Development Challenges):**
    *   **Δυσκολία στην Κατανόηση:** Νέοι προγραμματιστές ή μέλη της ομάδας δυσκολεύονται να κατανοήσουν τη δομή των δεδομένων χωρίς ένα σαφές σχήμα.
    *   **"Query Hell":** Τα ερωτήματα γίνονται πιο σύνθετα, καθώς πρέπει να λαμβάνουν υπόψη όλες τις πιθανές παραλλαγές της δομής του εγγράφου (π.χ., έλεγχος αν ένα πεδίο υπάρχει και τι τύπο έχει).
    *   **Refactoring Code:** Οι αλλαγές στη δομή των δεδομένων απαιτούν συντονισμένες αλλαγές σε όλη την εφαρμογή, οι οποίες μπορεί να είναι δύσκολο να εντοπιστούν και να εφαρμοστούν χωρίς σχήμα.

4.  **Επιδόσεις (Performance Issues):**
    *   Ασυνεπείς τύποι δεδομένων μπορούν να επηρεάσουν την απόδοση των ευρετηρίων και των ερωτημάτων.
    *   Χωρίς σαφές σχήμα, είναι πιο δύσκολο να σχεδιαστούν αποτελεσματικά ευρετήρια.

5.  **Εργαλεία και ORMs:**
    *   Πολλά εργαλεία ανάπτυξης, ORM/ODM (όπως το Mongoose για Node.js), και εργαλεία αναφοράς/ανάλυσης βασίζονται σε ένα σχήμα για τη δημιουργία μοντέλων και την απλοποίηση της αλληλεπίδρασης με τη βάση δεδομένων. Η απουσία σχήματος μειώνει την αποτελεσματικότητά τους ή απαιτεί χειροκίνητη διαχείριση.

**Λύσεις/Μετριασμοί:**
*   **MongoDB Schema Validation (από v3.6+):** Η MongoDB επιτρέπει την επιβολή ενός "soft schema" χρησιμοποιώντας JSON Schema. Αυτό επιτρέπει την ευελιξία του NoSQL, ενώ προσθέτει δομική ακεραιότητα.
*   **Team Conventions:** Αυστηρές συμφωνίες στην ομάδα για την ονομασία και τη δομή των πεδίων.
*   **Code-level Validation:** Χρήση ORM/ODM βιβλιοθηκών (π.χ., Mongoose) που επιτρέπουν τον ορισμό σχήματος στο επίπεδο της εφαρμογής.
*   **Thorough Testing:** Εκτεταμένες δοκιμές για την επιβεβαίωση της ακεραιότητας των δεδομένων.

### 3. Πώς θα διασφαλίσεις συνέπεια όταν έχεις απο-κανονικοποιήσει δεδομένα;

Η απο-κανονικοποίηση (denormalization) δεδομένων στο MongoDB, συχνά μέσω ενσωμάτωσης (embedding) ή διπλασιασμού (duplication), γίνεται για βελτίωση της απόδοσης ανάγνωσης (μειώνοντας την ανάγκη για `$lookup`). Το τίμημα είναι η πρόκληση διατήρησης της συνέπειας, καθώς η ενημέρωση των δεδομένων σε ένα σημείο απαιτεί ενημέρωση και στα διπλά αντίγραφα.

Για να διασφαλίσεις τη συνέπεια:

1.  **Transactions (Συναλλαγές) - Από MongoDB 4.0+:**
    *   Αυτός είναι ο πιο ισχυρός τρόπος για να διασφαλίσεις Atomicity, Consistency, Isolation, Durability (ACID) σε πολλαπλά έγγραφα και συλλογές. Εάν αλλάζεις ένα πεδίο στο "source" έγγραφο και ταυτόχρονα το αντίστοιχο απο-κανονικοποιημένο πεδίο σε άλλο έγγραφο, μπορείς να το κάνεις μέσα σε μία συναλλαγή.
    *   **Παράδειγμα:** Αν αλλάξει το όνομα ενός προϊόντος (στο έγγραφο `products`), και αυτό το όνομα είναι ενσωματωμένο σε ένα αναλυτικό πίνακα `salesReports`, μπορείς να ενημερώσεις και τα δύο εντός μιας συναλλαγής, εξασφαλίζοντας ότι είτε και τα δύο ενημερώνονται επιτυχώς είτε κανένα.

2.  **Application-Level Consistency (Συνέπεια στο Επίπεδο της Εφαρμογής):**
    *   Αυτή είναι η πιο συνηθισμένη προσέγγιση για απλούστερες περιπτώσεις ή όταν οι συναλλαγές δεν είναι απαραίτητες ή δυνατές (π.χ., σε πολύ παλιές εκδόσεις MongoDB). Η εφαρμογή είναι υπεύθυνη να εκτελεί όλες τις απαραίτητες ενημερώσεις.
    *   **Παράδειγμα:** Όταν αλλάζει η διεύθυνση ενός χρήστη:
        1.  Ενημέρωσε τη διεύθυνση στο κύριο έγγραφο `users`.
        2.  Στη συνέχεια, ενημέρωσε τη διεύθυνση σε όλες τις "ενεργές" παραγγελίες `orders` όπου αυτή η διεύθυνση έχει απο-κανονικοποιηθεί.
    *   **Μειονέκτημα:** Επιρρεπές σε σφάλματα αν η εφαρμογή crash-άρει μεταξύ των ενημερώσεων, οδηγώντας σε προσωρινή ασυνέπεια.

3.  **Two-Phase Commits (Δέσμευση Δύο Φάσεων):**
    *   Μια πιο σύνθετη προσέγγιση για την επίτευξη ατομικότητας σε πολλαπλά έγγραφα, ειδικά πριν τις ενσωματωμένες συναλλαγές της MongoDB. Περιλαμβάνει τη δημιουργία ενός "pending" status και μετά την οριστική δέσμευση. Γενικά, δεν είναι πλέον η συνιστώμενη λύση με τις σύγχρονες εκδόσεις.

4.  **Message Queues / Event-Driven Architecture (Μηνυματοκεντρική Αρχιτεκτονική):**
    *   Για μεγάλες, κατανεμημένες εφαρμογές, όταν ένα δεδομένο που έχει απο-κανονικοποιηθεί αλλάζει, το σύστημα εκδίδει ένα "γεγονός" (event) σε μια ουρά μηνυμάτων (π.χ., Kafka, RabbitMQ). Άλλες υπηρεσίες που "ακούνε" για αυτό το γεγονός ενημερώνουν τα δικά τους απο-κανονικοποιημένα δεδομένα.
    *   **Πλεονέκτημα:** Παρέχει τελική συνέπεια (eventual consistency) και είναι πιο ανθεκτικό σε αποτυχίες.
    *   **Μειονέκτημα:** Πιο σύνθετη αρχιτεκτονική, όχι άμεση συνέπεια.

5.  **Scheduled Jobs / Batch Updates (Προγραμματισμένες Εργασίες / Μαζικές Ενημερώσεις):**
    *   Εάν η άμεση συνέπεια δεν είναι κρίσιμη, μπορείς να τρέχεις περιοδικές (π.χ., νυχτερινές) εργασίες που ελέγχουν για ασυνέπειες και τις διορθώνουν.
    *   **Παράδειγμα:** Ένα job που ελέγχει όλες τις ενεργές παραγγελίες και συγκρίνει τις απο-κανονικοποιημένες τιμές προϊόντων με τις τρέχουσες τιμές στο `products` collection, διορθώνοντας τυχόν αποκλίσεις.
    *   **Μειονέκτημα:** Τα δεδομένα μπορεί να είναι ασυνεπή για ένα χρονικό διάστημα.

**Συνοπτικά:** Η καλύτερη προσέγγιση εξαρτάται από τις απαιτήσεις συνέπειας και την πολυπλοκότητα της εφαρμογής. Για τις περισσότερες σύγχρονες εφαρμογές MongoDB, οι **συναλλαγές (transactions)** είναι η προτιμώμενη μέθοδος για την επίτευξη ισχυρής συνέπειας σε απο-κανονικοποιημένα δεδομένα. Όταν οι συναλλαγές δεν καλύπτουν όλες τις ανάγκες, οι μηνυματοκεντρικές αρχιτεκτονικές προσφέρουν μια ισχυρή λύση για τελική συνέπεια.
