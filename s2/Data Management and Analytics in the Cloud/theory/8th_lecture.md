# **Βάσεις Δεδομένων Γράφων (Graph Databases) - Με έμφαση στο Neo4j**

## **1. Δεδομένα σε Μορφή Γράφου (Graph Data) (Slides 2-9)**

*   Πολλά είδη δεδομένων μπορούν να αναπαρασταθούν φυσικά ως **γράφοι (graphs)**:
    *   **Κοινωνικά Δίκτυα (Social Networks):** Άνθρωποι συνδεδεμένοι με σχέσεις (φίλοι, followers). Π.χ. το κοινωνικό γράφο του Facebook (Slide 2).
    *   **Δίκτυα Media:** Συνδέσεις μεταξύ ειδησεογραφικών πηγών ή blogs (Slide 3).
    *   **Δίκτυα Πληροφορίας (Information Nets):** Βιβλιογραφικές αναφορές (citations), γνώση domain, ontologies (Slide 4).
    *   **Δίκτυα Επικοινωνίας (Communication Nets):** Internet, δίκτυα τηλεπικοινωνιών (Slide 5).
    *   **Τεχνολογικά Δίκτυα:** Δίκτυα μεταφορών, ενεργειακά δίκτυα. Π.χ. το πρόβλημα των Επτά Γεφυρών του Königsberg (Euler, 1735) είναι ένα κλασικό παράδειγμα θεωρίας γράφων (Slide 6).
    *   **Web ως Γράφος:** Οι ιστοσελίδες ως **κόμβοι (nodes)** και οι υπερσυνδέσεις (hyperlinks) ως **ακμές/σχέσεις (edges/relationships)**. Ένας κατευθυνόμενος (directed) γράφος (Slide 7, 8). Παράδειγμα γράφου διαφόρων οντοτήτων συνδεδεμένων με σχέσεις (blog post, classes, university, lyrics) (Slide 9).

## **2. Το Μοντέλο Δεδομένων: Property Graph (Slides 10-11, 29-30)**

*   Οι Βάσεις Δεδομένων Γράφων βασίζονται σε ένα **explicit graph structure (ρητή δομή γράφου)**.
*   Τα βασικά δομικά στοιχεία ενός γράφου (όπως στο Property Graph Model που χρησιμοποιούν πολλές Graph Databases):
    *   **Vertices or nodes (Κορυφές ή Κόμβοι):** Αναπαριστούν **διακριτές οντότητες (distinct objects)** (π.χ. ένα άτομο, ένα μέρος, ένα προϊόν). Έχουν ένα μοναδικό αναγνωριστικό.
    *   **Edges or relationships or arcs (Ακμές ή Σχέσεις):** **Συνδέουν (connect)** τους κόμβους. Οι σχέσεις συχνά είναι **κατευθυνόμενες (directed)** και έχουν **όνομα (named)** (π.χ. "ΕΙΝΑΙ_ΦΙΛΟΣ_ΜΕ", "ΑΓΟΡΑΣΕ", "ΕΡΓΑΖΕΤΑΙ_ΣΕ"). Αυτό παρέχει σημασιολογικά σχετικές συνδέσεις.
    *   **Properties (Ιδιότητες):** Τόσο οι κόμβοι όσο και οι σχέσεις **μπορούν να έχουν ιδιότητες (properties)**, οι οποίες είναι ζεύγη κλειδιού-τιμής (key-value pairs) που περιγράφουν την οντότητα ή τη σχέση (π.χ. ένας κόμβος "Άτομο" μπορεί να έχει ιδιότητες "όνομα", "ηλικία", ενώ μια σχέση "ΕΡΓΑΖΕΤΑΙ_ΣΕ" μπορεί να έχει ιδιότητα "θέση", "ημερομηνία_πρόσληψης"). (Slide 10, 29).
*   **Property Graph Model:** Αναπαράσταση ενός δικτύου από την ταινία "Matrix" (Morpheus, Neo, Trinity, Cypher, Agent Smith, The Architect) με κόμβους (άτομα, γλώσσα), ονομασμένες και κατευθυνόμενες σχέσεις (KNOWS, LOVES, CODED_BY), και ιδιότητες στους κόμβους και τις σχέσεις (ηλικία, επάγγελμα, rank, version, disclosure, duration). (Slide 11, 30).

## **3. Γιατί να Χρησιμοποιήσουμε Βάσεις Δεδομένων Γράφων; (Slide 16, 19)**

*   **Όταν οι Σχέσεις είναι Σημαντικές!** Οι Graph Databases είναι ιδανικές όταν η κύρια προσπέλαση και ανάλυση των δεδομένων αφορά την **εξερεύνηση (exploration)** και την **πλοήγηση (navigation)** του δικτύου σχέσεων.
*   **RDBMS και Σχέσεις:** Σε RDBMS, οι σχέσεις μεταξύ οντοτήτων αναπαρίστανται ως **Joins** μεταξύ πινάκων (συχνά με Foreign Keys) ή ως **join tables**. Η ανασύσταση σύνθετων "μονοπατιών" ή "αλυσίδων" σχέσεων (graph traversal) σε RDBMS απαιτεί πολλαπλά και συχνά **σύνθετα joins**. Καθώς το βάθος (depth) της εξερεύνησης αυξάνει (π.χ. φίλοι-των-φίλων, φίλοι-των-φίλων-των-φίλων), το ερώτημα SQL γίνεται εξαιρετικά πολύπλοκο και η απόδοση **υποβαθμίζεται (degrades)**. (Slide 16, 21). Το "degrees of separation problem" (πόσο "μακριά" είσαι από κάποιον σε ένα δίκτυο) είναι δύσκολο σε SQL.
*   **Graph Databases και Σχέσεις:** Οι Graph Databases είναι **βελτιστοποιημένες** για την αποδοτική διαχείριση και διάσχιση (traversal) των σχέσεων. Κάθε κόμβος έχει απευθείας δείκτες (pointers) στους γειτονικούς του κόμβους και στις σχέσεις που τους συνδέουν (**index-free adjacency** - δεν χρειάζεται να κάνεις index lookup για να βρεις τους γείτονες). (Slide 20).
*   **Data-centric view:** Το μοντέλο επικεντρώνεται στα δεδομένα και τις σχέσεις τους. (Slide 19).

## **4. Βασικές Λειτουργίες και Ερωτήματα (Slides 12, 19, 26)**

*   **Basic Primitives:**
    *   Ορισμός/διαγραφή κόμβων ή σχέσεων.
    *   Εύρεση γειτονικών κόμβων (`Find adjacent nodes`).
*   **Graph Traversal (Διάσχιση Γράφου):** Η βασική λειτουργία. Ένα traversal πλοηγείται στον γράφο, ακολουθώντας σχέσεις και εντοπίζοντας μονοπάτια και κόμβους που πληρούν συγκεκριμένα κριτήρια. Συνδυάζει τα βασικά primitives (Slide 12, 20).
*   **Υποστήριξη CRUD:** Όπως και άλλες βάσεις, υποστηρίζουν CREATE, READ, UPDATE, DELETE σε στοιχεία του γράφου (κόμβους, σχέσεις, ιδιότητες). (Slide 19).
*   **Τύποι Ερωτημάτων (Slide 26):** Πιο εξειδικευμένοι τύποι ερωτημάτων πέρα από την απλή διάσχιση:
    *   **Sub-graph queries:** Αναζήτηση ενός γράφου που περιέχει ένα συγκεκριμένο μοτίβο γράφου (συνήθως involves sub-graph isomorphism problem, που είναι computationally hard).
    *   **Super-graph queries:** Αναζήτηση ενός γράφου εντός της βάσης που περιέχει τον γράφο που ορίζεται στο ερώτημα.
    *   **Similarity queries:** Εύρεση γράφων που είναι παρόμοιοι με τον γράφο του ερωτήματος.

## **5. Σύγκριση Relational vs Graph Database (Slide 21)**

*   **RDBMS:**
    *   Για να μοντελοποιήσεις μια σχέση (π.χ. "είναι μάνατζερ του"), συχνά χρειάζεσαι ένα foreign key ή ένα join table. Για διαφορετικούς τύπους σχέσεων, μπορεί να χρειάζεσαι διαφορετικές στήλες ή πίνακες -> Απαιτείται αλλαγή σχήματος (schema changes) για προσθήκη νέων τύπων σχέσεων.
    *   Το μοντέλο δεδομένων βασίζεται στη δομή ("ποια δεδομένα έχω"), και η προσπέλαση ακολουθεί τις απαιτούμενες συνδέσεις (joins) -> απαιτούνται πολλά joins για διάσχιση.
    *   Οι σχέσεις (ως joins) **δεν είναι αποθηκευμένες** αλλά **υπολογίζονται** κατά την εκτέλεση του ερωτήματος.
*   **Graph DB:**
    *   Μπορείς να δημιουργήσεις/διαγράψεις σχέσεις **δυναμικά** (χωρίς προκαθορισμένο όριο τύπων) και να τους δώσεις οποιοδήποτε όνομα (labels) και ιδιότητες.
    *   Το μοντέλο βασίζεται στις οντότητες *και* τις σχέσεις ("ποιες οντότητες έχω και πώς συνδέονται").
    *   Οι σχέσεις **δεν υπολογίζονται** αλλά **είναι αποθηκευμένες/μόνιμες (persistent)**. Αυτό τις καθιστά πιο ακριβές κατά την εισαγωγή (περισσότερα costly inserts) αλλά εξαιρετικά αποδοτικές στην ανάκτηση/διάσχιση (read/traversal).

## **6. Μοντελοποίηση Σχεσιακού σε Γράφο (Relational to Graphs) (Slides 13-15)**

*   Τα δεδομένα που αποθηκεύονται σε RDBMS μπορούν να αναπαρασταθούν σε Graph Databases, αλλά η "φυσική" μορφή τους αλλάζει.
*   Παράδειγμα Persons & Movies (Slide 13): Ένας σχεσιακός πίνακας `Actors` (με PersonID, MovieID, Role) γίνεται απλές σχέσεις `:ACTED_IN` μεταξύ κόμβων `Person` και `Movie` με ιδιότητα `Role`.
*   Παράδειγμα Projects, Persons, Organizations (Slides 14-15): Πολύπλοκες σχέσεις (FKs) σε RDBMS (Slide 14) μετατρέπονται σε σαφείς, ονομασμένες σχέσεις στο γράφο (:BELONGS_TO, :LEAD_BY, :WORKS_AT, :IS_PART_OF).

## **7. Αρχιτεκτονικές Graph Database Storage Model (Slides 22-24)**

Υπάρχουν δύο κύριες προσεγγίσεις για το πώς μια Graph Database αποθηκεύει τα δεδομένα της:

*   **Native Graph Databases (Φυσικές/Εγγενείς) (Slides 22, 23):**
    *   Βασίζονται σε ένα μοντέλο αποθήκευσης **ειδικά σχεδιασμένο για δομές γράφου**.
    *   Είναι βελτιστοποιημένες για λειτουργίες γράφου (ταχεία διάσχιση).
    *   Παράδειγμα: **Neo4j** (φυσική Graph Database, βλ. παρακάτω). Αποθηκεύει κόμβους, σχέσεις και ιδιότητες σε ξεχωριστά αρχεία. Οι σχέσεις σχηματίζουν doubly linked lists μεταξύ κόμβων. Χρησιμοποιεί pointers για τη σύνδεση.
    *   Παράδειγμα: **Sparksee (DEX)** (Graph database που αντιμετωπίζει κόμβους/σχέσεις ως objects).
*   **Graph Databases built upon existing storage models (Μη-εγγενείς / Φτιαγμένες πάνω σε υπάρχοντες μηχανισμούς) (Slides 22, 24):**
    *   Χρησιμοποιούν υπάρχοντες, γενικούς μηχανισμούς αποθήκευσης (π.χ. Key-Value stores, Document stores) ως **υποκείμενο στρώμα**, και προσθέτουν ένα **graph layer (επίπεδο γράφου)** από πάνω.
    *   Παράδειγμα: **OrientDB** (Multi-model database, υποστηρίζει Document, Graph, KV, Object μοντέλα).
    *   Παράδειγμα: **Titan** (Distributed Graph Database). Υποστηρίζει **διαφορετικούς backends** για αποθήκευση, π.χ. BerkeleyDB (embedded KV), Cassandra (Column-family), HBase (Column-family). Βασίζεται σε αυτές για μονιμότητα και διανομή.
    *   Πλεονέκτημα: Εκμετάλλευση των χαρακτηριστικών κλιμάκωσης/διαθεσιμότητας των υποκείμενων storages.
    *   Μειονέκτημα: Η διάσχιση γράφου μπορεί να μην είναι τόσο γρήγορη όσο σε μια Native Graph DB, καθώς η προσπέλαση δεδομένων του γράφου πρέπει να "περάσει" από το στρώμα του υποκείμενου storage engine.

## **8. Graph Parallel Processing Engines (Slide 25)**

*   Αυτά δεν είναι απαραίτητα βάσεις δεδομένων αποθήκευσης, αλλά **engines για την επεξεργασία γράφων σε μεγάλη κλίμακα**, συχνά για αναλυτικές εργασίες (batch analysis) ή σύνθετους αλγορίθμους (π.χ. PageRank, community detection) σε δεδομένα γράφου.
*   Μπορούν να δουλέψουν με δεδομένα γράφου που είναι αποθηκευμένα αλλού (π.χ. σε Hadoop).
*   Σχεδιασμένα για **μαζική διανομή (massive distribution)** της επεξεργασίας.
*   Παρέχουν APIs και αλγορίθμους ειδικά για επεξεργασία γράφων.
*   Συστήματα: **Apache Giraph** (τρέχει πάνω σε Hadoop/MapReduce), **GraphX** (μέρος του Apache Spark), το **Titan** (αν και βάση δεδομένων, συχνά χρησιμοποιείται σε αυτό το πλαίσιο).

## **9. Neo4j - Βάση Δεδομένων Γράφου (Slides 27-44)**

Το **Neo4j** είναι η πιο γνωστή και ευρέως χρησιμοποιούμενη Native Graph Database. (Slide 28)

*   **Γενικά:** Open Source, Cross-Platform, γραμμένο σε Java.
*   **Μοντέλο Δεδομένων:** Property Graph (κόμβοι, σχέσεις, ιδιότητες). Υποστηρίζει `Labels` στους κόμβους (ομαδοποίηση κόμβων).
*   **Σχεδιασμός:** Κλιμακούμενο για **δισεκατομμύρια κόμβους**. Προαιρετικό σχήμα (optional schema) για επιδόσεις και μοντελοποίηση. Σχεδιασμένο για **OLTP workloads** με υποστήριξη **ACID transactions**. Υποστηρίζει multi-version consistency και Master-slave replication (για διαθεσιμότητα).
*   **Cypher (Slides 31-44):**
    *   Είναι η κύρια **γλώσσα ερωτημάτων** του Neo4j.
    *   Είναι μια **δηλωτική (declarative)** γλώσσα, **SQL-inspired**, σχεδιασμένη για την **οπτική περιγραφή μοτίβων (patterns)** σε γράφους, χρησιμοποιώντας ASCII-art σύνταξη.
    *   **Σύνταξη:** Χρησιμοποιεί `( )` για κόμβους και `-->` για κατευθυνόμενες σχέσεις. Μεταβλητές (π.χ. `(a)`, `[r]`), Labels (`(a:Person)`), και Properties (`(a:Person {name: 'Jim'})`) μπορούν να δηλωθούν μέσα στα μοτίβα. Μπορεί να δηλωθεί ο τύπος της σχέσης (`-[r:LOVES]->`). Επαναλήψεις σχέσεων (`-[*1..3]`). (Slides 32-33, 37).
    *   **Pattern Matching:** Τα μοτίβα αποτελούν τα δομικά στοιχεία για σύνθετα ερωτήματα. Μπορούν να συνδεθούν με κόμμα (`,`). Αναφέρεται σε μεταβλητές (όνομα κόμβου/σχέσης) που δηλώθηκαν νωρίτερα. (Slide 34, 35).
    *   **Δομή Ερωτήματος Cypher (Read Query):** `MATCH` -> `WHERE` -> `WITH` -> `RETURN` (Διαφάνεια 38, 39).
        *   `MATCH`: Καθορίζει το **μοτίβο** (pattern) γράφου που αναζητείται.
        *   `WHERE`: Πρόσθετοι **περιορισμοί φιλτραρίσματος** σε κόμβους ή σχέσεις.
        *   `WITH`: Χρησιμοποιείται για **chaining** αποτελεσμάτων ερωτημάτων (pipeline).
        *   `RETURN`: Καθορίζει τι **να επιστραφεί** (όπως SELECT). Υποστηρίζει ORDER BY, SKIP, LIMIT.
    *   **Παράδειγμα Query Cypher (Slide 36):** Αναζήτηση φίλων-του-Jim (two hops away).
    *   **Δομή Ερωτήματος Cypher (Write Query):** `(CREATE | MERGE)` -> `SET|DELETE|REMOVE|FOREACH` -> `RETURN` (Διαφάνεια 41, 42, 43).
        *   `CREATE`: Δημιουργία νέων κόμβων ή σχέσεων. `CREATE UNIQUE` για να δημιουργηθεί μόνο αν δεν υπάρχει.
        *   `MERGE`: Συνδυάζει `MATCH` και `CREATE`. Βρίσκει ένα μοτίβο. Αν υπάρχει, το επιστρέφει. Αν δεν υπάρχει, το δημιουργεί.
        *   `SET`: Ενημερώνει ιδιότητες ή labels.
        *   `DELETE`: Διαγράφει κόμβους ή σχέσεις.
        *   `REMOVE`: Διαγράφει labels ή ιδιότητες.
        *   `FOREACH`: Εκτελεί ενέργειες για κάθε στοιχείο σε μια λίστα.
    *   **Παράδειγμα Write Query Cypher (Slide 44):** MERGE δύο κόμβων (με βάση το όνομα) και δημιουργία σχέσης `LOVES` μεταξύ τους (αν δεν υπάρχει ήδη).

## **Σύνδεση με το μάθημα:**

Οι Graph Databases προσφέρουν μια ισχυρή εναλλακτική για δεδομένα με πλούσιες, διασυνδεδεμένες σχέσεις. Η κατανόηση του Property Graph model και της γλώσσας Cypher του Neo4j είναι απαραίτητη αν θέλετε να διαχειριστείτε δεδομένα σε τομείς όπως Social Networks, Recommendation Engines, Knowledge Graphs, Fraud Detection, όπου η δομή του δικτύου είναι κλειδί. Σε ένα Cloud περιβάλλον, ενώ το Neo4j (ως Native) είναι καλό για OLTP και Traversals, για μεγάλα κατανεμημένα αναλυτικά workloads σε γράφους, συχνά χρησιμοποιούνται Engines όπως Giraph/GraphX πάνω σε συστήματα Big Data (π.χ. Hadoop/Spark) ή Distributed Graph Databases όπως Titan (χρησιμοποιώντας υποκείμενα distributed storages).


---

## **Cypher: Η Γλώσσα Ερωτημάτων της Neo4j**

*   Είναι μια **δηλωτική** (declarative) γλώσσα, **εμπνευσμένη από την SQL**, αλλά ειδικά σχεδιασμένη για γραφήματα.
*   Περιγράφει τα μοτίβα που θέλουμε να αναζητήσουμε ή να επεξεργαστούμε στο γράφημα **οπτικά**, χρησιμοποιώντας ένα είδος "ascii-art" σύνταξης.

---

## **Σύνταξη της Cypher:**

*   **Κόμβοι (Nodes):**
    *   `()` : Ανώνυμος κόμβος (υπάρχει, αλλά δεν μας ενδιαφέρει να τον αναφέρουμε ξανά).
    *   `(x)` : Εκχωρεί τη μεταβλητή `x` στον κόμβο. Η μεταβλητή αυτή είναι προσβάσιμη στο εύρος (scope) του ερωτήματος.
    *   `(x: Label)` : Κόμβος με τη μεταβλητή `x` και το label `Label`. Τα labels κατηγοριοποιούν τους κόμβους. Ένας κόμβος μπορεί να έχει πολλά labels (π.χ., `:Person:Entity`).
    *   `(x {property: "abc"})` : Κόμβος `x` με συγκεκριμένη τιμή στην ιδιότητα `property`. Αναφερόμαστε σε αυτήν την ιδιότητα ως `x.property`.
*   **Σχέσεις (Relationships):**
    *   `-->` ή `<--` : Δείχνει κατευθυνόμενη σχέση. `(a)--> (b)` σημαίνει σχέση από `a` προς `b`.
    *   `--` : Δείχνει μη-κατευθυνόμενη σχέση (η Cypher την αντιμετωπίζει σαν να είναι προς και τις δύο κατευθύνσεις κατά το ταίριασμα μοτίβων, αν και οι σχέσεις αποθηκεύονται με κατεύθυνση στη Neo4j).
    *   `-[ ]->` ή `<-[ ]-` ή `-[ ]-` : Εντός των αγκύλων `[ ]` μπαίνουν τα χαρακτηριστικά της σχέσης.
    *   `-[r]->` : Εκχωρεί τη μεταβλητή `r` στη σχέση.
    *   `-[:TYPE]->` : Σχέση τύπου `TYPE`. Μπορεί να έχει πολλαπλούς τύπους με `|` (π.χ., `[:RELATES1|RELATES2]`).
    *   `-[r:TYPE]->` : Σχέση με μεταβλητή `r` και τύπο `TYPE`.
    *   `-[r:TYPE {property:'abc'}]->` : Σχέση `r` τύπου `TYPE` με συγκεκριμένη ιδιότητα `property`. Αναφορά ως `r.property`.
    *   `-[*1..3]->` : Ορίζει το μήκος της διαδρομής. Σχέση που επαναλαμβάνεται 1 έως 3 φορές (π.χ., φίλοι του φίλου, φίλοι του φίλου του φίλου). `*` σημαίνει 0 ή περισσότερες, `*N` N ή περισσότερες, `*N..M` από N έως M, `*..M` 0 έως M.

**Μοτίβα (Patterns):** Συνδυασμοί κόμβων και σχέσεων που περιγράφουν ένα μέρος του γραφήματος (ή τη δομή που ψάχνουμε). Γράφονται συνεχόμενα ή διαχωρισμένα με κόμμα. Μπορούμε να αναφερθούμε σε μεταβλητές που δηλώθηκαν νωρίτερα. (Παραδείγματα διαφανειών 34, 35).

---

## **Δομή Ερωτημάτων Cypher:**

*   **Δομή Ανάγνωσης (Read Query Structure):**
    `[MATCH WHERE]`
    `[OPTIONAL MATCH WHERE]`
    `[WITH [ORDER BY] [SKIP] [LIMIT]]`
    `RETURN [ORDER BY] [SKIP] [LIMIT]`

    *   **MATCH:** Η θεμελιώδης ρήτρα για **εύρεση μοτίβων** στο γράφημα. Βρίσκει τα μέρη του γραφήματος που ταιριάζουν με τα μοτίβα που ορίζουμε.
    *   **WHERE:** Εφαρμόζει επιπλέον **συνθήκες/φίλτρα** στις μεταβλητές ή τις ιδιότητες που βρέθηκαν στο MATCH.
    *   **OPTIONAL MATCH:** Δοκιμάζει να ταιριάξει ένα μοτίβο, αλλά δεν απορρίπτει ολόκληρο το αποτέλεσμα αν δεν βρεθεί ταίριασμα (οι μεταβλητές που δεν βρέθηκαν είναι null).
    *   **WITH:** Χρησιμοποιείται για να **"αλυσοδέσει" (pipeline)** μέρη ενός ερωτήματος. Επιτρέπει τη μετάβαση αποτελεσμάτων από ένα βήμα στο επόμενο, φιλτράρισμα, ταξινόμηση ή ομαδοποίηση ενδιάμεσα. Λειτουργεί ως το "κεφάλι" του επόμενου βήματος (π.χ., ενός νέου MATCH ή ενός RETURN).
    *   **RETURN:** Καθορίζει ποια δεδομένα θα **επιστραφούν** ως αποτέλεσμα του ερωτήματος (όπως η SELECT στην SQL). Μπορεί να επιστρέψει κόμβους, σχέσεις, ιδιότητες, υπολογισμένες τιμές (π.χ., με count()).
    *   **ORDER BY:** Ταξινομεί τα αποτελέσματα.
    *   **SKIP:** Παραλείπει έναν αριθμό αποτελεσμάτων από την αρχή (όπως OFFSET).
    *   **LIMIT:** Περιορίζει τον μέγιστο αριθμό αποτελεσμάτων που θα επιστραφούν.

*   **Δομή Εγγραφής (Write-Only Query Structure):**
    `(CREATE [UNIQUE] | MERGE)*`
    `[SET | DELETE | REMOVE | FOREACH]*`
    `[RETURN [ORDER BY] [SKIP] [LIMIT]]` (Το RETURN είναι προαιρετικό στην εγγραφή)

    *   **CREATE:** Δημιουργεί νέα στοιχεία (κόμβους ή σχέσεις) στο γράφημα.
    *   **MERGE:** Προσπαθεί να ταιριάξει ένα μοτίβο. **Εάν το μοτίβο βρεθεί**, επιστρέφει τα στοιχεία που ταιριάζουν. **Εάν δεν βρεθεί**, **δημιουργεί** το μοτίβο. Είναι ένας συνδυασμός MATCH και CREATE, χρήσιμο για αποφυγή διπλότυπων. Η [UNIQUE] επιτρέπει τον ορισμό constraints.
    *   **SET:** Ενημερώνει (προσθέτει ή τροποποιεί) **ιδιότητες** σε κόμβους ή σχέσεις. Μπορεί επίσης να προσθέσει **labels** σε κόμβους.
    *   **DELETE:** Διαγράφει κόμβους ή σχέσεις. Η διαγραφή κόμβου απαιτεί πρώτα τη διαγραφή όλων των σχέσεων που συνδέονται με αυτόν.
    *   **DETACH DELETE:** Διαγράφει έναν κόμβο **μαζί** με όλες τις σχέσεις του.
    *   **REMOVE:** Διαγράφει **labels** από κόμβους ή συγκεκριμένες **ιδιότητες** από κόμβους ή σχέσεις (όχι τα ίδια τα στοιχεία).
    *   **FOREACH:** Εκτελεί μία ή περισσότερες ενέργειες σε κάθε στοιχείο μιας λίστας.

*   **Δομή Ανάγνωσης-Εγγραφής (Read-Write Query Structure):** Συνδυάζει ρήτρες ανάγνωσης (MATCH, WITH) και ρήτρες εγγραφής (CREATE, MERGE, SET, DELETE, κλπ) στην ίδια εντολή, ακολουθώντας μια λογική σειρά.

**(Σημείωση: Δείτε τα παραδείγματα Cypher στις διαφάνειες 35, 36, 40, 44 για πρακτική εξάσκηση στο συντακτικό.)**

---

## **Τελική Σύνοψη:**

Οι βάσεις δεδομένων γραφήματος είναι μια ισχυρή εναλλακτική λύση στις σχεσιακές βάσεις όταν η δομή των δεδομένων είναι πολύπλοκο δίκτυο και οι σχέσεις και οι διασχίσεις αυτού του δικτύου είναι κεντρικές στην εφαρμογή και στα ερωτήματα. Το μοντέλο Property Graph και γλώσσες όπως η Cypher στη Neo4j παρέχουν μια διαισθητική και αποδοτική προσέγγιση για τη μοντελοποίηση, αποθήκευση και ανάκτηση αυτών των δεδομένων.
