# **Column Stores / Column Family Databases - Με έμφαση στην Cassandra**

**1. Σύγκριση Relational (OLTP) και OLAP (Slides 2-3)**

Πριν δούμε τις Column Stores, ανασκοπούμε τις διαφορές μεταξύ δύο κύριων κατηγοριών εφαρμογών βάσεων δεδομένων:

*   **OLTP (Online Transaction Processing):**
    *   Σχεδιασμός βάσης: Βελτιστοποιημένος για γρήγορες, συχνές, μικρές συναλλαγές που αφορούν μικρό αριθμό εγγραφών (record-at-a-time processing).
    *   Χαρακτηριστικά: Συχνές ενημερώσεις (updates), πολλοί χρήστες, γρήγορος χρόνος απόκρισης.
    *   Απαιτεί ένα **write-optimized row store** (τα δεδομένα οργανώνονται σε αρχεία γραμμών).
    *   Εύκολο να προσθέσεις νέα εγγραφή, αλλά η ανάγνωση μπορεί να "πετύχει" μη απαραίτητα δεδομένα (αν η στήλη δεν χρειάζεται, αλλά βρίσκεται στην ίδια γραμμή).
*   **OLAP (Online Analytical Processing):**
    *   Σχεδιασμός βάσης: Βελτιστοποιημένος για υποστήριξη αποφάσεων (decision support), business intelligence. Αφορά εκτέλεση αναφορών (report programs), συχνά offline.
    *   Χαρακτηριστικά: Συναλλαγές που αφορούν **μεγάλο αριθμό εγγραφών** (batch processing), συχνά ad-hoc ερωτήματα (που δεν είναι προκαθορισμένα), σπάνιες ενημερώσεις (updates, συχνά batch updates), λίγοι χρήστες (επαγγελματίες που αναλύουν δεδομένα), γρήγορος χρόνος απόκρισης (εννοείται για αναλυτικά ερωτήματα, όχι για απλή προσπέλαση).
    *   Σχεσιακές βάσεις (RDBMS) έχουν βελτιστοποιηθεί πρωταρχικά για OLTP.
    *   **Data Warehouse:** Τυπική υλοποίηση για OLAP. Δεδομένα: ιστορικά, συνοπτικά, aggregated. Σχεδιασμός: Star schema, snowflake schema (αναφερόμαστε στη λογική οργάνωση, Slide 4). Δεδομένα συχνά απο-κανονικοποιημένα (unormalized). Κυρίως εργασίες ανάγνωσης (read operations). Ενημερώσεις γίνονται σπάνια και σε batches (batch updates).

**2. Η προσέγγιση Columnar (Slides 5-7)**

*   **Βασική Ιδέα (Key Intuition):** Αντί να αποθηκεύουμε τα δεδομένα οργανωμένα κατά **γραμμή (row-oriented)** (όπως τα παραδοσιακά RDBMS), αποθηκεύουμε τα δεδομένα οργανωμένα κατά **στήλη (column-oriented)**.
    *   Σε μια Row-oriented βάση, για έναν πίνακα (π.χ. Employee) με στήλες (ID, Name, DOB, Salary, Sales, Expenses), η εγγραφή για τον "Dick" αποθηκεύεται ως μια συνεχόμενη ακολουθία τιμών: [1001, Dick, 21/12/1960, 67000, 78980, 3244]. Όλη η γραμμή είναι μαζί.
    *   Σε μια Column-oriented βάση, **όλες οι τιμές για μια συγκεκριμένη στήλη** αποθηκεύονται μαζί. Θα είχαμε μια περιοχή για όλα τα IDs: [1001, 1002, 1003, ...], μια περιοχή για όλα τα Names: [Dick, Jane, Robert, ...], κ.ο.κ. (Slide 5).
*   **Σημασία:** Για ένα ερώτημα που αφορά μόνο συγκεκριμένες στήλες (π.χ. `SELECT AVG(Salary) FROM Employee`), μια Column-oriented βάση χρειάζεται να διαβάσει μόνο τα δεδομένα της στήλης "Salary". Μια Row-oriented βάση πρέπει να διαβάσει *ολόκληρες* τις γραμμές και να "πετάξει" τα δεδομένα των στηλών που δεν χρειάζονται (wasted I/O). (Slide 6, 7, 8).
*   **Χαρακτηριστικά Column Stores (Slide 6):**
    *   **Logical Data Model:** Μπορεί να βασίζεται στο Σχεσιακό Μοντέλο (tables, columns, rows), αλλά η **φυσική αποθήκευση** είναι κατά στήλη.
    *   **Βελτιστοποιημένες για Aggregation Queries:** Όπως SUM, AVG, COUNT. Το να διαβάζεις μόνο τις τιμές μιας στήλης είναι πολύ αποδοτικό για αυτούς τους υπολογισμούς.
    *   **Columnar Compression:** Επειδή όλες οι τιμές σε μια στήλη είναι του ίδιου τύπου δεδομένων (και συχνά έχουν παρόμοιες τιμές ή μοτίβα), μπορούν να συμπιεστούν πολύ αποτελεσματικά. Αυτό μειώνει το μέγεθος των δεδομένων στο δίσκο (και άρα το I/O για να τις διαβάσεις).
    *   **Columnar Write Penalty:** Η προσθήκη μιας **νέας εγγραφής** σε έναν πίνακα είναι πιο σύνθετη και δαπανηρή σε μια Columnar βάση (write penalty) από ό,τι σε μια Row-oriented. Πρέπει να γράψεις τη νέα τιμή για *κάθε* στήλη στην αντίστοιχη περιοχή αποθήκευσης αυτής της στήλης (που είναι διάσπαρτη). Σε μια Row-oriented, απλώς προσθέτεις την πλήρη γραμμή στο τέλος του αρχείου (Slide 11).
*   **Πλεονεκτήματα Συμπίεσης (Slide 9):**
    *   Μειώνει το μέγεθος των δεδομένων.
    *   Βελτιώνει την I/O απόδοση δίσκου και μνήμης: μειώνει seek times (σχετικά δεδομένα μαζί), μειώνει transfer times (λιγότερα δεδομένα), αυξάνει buffer hit rate (περισσότερα δεδομένα χωράνε στη μνήμη).
    *   Μέθοδοι Συμπίεσης (Slide 10): Dictionary encoding (αντικατάσταση επαναλαμβανόμενων τιμών με μικρότερους δείκτες), Delta encoding (αποθήκευση διαφορών μεταξύ διαδοχικών τιμών - λειτουργεί καλύτερα σε ταξινομημένα δεδομένα).
*   **Ιστορικό Column Stores (Slide 12):** Δεν είναι νέα ιδέα. Πρωτοεμφανίστηκαν σε εξειδικευμένα Data Warehousing συστήματα από τα μέσα των 90s (Sybase IQ), με πιο εξελιγμένες υλοποιήσεις μετά τα 2000 (C-Store, Vertica, InfoBright). Πιο πρόσφατα, η columnar αποθήκευση έχει ενσωματωθεί και σε παραδοσιακά RDBMS για OLAP workloads (π.χ. Oracle Exadata, MS SQL Server Columnstore Index, SAP HANA).

**3. Αρχιτεκτονική Column Databases (Slides 13-16)**

*   **Πρόκληση Ενημερώσεων:** Η Columnar οργάνωση είναι ακατάλληλη για workloads με συνεχή ροή ενημερώσεων (write-heavy OLTP). Οι batch updates λειτουργούν καλύτερα.
*   **Λύση: Write-Optimized Delta Store (Slides 13, 14):** Για να διαχειριστούν τις συχνές ενημερώσεις, πολλές Columnar βάσεις χρησιμοποιούν μια "υβριδική" αρχιτεκτονική. Τα δεδομένα που **ενημερώνονται συχνά** ή εισάγονται πρόσφατα, αποθηκεύονται προσωρινά σε μια δομή **write-optimized** (π.χ. σε RAM ή SSD με δομή LSM Tree), ενώ τα "παλαιότερα" και πιο σταθερά δεδομένα αποθηκεύονται στη βελτιστοποιημένη για ανάγνωση Columnar δομή.
    *   **Delta Store:** Αποθηκεύει τις πρόσφατες ενημερώσεις. Μπορεί να είναι hybrid (row/column), in-memory, uncompressed, βελτιστοποιημένο για συχνές updates.
    *   Τα δεδομένα από το Delta Store **συγχωνεύονται (merged)** περιοδικά με το Column Store.
    *   Ερωτήματα μπορεί να χρειαστεί να προσπελάσουν και τους δύο "χώρους" (delta και columnar store) και να συνδυάσουν τα αποτελέσματα. (Παρόμοια ιδέα με LSM Trees).
*   **Projections (Προβολές) (Slides 15-16):**
    *   Σε μια Columnar βάση, ένας λογικός πίνακας μπορεί να αναπαρασταθεί φυσικά ως ένα σύνολο από **"προβολές"**.
    *   Κάθε προβολή αποτελείται από ένα **υποσύνολο των στηλών** του πίνακα. Οι στήλες σε μια προβολή αποθηκεύονται μαζί (συνήθως ταξινομημένες βάσει ενός κοινού SORT KEY).
    *   Μια στήλη μπορεί να εμφανίζεται σε **μία ή περισσότερες προβολές**, ενδεχομένως με διαφορετικές διατάξεις ταξινόμησης (sort orders).
    *   Οι προβολές μπορούν να δημιουργηθούν χειροκίνητα, αυτόματα από τον query optimizer (βάσει ερωτημάτων) ή μαζικά (batch) βάσει ιστορικού workloads.
    *   Στόχος: να βελτιστοποιηθεί η προσπέλαση για συγκεκριμένα ερωτήματα διατηρώντας μόνο τις απαραίτητες στήλες μαζί και με την κατάλληλη διάταξη.

**4. Cassandra (Slides 1, 17-47)**

Η **Cassandra** είναι ένα δημοφιλές παράδειγμα Column Family Store στο χώρο του NoSQL. Δημιουργήθηκε από τη Facebook (2008), open-sourced στην Apache. Γράφτηκε σε Java. (Slide 17)

*   **Goals:** Σχεδιάστηκε για:
    *   **Scalability (read/write throughput):** Να μπορεί να χειριστεί υψηλό φόρτο εγγραφών και αναγνώσεων.
    *   **Availability:** Να είναι διαθέσιμη συνεχώς.
    *   **Fault Tolerance:** Να είναι ανθεκτική σε αποτυχίες κόμβων ή δικτύου. (Έντονη εστίαση στις ιδιότητες A+P του CAP Theorem).
*   **Data Model (Slides 18-21):**
    *   Βασίζεται στις ιδέες του **Google BigTable** (που είναι επίσης Column-family store).
    *   Δεδομένα οργανωμένα σε **tables** (παρόμοια με RDBMS).
    *   Tables ευρετηριασμένες και ταξινομημένες βάσει ενός **rowkey**.
    *   Οι στήλες οργανώνονται σε **Column Families**.
        *   Column Families: Μια "ομάδα" σχετιζόμενων στηλών.
        *   Μπορούν να είναι simple ή super (nested) column families. (Πιο σύνθετες δομές στήλης).
        *   Διαφορά με RDBMS: Οι στήλες σε μια γραμμή της Cassandra *μπορεί να διαφέρουν* από γραμμή σε γραμμή στην ίδια "Column Family" - δεν υπάρχει σταθερό σχήμα. (Slide 22 - RDBMS vs Cassandra).
    *   Τα δεδομένα για μια συγκεκριμένη **Column Family** αποθηκεύονται **μαζί** στον δίσκο.
    *   Ένα **cell** (η τομή γραμμής και στήλης) μπορεί να περιέχει **πολλαπλές εκδόσεις** ενός δεδομένου, αναγνωρισμένες από ένα **timestamp**. Η Cassandra χρησιμοποιεί timestamps για να καθορίσει την τελευταία έκδοση (last write wins conflict resolution, Slide 20, 46).
    *   Οι στήλες **μπορούν να ευρετηριαστούν** βάσει του ονόματός τους. Υποστηρίζει secondary indexes (αν και με περιορισμούς σε σχέση με RDBMS). Το primary index είναι ο **row key**.
    *   ColumnName: Ο όρος `ColumnFamily:ColumnName` ή `ColumnFamily:SuperColumn:ColumnName` δείχνει την ιεραρχική φύση των στηλών στην Cassandra (Slide 21).
*   **Βασικές Λειτουργίες και CQL (Slides 23-27, 50-52):**
    *   Βασικές λειτουργίες Key-Value: **GET, SET, DEL**.
    *   **CQL (Cassandra Query Language):** Μια γλώσσα ερωτημάτων που **μοιάζει με SQL** (SQL-like), αλλά είναι απλούστερη και προσαρμοσμένη στο data model της Cassandra. Χρησιμοποιείται για ad-hoc ερωτήματα (μέσω του `cqlsh` shell), απλοποιεί τις εργασίες προγραμματισμού. (Slide 23, 50)
    *   Περιλαμβάνει δηλώσεις DDL: `CREATE`, `ALTER`, `DROP`, `TRUNCATE` για **Keyspaces** (παρόμοιο με βάσεις) και **Tables**.
    *   Δηλώσεις DML: `SELECT`, `INSERT`, `UPDATE`, `DELETE`.
    *   **Διαφορές CQL από SQL (Slides 23, 51):**
        *   **No joins or subqueries:** Δεν υποστηρίζει joins μεταξύ πινάκων (πρέπει να γίνουν στην εφαρμογή ή μέσω client-side Joins).
        *   **Simpler WHERE conditions:** Οι συνθήκες στο `WHERE` clause είναι περιορισμένες (περιορίζονται κυρίως στο row key και σε indexed columns).
        *   `SELECT` και `ORDER BY` έχουν περιορισμούς, συχνά βασίζονται στο clustering columns μέσα σε ένα specific partition key (Slide 51, 52 - CQL SELECT).
    *   **Cassandra Collections (Slides 26-27):** Πιο πρόσφατα (στις διαφάνειες αναφέρεται στο CQL CREATE TABLE) η Cassandra εισήγαγε support για Collection Data Types στην τιμή μιας στήλης: `set`, `list`, `map`.
*   **Partioning & Consistent Hashing (Slides 30-34):**
    *   Η Cassandra είναι σχεδιασμένη για **κατανεμημένο partitionning**. Καθορίζει πώς τα δεδομένα διανέμονται στους κόμβους (συμπεριλαμβανομένων των αντιγράφων).
    *   Χρησιμοποιεί **Consistent Hashing**. Οι κόμβοι είναι δομημένοι σε ένα **δακτύλιο (ring)**. Κάθε κόμβος λαμβάνει ένα εύρος τιμών. Το hash value του data key (row key) καθορίζει τη θέση των δεδομένων στον δακτύλιο.
    *   **Partitioner:** Ο αλγόριθμος που υπολογίζει το hash value του row key και καθορίζει σε ποιο σημείο στον δακτύλιο θα τοποθετηθούν τα δεδομένα.
        *   Murmur3Partitioner (προεπιλογή): Ομοιόμορφη κατανομή.
        *   RandomPartitioner (MD5): Παλαιότερη, ομοιόμορφη κατανομή.
        *   ByteOrderedPartitioner: Διατηρεί τη λεξικογραφική σειρά των κλειδιών (σχετικό hash), επιτρέποντας αναζήτηση εύρους κλειδιών στον δακτύλιο. (Παρόμοιο με Range-based partitioning σε RDBMS/MongoDB).
    *   **Node Addition:** Σε Consistent Hashing, η προσθήκη νέου κόμβου είναι πιο αποδοτική από απλό hashing. Ο νέος κόμβος "κλέβει" ένα εύρος hashes από τους υπάρχοντες. (Slide 32).
    *   **Virtual Nodes (vnodes):** Αντί κάθε φυσικός κόμβος να έχει ένα μεγάλο εύρος στον δακτύλιο, κάθε κόμβος λαμβάνει ένα μεγάλο **αριθμό μικρών, τυχαία κατανεμημένων ευρών** (π.χ. 256 vnodes). Αυτό κάνει την κατανομή φόρτου πιο ομοιόμορφη (load balancing), απλοποιεί το balancing μετά την προσθήκη/αφαίρεση κόμβων και εκμεταλλεύεται ετερογενείς κόμβους. (Slide 33)
*   **Gossip Protocol (Slides 35-36):**
    *   Η Cassandra έχει μια **Peer-to-Peer (p2p)** αρχιτεκτονική. **Όλοι οι κόμβοι είναι ίσοι (equal)**, δεν υπάρχει master node (ή, πιο σωστά, οποιοσδήποτε κόμβος μπορεί να είναι coordinator για μια client operation).
    *   Για να διασφαλιστεί ότι όλοι οι κόμβοι είναι ενήμεροι για την τρέχουσα **κατάσταση και διαμόρφωση** του cluster (ποιοι κόμβοι είναι up/down, ποιοι διαχειρίζονται ποια ranges), χρησιμοποιούνται **Gossip protocols**.
    *   Gossip process: Τρέχει κάθε δευτερόλεπτο. Κάθε κόμβος μεταδίδει πληροφορίες για την κατάστασή του (και την κατάσταση κόμβων που γνωρίζει) σε λίγους άλλους κόμβους. Αυτό επιτρέπει γρήγορη ανίχνευση αποτυχιών και ενημέρωση του cluster.
*   **Replication (Slides 37-40):**
    *   Όλα τα αντίγραφα **είναι εξίσου σημαντικά**. No master! (Σχεδιασμός για A+P).
    *   **Replication Factor N:** Ο αριθμός των κόμβων στους οποίους **πρέπει να γραφτούν** τα δεδομένα. Καθορίζεται στο επίπεδο **Keyspace**.
    *   Κόμβος Coordinator: Ο κόμβος στον οποίο συνδέεται ο client για μια operation. Είναι υπεύθυνος για την αναπαραγωγή (διασφαλίζει ότι το write φτάνει σε N κόμβους).
    *   **Replica Placement Strategy (Στρατηγική Τοποθέτησης Αντιγράφων) (Slides 38-39):** Πώς τοποθετούνται τα N αντίγραφα ενός data key.
        *   Simple Strategy (Default): Τα αντίγραφα τοποθετούνται στους **N-1 επόμενους κόμβους** (clockwise) στον δακτύλιο Consistent Hashing (συμπεριλαμβανομένου του coordinator). Τα αντίγραφα είναι **τοποθετημένα κοντά** στον δακτύλιο.
        *   Network Topology Aware Strategy: Επιπλέον, λαμβάνεται υπόψη η **τοπολογία του δικτύου/data center**. Διασφαλίζει ότι τα αντίγραφα τοποθετούνται σε **διαφορετικές server racks** ή ακόμα και σε **διαφορετικά data centers**. Αυτό βελτιώνει την ανθεκτικότητα σε βλάβες που επηρεάζουν ένα rack ή ένα data center.
    *   **Πόσα Αντίγραφα; (Slide 40):** Συνήθως 2-3 αντίγραφα ανά data center. Trade-off: περισσότερα αντίγραφα βελτιώνουν διαθεσιμότητα/τοπικές αναγνώσεις, αλλά αυξάνουν κόστος αποθήκευσης και κόστος/καθυστέρηση εγγραφών.
*   **Consistency (Slides 41-44):** Η Cassandra παρέχει **Tunable Consistency**, παρόμοια με το Dynamo. Για κάθε ενέργεια (read ή write) μπορείς να καθορίσεις πόσα αντίγραφα (`W` για write, `R` για read) πρέπει να ανταποκριθούν για να θεωρηθεί η ενέργεια επιτυχής. (`N` είναι ο Replication Factor).
    *   **Consistency Levels for Writes (Slide 42):**
        *   ALL: Write επιβεβαιώνεται από όλα τα N αντίγραφα. Strong Consistency, αλλά slow write και 1 κόμβος down -> failure.
        *   ONE|TWO|THREE: Write επιβεβαιώνεται από τον coordinator + 1, 2, ή 3 replicas. ONE: max efficiency, max risk.
        *   QUORUM: Write επιβεβαιώνεται από την πλειοψηφία των replicas (`floor(N/2) + 1`).
        *   EACH_QUORUM: Write επιβεβαιώνεται από πλειοψηφία **σε κάθε data center**.
        *   LOCAL_QUORUM: Write επιβεβαιώνεται από πλειοψηφία **στο τρέχον data center**.
        *   ANY: Write επιτυχές αν επιβεβαιωθεί από **έστω και 1 κόμβο** (ακόμα και αν ο στόχος ήταν άλλος - **hinted handoff** - ο coordinator θα προσπαθήσει να στείλει την ενημέρωση αργότερα στο σωστό κόμβο αν είναι κάτω). Minimum Consistency, Maximum Availability.
    *   **Consistency Levels for Reads (Slide 43):**
        *   ALL: Όλα τα N αντίγραφα ερωτώνται, η πιο πρόσφατη τιμή επιστρέφεται. Strictest Consistency, αλλά slow read.
        *   ONE|TWO|THREE: Ερώτηση στον coordinator + 1, 2, ή 3 replicas (συχνά οι "κοντινότεροι" - determined by snitches).
        *   LOCAL_ONE: Read στον κοντινότερο κόμβο στο τρέχον data center. Fastest Read, possible stale data.
        *   QUORUM: Read από πλειοψηφία replicas.
        *   EACH_QUORUM: Read από πλειοψηφία σε κάθε data center.
        *   LOCAL_QUORUM: Read από πλειοψηφία στο τρέχον data center.
    *   **Trade-off Consistency Levels:** Ορίζεις επίπεδα Consistency για Writes (W) και Reads (R). Αν W+R > N, τότε για κάθε read, τουλάχιστον ένα από τα replicas που διαβάζεις θα έχει την τελευταία τιμή (εξασφαλίζεις κάποιο επίπεδο Consistency, συνήθως C του CAP). (Slide 44).
*   **Anti-entropy Mechanisms (Slides 45-46):**
    *   Όταν το write consistency είναι < ALL, μπορεί να προκύψουν **ασυνέπειες (inconsistencies)** μεταξύ των αντιγράφων. Με τον χρόνο, η `entropy` αυξάνει (η απόκλιση μεταξύ αντιγράφων).
    *   Μηχανισμοί για μείωση της `entropy`:
        *   **Hinted Handoff (Υπονοούμενη Παράδοση):** Αν ο κόμβος στον οποίο έπρεπε να γραφτεί ένα αντίγραφο είναι προσωρινά μη διαθέσιμος, ο coordinator (ή άλλος κόμβος) αποθηκεύει την ενημέρωση προσωρινά (`hints`) και προσπαθεί να τη στείλει αργότερα (μέσα σε λίγες ώρες). Μπορεί να υποκαταστήσει το write σε ANY consistency.
        *   **Read Repair (Επιδιόρθωση κατά την Ανάγνωση):** Όταν ένα read (με R>1) εντοπίζει ασυνέπειες μεταξύ των replicas που ερωτώνται, αποστέλλεται ενημέρωση για τη διόρθωση της ασυνέπειας (write to correct) στους κόμβους με τα παλιά δεδομένα.
*   **Timestamps & Granularity (Slide 46):** Η Cassandra χρησιμοποιεί timestamps (last write wins) για να καθορίσει το τελευταίο αντίγραφο. Η μονάδα τροποποίησης/σύγκρουσης/απόκρισης είναι το **μεμονωμένο cell** (τομή γραμμής και στήλης), κάτι που μειώνει τις χαμένες ενημερώσεις σε σχέση με locking σε όλο το document (όπως στο MongoDB).
*   **Lightweight Transactions (LWT) (Slide 47):**
    *   Η Cassandra έχει **lockless** αρχιτεκτονική - δεν χρησιμοποιεί παραδοσιακά locks για concurrency control όπως τα RDBMS ή το MongoDB.
    *   Επιλύει συγκρούσεις (μέσω Timestamps, LWW, CRDTs, Anti-entropy).
    *   Υποστηρίζει **ελαφριές συναλλαγές (LWT)**, που εφαρμόζουν **μία μόνο operation** και υποστηρίζουν το μοτίβο **compare-and-set (CAS)**.
    *   CAS: Ελέγχει την τιμή ενός κελιού. Αν η τιμή είναι αυτή που περίμενες, τότε θέτει μια νέα τιμή. Παρόμοιο με **optimistic locking**. Δεν είναι πλήρεις ACID συναλλαγές.

**5. Σύνοψη Cassandra (Slide 53)**

*   Open-source υπό Apache license.
*   Data Model: Column Family Store (βασισμένο σε BigTable), αλλά παρέχει ταμπέλα-όμοια (tabular) αφαίρεση μέσω της CQL.
*   Συναλλαγές: Tunable Consistency, διάφοροι μηχανισμοί όπως Paxos (σε υποδομή για leader election κλπ.), και LWT.
*   Clustering/Partioning: Consistent Hashing.
*   APIs: CQL (Cassandra Query Language).

**Σύνδεση με το μάθημα:**

Η Cassandra, ως Column Family Store, είναι εξαιρετική για workloads με **υψηλό read/write throughput** και για **χειρισμό αραιών δεδομένων (sparse data)**. Ο Peer-to-Peer σχεδιασμός, η έμφαση στην A+P του CAP Theorem (Tunable Consistency, Replication Strategies, Gossip, Anti-entropy), και η βελτιστοποίηση για SSD/Flash media την καθιστούν κατάλληλη για εφαρμογές όπου η διαθεσιμότητα και η κλιμακούμενοτητα σε παγκόσμια κλίμακα είναι πιο κρίσιμες από την αυστηρή συνέπεια και τις πολύπλοκες συναλλαγές/joins.

Η κατανόηση των διαφορετικών μοντέλων αποθήκευσης (Row vs Columnar), των τεχνικών βελτιστοποίησης για διαφορετικούς τύπους δίσκων, και των μηχανισμών κατανεμημένης διαχείρισης (Consistent Hashing, Gossip, Tunable Consistency, Replication) είναι θεμελιώδης για την επιλογή και σχεδίαση της σωστής λύσης βάσης δεδομένων σε ένα περιβάλλον Cloud και Big Data.


```
## **15. Συνέπεια (Consistency) (Διαφ. 41-45)**

*   **Tunable Consistency (Ρυθμιζόμενη Συνέπεια):** Όπως στο Dynamo, η Cassandra επιτρέπει στον client να ορίσει το **επίπεδο συνέπειας (consistency level)** για κάθε λειτουργία ανάγνωσης (R) ή εγγραφής (W), επηρεάζοντας τον αριθμό των κόμβων που πρέπει να απαντήσουν.
    *   Ν: Ορίζεται από το Replication Factor του keyspace.
*   **Επίπεδα Συνέπειας Εγγραφής (Write Consistency):**
    *   `ANY`: Αρκεί να γράψει ένας κόμβος (ακόμα και μέσω hinted handoff). Γρηγορότερο, λιγότερο συνεπές.
    *   `ONE`, `TWO`, `THREE`: Απαιτεί επιβεβαίωση από 1, 2, ή 3 κόμβους.
    *   `QUORUM`: Απαιτεί επιβεβαίωση από την πλειοψηφία των replicas (`floor(N/2) + 1`) σε όλα τα DCs.
    *   `LOCAL_QUORUM`: Απαιτεί επιβεβαίωση από την πλειοψηφία στο *τρέχον* data center του coordinator.
    *   `EACH_QUORUM`: Απαιτεί επιβεβαίωση από πλειοψηφία *σε κάθε* data center.
    *   `ALL`: Απαιτεί επιβεβαίωση από *όλους* τους replicas. Ισχυρότερη συνέπεια, αλλά χαμηλότερη διαθεσιμότητα (αποτυγχάνει αν έστω ένας κόμβος είναι κάτω).
*   **Επίπεδα Συνέπειας Ανάγνωσης (Read Consistency):**
    *   `ONE`, `TWO`, `THREE`: Επικοινωνεί με τον/τους πλησιέστερο(ους) κόμβο(υς).
    *   `LOCAL_ONE`: Διαβάζει από τον πλησιέστερο στο τρέχον DC.
    *   `QUORUM`: Διαβάζει από πλειοψηφία replicas σε όλα τα DCs και επιστρέφει την πιο πρόσφατη τιμή.
    *   `LOCAL_QUORUM`: Διαβάζει από πλειοψηφία στο τρέχον DC.
    *   `EACH_QUORUM`: Διαβάζει από πλειοψηφία σε κάθε DC.
    *   `ALL`: Διαβάζει από όλους τους replicas.
*   **Σχέση R + W > N:** Εξασφαλίζει συνήθως strong consistency (με την προϋπόθεση ότι τα partitions δεν αλλάζουν κατά τη διάρκεια).
*   **Πίνακας Συνέπειας (Διαφ. 45):** Δείχνει τους συνδυασμούς και τα χαρακτηριστικά τους.
```
