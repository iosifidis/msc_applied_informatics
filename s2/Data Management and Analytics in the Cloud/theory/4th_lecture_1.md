# **Βάσεις Δεδομένων Κλειδιού-Τιμής (Key-Value Databases)**

## **1. Πώς Λειτουργούν οι Key-Value Βάσεις Δεδομένων (Slides 2-4)**

- **Βασική Ιδέα:** Μια Key-Value βάση αποθηκεύει δεδομένα ως ένα σύνολο από ζεύγη **κλειδιού-τιμής (key-value pairs)**.
  - Κάθε ζεύγος αποτελείται από ένα μοναδικό **κλειδί (key)** και μια **τιμή (value)** που σχετίζεται με αυτό το κλειδί.
  - Το κλειδί χρησιμοποιείται για την αναζήτηση, ανάκτηση και αποθήκευση της τιμής.
- **Αναλογία με δομές Μνήμης:** Η βασική δομή είναι πολύ παρόμοια με δομές δεδομένων που ήδη γνωρίζετε από τον προγραμματισμό, όπως:
  - `Hash tables` ή `hash maps` σε διάφορες γλώσσες (π.χ. C++, Java).
  - `Dictionaries` σε Python.
  - `Objects` σε Javascript.
  - `Associative arrays`.
- **Βασική Διαφορά από τις δομές Μνήμης:** Η κύρια διαφορά είναι ότι σε μια βάση δεδομένων τύπου Key-Value, τα δεδομένα **είναι μόνιμα (persisted)** (δηλαδή, αποθηκεύονται στον δίσκο και δεν χάνονται όταν σβήσει η εφαρμογή) και **διαχειρίζονταιται (managed)** από το λογισμικό της βάσης.
- **Αρχιτεκτονική (τυπική):** Οι KV βάσεις λειτουργούν διατηρώντας μια δομή δεδομένων στην **ενδιάμεση μνήμη (RAM)** (π.χ. hash table ή B-tree στο RAM) η οποία είναι **αντιστοιχισμένη (mapped)** στα δεδομένα που είναι αποθηκευμένα στον **δίσκο**.
- **Απόδοση:** Η RAM είναι πολύ πιο γρήγορη από την πρόσβαση στον δίσκο. Οι περισσότερες βάσεις δεδομένων (συμπεριλαμβανομένων των KV) χρησιμοποιούν αλγορίθμους για να κρατούν **συχνά προσπελαυνόμενα δεδομένα στη RAM**, και να προσπελαύνουν τον δίσκο μόνο αν τα δεδομένα (ή ο δείκτης για αυτά) δεν είναι ήδη στην μνήμη (buffer pool).
- **Ο πιο απλός τύπος NoSQL:** Οι KV βάσεις θεωρούνται ο "απλούστερος" τύπος βάσης NoSQL από άποψη μοντέλου δεδομένων.
- **Ευελιξία:** Είναι χρήσιμες για **scalable data setups** (κατανεμημένες και κλιμακούμενες αρχιτεκτονικές), μπορούν να διαχειριστούν **αλλαγές σχήματος** (schema changes) στην τιμή (value), και να αποθηκεύσουν δεδομένα για πιο **ευέλικτη ανάκτηση** (flexble retrieval) _βάσει του κλειδιού_.
- **Υλοποιήσεις διαφέρουν:** Οι Key-Value βάσεις **μπορούν να διαφέρουν σημαντικά** στην υλοποίηση και τις δυνατότητες ανάλογα με την προβλεπόμενη περίπτωση χρήσης. Διαφορές μπορεί να υπάρχουν στο μοντέλο συνέπειας, αν υποστηρίζουν ταξινομημένα κλειδιά, στους μηχανισμούς αναπαραγωγής και διαμερισμού, και στις στρατηγικές σειριοποίησης της τιμής.

## **2. Βασικά Χαρακτηριστικά μιας Key-Value Βάσης Δεδομένων (Slides 5-10)**

- **Βασικές Λειτουργίες (Slide 5):** Τα πιο βασικά χαρακτηριστικά που απαιτούνται από οποιαδήποτε KV βάση είναι οι λειτουργίες:
  - `CREATE` (δημιουργία ζεύγους κλειδί-τιμή)
  - `UPDATE` (ενημέρωση της τιμής για ένα υπάρχον κλειδί)
  - `RETRIEVE` (ανάκτηση της τιμής βάσει του κλειδιού)
  - `DELETE` (διαγραφή ενός ζεύγους κλειδί-τιμή βάσει του κλειδιού)
  - Όλες οι λειτουργίες γίνονται **χρησιμοποιώντας το κλειδί**.
- **Υποστήριξη Τύπου Δεδομένων (Value) (Slide 6):**
  - Η _τιμή (value)_ σε ένα ζεύγος κλειδί-τιμή μπορεί να είναι οτιδήποτε - από μια απλή στοιχειοσειρά (string) ή αριθμό, μέχρι πιο σύνθετες δομές.
  - Κάποιες KV βάσεις υποστηρίζουν **καθορισμένους τύπους δεδομένων** ή **ημιδομημένα δεδομένα** (semi-structured), όπως πίνακες (arrays) ή εμφωλευμένα λεξικά (nested dictionaries / JSON-like structures).
  - Παρέχοντας στη βάση πληροφορίες για τον τύπο/δομή της τιμής, υπάρχει χώρος για περισσότερες **βελτιστοποιήσεις** (optimization) στην αποθήκευση (π.χ. συμπίεση) και την εκτέλεση ερωτημάτων (αν και οι δυνατότητες ερωτημάτων είναι περιορισμένες σε σύγκριση με RDBMS).
- **Ταξινομημένα Κλειδιά (Sorted Keys) (Slide 7):**
  - Ορισμένες KV βάσεις (όχι όλες!) διατηρούν τα κλειδιά **ταξινομημένα** (π.χ. αλφαβητικά ή αριθμητικά).
  - Αυτό επιτρέπει την αποτελεσματική **επανάληψη/προσπέλαση** (iteration) πάνω σε ένα εύρος κλειδιών.
  - Συχνές περιπτώσεις χρήσης: ανάκτηση όλων των κλειδιών που ξεκινούν με συγκεκριμένα γράμματα (π.χ. prefix search), ανάκτηση όλων των κλειδιών σε ένα εύρος αριθμών ή σε ένα χρονικό εύρος (αν το κλειδί είναι timestamp).
- **Υποστήριξη Δευτερευόντων Κλειδιών/Ευρετηρίων (Secondary Key/Index Support) (Slide 8):**
  - Κάποιες KV βάσεις επιτρέπουν τον ορισμό **πολλαπλών, διαφορετικών κλειδιών** για την προσπέλαση **της ίδιας** πληροφορίας. Αυτά είναι τα λεγόμενα δευτερεύοντα ευρετήρια (secondary indexes).
  - Παράδειγμα: να μπορείς να βρεις πληροφορίες πελάτη όχι μόνο με το ID (primary key) αλλά και με το όνομα, email ή τηλέφωνο (δευτερεύοντα κλειδιά).
  - Δεν χρειάζεται πλέον να "αναγκαστείς" να επιλέξεις ένα μοναδικό κλειδί για όλες τις αναζητήσεις. (Πλησιάζει τη λειτουργικότητα των RDBMS indexes).
- **Replication και Partitioning (Slide 9):**
  - Οι περισσότερες Key-Value βάσεις είναι σχεδιασμένες ως **κατανεμημένα συστήματα**.
  - Παρέχουν ενσωματωμένη υποστήριξη για **αναπαραγωγή (replication)** (πολλαπλά αντίγραφα των δεδομένων σε διαφορετικούς κόμβους), κάτι που βοηθά στην **κλιμακούμενοτητα (scalability)** και την **αποκατάσταση από καταστροφές (disaster recovery)**.
  - Παρέχουν επίσης υποστήριξη για **διαμερισμό (partitioning / sharding)**, διαμοιράζοντας τα δεδομένα σε πολλαπλούς κόμβους. Μπορεί να υπάρχει προεπιλεγμένος τρόπος διαμερισμού (π.χ. hash-based) ή η επιλογή για ορισμό του τρόπου διαμερισμού.
  - Πιο εξελιγμένες KV βάσεις έχουν αυτόματη υποστήριξη για διανομή των δεδομένων σε **πολλαπλά data centers**, οδηγώντας σε βελτιωμένη αξιοπιστία (reliability) και απόδοση (λόγω της χρήσης δεδομένων κοντά στους χρήστες - data locality).
- **Υποστήριξη ACID (Slide 10):**
  - Πολλά από τα κέρδη στην απόδοση και επεκτασιμότητα των NoSQL, και των KV ειδικότερα, προέρχονται από την **απόρριψη της υποστήριξης για ACID συναλλαγές** (που είναι ακριβές σε κατανεμημένα περιβάλλοντα).
  - Ωστόσο, **πολλές** KV βάσεις προσφέρουν πλέον την **επιλογή** χρήσης ACID συναλλαγών **όταν απαιτείται**, αν και αυτό συνήθως γίνεται **με κόστος στην απόδοση**.
  - Η ύπαρξη της επιλογής είναι πλεονέκτημα για τους προγραμματιστές: μπορούν να χρησιμοποιήσουν ACID μόνο όπου είναι κρίσιμο (π.χ. χρηματικές συναλλαγές) και να βασιστούν σε πιο γρήγορες, μη-ACID λειτουργίες αλλού.

## **3. Πλεονεκτήματα των Key-Value Βάσεων Δεδομένων (Slides 11-13)**

- **Επεκτασιμότητα (Scalability) (Slide 11):**
  - Είναι το πρωταρχικό "πουλέν" (selling point) των KV (και των NoSQL γενικά) σε σχέση με τα RDBMS.
  - Η δυνατότητα να κλιμακωθούν **οριζόντια (scale out)** προσθέτοντας απλώς περισσότερους servers, είναι αυτό που τις έκανε δημοφιλείς σε εταιρείες όπως η Amazon και η Google, οι οποίες χρειάζονταν να διαχειριστούν τεράστιο όγκο δεδομένων και αιτημάτων.
  - Είναι ελκυστικές για τους προγραμματιστές επειδή οι τεχνικές κλιμάκωσης (replication, sharding) είναι ενσωματωμένες και "δουλεύουν από μόνες τους" σε μεγάλο βαθμό.
- **Παραγωγικότητα Προγραμματιστή (Developer Productivity) (Slide 12):**
  - Οι προγραμματιστές αφιερώνουν λιγότερο χρόνο προσπαθώντας να κλιμακώσουν τη βάση, εστιάζοντας στην ίδια την εφαρμογή.
  - Η φύση **χωρίς σχήμα (schema-less)** ή με ευέλικτο σχήμα σημαίνει ότι οι αλλαγές στη δομή των δεδομένων **δεν απαιτούν πολύπλοκες διαδικασίες μετανάστευσης (migrations)** και πιθανό downtime, κάτι που είναι συνηθισμένο σε RDBMS.
  - Μπορεί να μειώσει το **πρόβλημα αναντιστοιχίας σύνθεσης (impedance mismatch)** μεταξύ του μοντέλου δεδομένων στον κώδικα της εφαρμογής (π.χ. objects, JSON) και του σχεσιακού μοντέλου (πίνακες, γραμμές). Η απευθείας αποθήκευση ενός JSON object ως τιμή σε ένα κλειδί είναι πιο άμεση από το να το "σπάσεις" σε πολλαπλούς σχεσιακούς πίνακες.
- **Απόδοση (Performance) (Slide 13):**
  - Ακόμη και αν αγνοήσουμε τις δυνατότητες κλιμάκωσης, για ορισμένες περιπτώσεις χρήσης (π.χ. απλές αναγνώσεις/εγγραφές βάσει κλειδιού), μια KV βάση σε έναν μόνο κόμβο μπορεί να έχει **καλύτερη απόδοση** σε ανάγνωση και εγγραφή δεδομένων σε σχέση με ένα πιο γενικού σκοπού σχεσιακό DBMS.
  - Αυτό συμβαίνει επειδή η KV βάση είναι βελτιστοποιημένη για αυτή την πολύ συγκεκριμένη λειτουργία προσπέλασης (lookup by key).

## **4. Μειονεκτήματα των Key-Value Βάσεων Δεδομένων (Slides 14-17)**

- **Έλλειψη Υποστήριξης ACID (Slide 14):**
  - Για να επιτευχθεί η κλιμακούμενοτητα, πολλές KV βάσεις **δεν παρέχουν** ενσωματωμένη υποστήριξη για ACID συναλλαγές.
  - Στις αρχές της υιοθέτησης των NoSQL, πολλοί προγραμματιστές προσπαθούσαν να "αντιγράψουν" τη λογική των συναλλαγών στον κώδικα της εφαρμογής, κάτι που συχνά οδηγούσε σε πολλά προβλήματα συνέπειας και πολυπλοκότητας.
- **"Ακατάστατο" Σχήμα ("Messy" Schema) (Slide 15):**
  - Ενώ το να μην έχεις σταθερό σχήμα μπορεί να αυξήσει την παραγωγικότητα βραχυπρόθεσμα, αν μια ομάδα δεν είναι **πειθαρχημένη** στην τεκμηρίωση και τον σχεδιασμό, το μοντέλο δεδομένων **μπορεί να γίνει χαοτικό**.
  - Η δυνατότητα αλλαγής του "σχήματος" on the fly μπορεί να καλύψει φτωχό αρχικό σχεδιασμό και να οδηγήσει σε μακροπρόθεσμα προβλήματα συντήρησης.
  - Αντίθετα, το να "αναγκάζεσαι" να σχεδιάσεις προσεκτικά το μοντέλο δεδομένων σε ένα RDBMS (καθορισμένο σχήμα) μπορεί να θεωρηθεί ως ένα **πλεονέκτημα** πειθαρχίας και μακροπρόθεσμης δομικής ακεραιότητας.
- **Δεν Υποστηρίζονται Προηγμένα Ερωτήματα (Advanced Query Support not available) (Slide 16):**
  - Μια standard KV βάση **δεν παρέχει δυνατότητες αναζήτησης/επεξεργασίας εντός της τιμής (value)** ή σύνθετων aggregations (π.χ. SUM, AVG σε πολλές τιμές). Δεν μπορεί να δώσει "insight" στο περιεχόμενο της τιμής χωρίς να την ανακτήσει ολόκληρη.
  - Πρέπει να ανακτήσεις την τιμή (ή πολλές τιμές) βάσει κλειδιού(ων) και μετά να κάνεις **φιλτράρισμα ή επεξεργασία στον κώδικα της εφαρμογής**. Αυτό είναι **λιγότερο αποδοτικό** από το να γινόταν στη βάση (όπως στα RDBMS με SQL).
  - Η έλλειψη μιας γλώσσας ερωτημάτων όπως η SQL σημαίνει ότι λογική που θα υλοποιούταν στη βάση, πηγαίνει στον κώδικα της εφαρμογής, αυξάνοντας την **πολυπλοκότητα της εφαρμογής** και δυσκολεύοντας τη συντήρηση.
  - Η ενημέρωση μέρους μιας σύνθετης (εμφωλευμένης) τιμής μπορεί να είναι **αναποτελεσματική**, καθώς συχνά πρέπει να **αντικατασταθεί ολόκληρη η τιμή**.
- **Πιθανώς Λιγότερο Αποτελεσματική Αποθήκευση και Βελτιστοποίηση Ερωτημάτων (Slide 17):**
  - Με καθορισμένους τύπους σχήματος, ένα RDBMS μπορεί να βελτιστοποιήσει την αποθήκευση χρησιμοποιώντας **συμπίεση** (ειδικά σε column-oriented δομές).
  - Επίσης, τα RDBMS είναι βελτιστοποιημένα για **κοινά ερωτήματα**, όπως η εύρεση aggregates σε τιμές στηλών, κάτι που δεν είναι εγγενές χαρακτηριστικό των KV.

## **5. Περιπτώσεις Χρήσης Key-Value Βάσεων Δεδομένων (Slides 18-20)**

- **Εφαρμογές ευαίσθητες στην Απόδοση (Performance-sensitive applications) (Slide 18):**
  - Χρήση ενός KV (π.χ. Redis, Dynamo) για **βελτίωση της απόδοσης αναγνώσεων**.
  - Συχνά χρησιμοποιούνται ως **cache** μπροστά από μια άλλη (ίσως σχεσιακή) βάση. Η σχεσιακή βάση είναι η "πηγή αλήθειας" για τις εγγραφές, και τα δεδομένα ωθούνται ή προ-υπολογίζονται σε διανεμημένους KV κόμβους (πιο κοντά στους χρήστες) για ταχεία ανάκτηση (μείωση latency).
  - Παράδειγμα: News feeds στο Twitter - προ-υπολογισμός και αποθήκευση σε cache KV για γρήγορο φόρτωμα της αρχικής σελίδας.
- **Storage Engine για Βάσεις Υψηλότερου Επιπέδου (Slide 19):**
  - Πολλές βάσεις δεδομένων χρησιμοποιούν KV βάσεις ως το **υποκείμενο στρώμα αποθήκευσης (under the hood)** λόγω της ωμής τους απόδοσης (raw performance) στις βασικές λειτουργίες read/write by key.
  - Αυτό γλιτώνει χρόνο ανάπτυξης ("not reinventing the wheel").
  - Παράδειγμα: RocksDB (ενσωματωμένη KV βάση από τη Facebook) χρησιμοποιείται ή υποστηρίζεται από MySQL (ως storage engine), Cassandra (ως commit log), MariaDB, MongoDB (ως WiredTiger engine), YugabyteDB, και InfluxDB.
- **Internet of Things (IoT) (Slide 20):**
  - Στο IoT, έχουμε μεγάλο όγκο συσκευών που παράγουν δεδομένα.
  - Συχνά θέλουμε να κάνουμε την επεξεργασία **πιο κοντά στην "άκρη" (edge)**, δηλαδή στην περιοχή όπου οι συσκευές συλλέγουν πληροφορίες, για να μειώσουμε την καθυστέρηση (latency) και τον όγκο δεδομένων που μεταφέρονται.
  - Μια NoSQL KV βάση μπορεί να χρησιμοποιηθεί στο "edge" για αποθήκευση των δεδομένων των συσκευών και βασική επεξεργασία κοντά στην πηγή τους.

## **6. Παραδείγματα Key-Value Βάσεων Δεδομένων (Slides 21-23)**

- **Berkeley DB (Slide 21):**
  - Μία από τις πρώτες υλοποιήσεις Key-Value.
  - Ήταν μια **ενσωματωμένη (embedded)** KV βάση, σχεδιασμένη να λειτουργεί _μέσα_ στην εφαρμογή, όχι ως ξεχωριστός server με δικτυακή πρόσβαση.
  - Πολλές από τις αρχιτεκτονικές της αποφάσεις, εστιασμένες στην απλότητα και την απόδοση, μπορούν να θεωρηθούν πρόδρομοι των ιδεών του NoSQL.
  - Επηρέασε τη δημιουργία άλλων ενσωματωμένων KV βάσεων όπως RocksDB (Facebook) και LevelDB (Google).
- **Dynamo (Amazon) (Slide 22):**
  - Πολύ **επιδραστική (influential)** KV βάση που δημιουργήθηκε από την Amazon το 2007 για να κλιμακώσει την πλατφόρμα Amazon Marketplace.
  - Αν και πολλές από τις έννοιες που χρησιμοποίησε (κατανεμημένο hashing, tunable consistency) υπήρχαν, η Amazon τις έφερε στην **κύρια ροή (mainstream)** και απέδειξε την εμπορική τους αξία σε Web-scale συστήματα τύπου NoSQL. (Συνδέεται άμεσα με το CAP Theorem και τις BASE ιδιότητες που είδαμε).
- **Redis (Slide 23):**
  - Μια **πλήρως in-memory** KV βάση.
  - Βελτιώνει δραστικά την απόδοση αναγνώσεων και εγγραφών επειδή η RAM είναι τάξεις μεγέθους ταχύτερη από τον δίσκο.
  - Μειονέκτημα: η διατήρηση δεδομένων στη RAM είναι σημαντικά πιο **ακριβή** από την αποθήκευση σε σκληρό δίσκο.
  - Χρησιμοποιείται **τυπικά ως cache layer** μπροστά από άλλες βάσεις δεδομένων για την εξυπηρέτηση ταχέων αιτημάτων ανάγνωσης.

## **7. Λίγη Ιστορία: Τα μέσα της Δεκαετίας 2000 (Slides 24-25)**

- Τα μέσα της δεκαετίας του 2000 χαρακτηρίστηκαν από την ανάδυση γιγάντων του Web (Google, Facebook, MySpace).
- Αυτοί αντιμετώπισαν τεράστιες προκλήσεις στην **κλιμάκωση των υποδομών** τους για να υποστηρίξουν εκατομμύρια/δισεκατομμύρια χρήστες.
- **Google:** Πρωτοπόρος με νέες τεχνολογίες:
  - GFS (αρχιτεκτονική αποθήκευσης) - 2003
  - MapReduce (αλγόριθμος κατανεμημένης παράλληλης επεξεργασίας) - 2004
  - BigTable (κατανεμημένη, δομημένη βάση δεδομένων - column-family) - 2006
- **Hadoop (Yahoo!):** Ανοιχτού κώδικα υλοποίηση της Google stack (HDFS, MapReduce/YARN).
- **Άλλες Εταιρείες / Λύσεις:**
  - Oracle RAC: Μια ακριβή (proprietary) λύση RDBMS για υψηλή κλιμακούμενοτητα.
  - Memcached: Κατανεμημένη cache αντικειμένων.
  - MySQL + Sharding: Χρησιμοποιήθηκε επιτυχώς από εταιρείες όπως το Twitter και η Facebook (DIY sharding στην εφαρμογή ή με εξωτερικά εργαλεία).
  - **Amazon Dynamo (2008):** Μια database webscale, η **πρώτη Key-Value βάση δεδομένων** που απέδειξε τη βιωσιμότητα και αποτελεσματικότητα αυτού του μοντέλου σε πραγματικά συστήματα μεγάλης κλίμακας, επηρεάζοντας όλο τον χώρο του NoSQL.

## **8. Επίλυση Συγκρούσεων (Conflict Resolution) και Έκδοση Δεδομένων (Data Versioning) (Slides 36-41)**

Στα ασύγχρονα κατανεμημένα συστήματα (AP / BASE), όπου τα αντίγραφα δεν είναι πάντα συγχρονισμένα, είναι δυνατόν δύο διαφορετικές ενημερώσεις στην ίδια τιμή (value) να συμβούν παράλληλα σε διαφορετικούς κόμβους, οδηγώντας σε **σύγκρουση (conflict)**. Χρειάζονται μηχανισμοί επίλυσης.

- **Last Write Wins (LWW - Η τελευταία εγγραφή κερδίζει) (Slide 36):**
  - Συνηθισμένη απλή στρατηγική. Για να καθοριστεί ποιο αντίγραφο είναι το πιο "επίκαιρο", συγκρίνονται τα **timestamps** των συγκρουόμενων εγγραφών και επιλέγεται αυτό με το **μεγαλύτερο timestamp**.
  - **Προβλήματα:** Όταν εφαρμόζεται σε μεγάλα, σύνθετα αντικείμενα, μπορεί να οδηγήσει σε **χαμένες ενημερώσεις (lost updates)**. Αν δύο χρήστες τροποποιήσουν διαφορετικά μέρη ενός μεγάλου JSON document στην ίδια τιμή ταυτόχρονα σε διαφορετικούς κόμβους, η στρατηγική LWW θα κρατήσει ολόκληρο το document από τον "τελευταίο" (βάσει timestamp) γράφοντα, χάνοντας τις αλλαγές του άλλου.
  - **Λύση (για lost updates):** Αντί να κλειδώνεις/τροποποιείς ολόκληρη τη γραμμή/έγγραφο, να κάνεις την μονάδα τροποποίησης (unit of modification) και επίλυσης συγκρούσεων πιο μικρή, π.χ., στο επίπεδο **μεμονωμένου κελιού (individual cell)** - κάτι που είναι σύνηθες σε column-family βάσεις όπως η Cassandra. Σε KV και Document, συχνά απαιτείται κλείδωμα/αντικατάσταση ολόκληρης της τιμής/εγγράφου.
- **Vector Clocks (Ρολόγια Διανύσματος) (Slides 37-39):**
  - Μια πιο σύνθετη προσέγγιση για την επίλυση συγκρούσεων.
  - **Δεν απαιτούν συγχρονισμό ωρολογίων** μεταξύ των κόμβων.
  - Βοηθούν στην **ταυτοποίηση συναλλαγών που μπορεί να βρίσκονται σε σύγκρουση**.
  - Ένα Vector Clock είναι ένα **σύνολο (ή διάνυσμα) μετρητών (counters)**, έναν για κάθε κόμβο (διεργασία) του κατανεμημένου συστήματος. Κάθε κόμβος διατηρεί το δικό του vector clock.
  - Οι μετρητές ενημερώνονται σε εσωτερικά γεγονότα, αποστολή μηνυμάτων, και λήψη μηνυμάτων (καθώς και με λήψη του μέγιστου της τιμής του κόμβου και της αντίστοιχης τιμής στο vector clock του αποστολέα).
  - Συγκρίνοντας τα vector clocks δύο εκδόσεων μιας τιμής, μπορεί να καθοριστεί η **σχέση τους (ordering of events)**:
    - **Happened-Before (Συνέβη-πριν):** Αν V(a) < V(b) (δηλαδή κάθε μετρητής στο vector clock της έκδοσης 'a' είναι μικρότερος ή ίσος από τον αντίστοιχο μετρητή στην έκδοση 'b', και υπάρχει τουλάχιστον ένας μετρητής αυστηρά μικρότερος), τότε η έκδοση 'a' συνέβη πριν την έκδοση 'b'. Δεν υπάρχει σύγκρουση - η 'b' είναι η νεότερη.
    - **Concurrent Events (Ταυτόχρονα Γεγονότα):** Αν ούτε V(a) < V(b) ούτε V(b) < V(a), τότε οι εκδόσεις 'a' και 'b' είναι **ταυτόχρονες** και βρίσκονται **σε σύγκρουση**. Αυτή η σύγκρουση πρέπει να επιλυθεί.
- **Πώς Επιλύουμε Συγκρούσεις (με Vector Clocks ή αλλιώς) (Slide 40):**
  - **Revert to Last Write Wins:** Χάνουμε την παράλληλη ενημέρωση.
  - **Keep both copies:** Κρατάμε _και τα δύο_ συγκρουόμενα αντίγραφα και αφήνουμε την **εφαρμογή ή τον χρήστη** να επιλύσει τη σύγκρουση (π.χ. χειροκίνητα merge ή με συγκεκριμένη λογική στην εφαρμογή).
  - **Merge the data:** Το σύστημα επιχειρεί να συγχωνεύσει αυτόματα τα συγκρουόμενα δεδομένα με έξυπνο τρόπο. Αυτό κάνει το **Dynamo** (π.χ. συγχώνευση λιστών).
  - **Conflict-Free Replicated Data Type (CRDT - Τύπος Δεδομένων χωρίς Συγκρούσεις) (Slides 40-41):** Ειδικοί τύποι δεδομένων που είναι **μαθηματικά σχεδιασμένοι** έτσι ώστε οι ταυτόχρονες ενημερώσεις να μπορούν να εφαρμοστούν με _οποιαδήποτε σειρά_ σε οποιοδήποτε αντίγραφο, και τελικά όλα τα αντίγραφα να συγκλίνουν (converge) στην **ίδια τελική κατάσταση** χωρίς να απαιτείται ειδική λογική επίλυσης συγκρούσεων (πέρα από την εφαρμογή όλων των operation). Ένα παράδειγμα είναι το `g-counter` (grow-only counter) που μόνο αυξάνει. Χρησιμοποιούνται σε συστήματα όπως το Riak.

## **9. Δευτερεύοντα Ευρετήρια (Secondary Indexing) σε Key-Value Βάσεις (Slides 42-44)**

Όπως αναφέρθηκε νωρίτερα, η αναζήτηση σε μια KV βάση γίνεται πρωτίστως μέσω του **κύριου κλειδιού (primary key)**. Η δυνατότητα αναζήτησης βάσει **άλλων πεδίων** απαιτεί **δευτερεύοντα ευρετήρια (secondary indexes)**. Στα KV, αυτά δεν είναι πάντα τόσο απλά όσο στα RDBMS.

- **DIY Secondary Indexing (Φτιάξτο-μόνος-σου Ευρετηρίαση) (Slide 42):** Σε απλές KV βάσεις που δεν υποστηρίζουν ενσωματωμένα δευτερεύοντα ευρετήρια, ο προγραμματιστής πρέπει να τα υλοποιήσει ο ίδιος:
  - Δημιουργείς ένα **νέο ζεύγος κλειδί-τιμή** για κάθε ευρετήριο. Το κλειδί του νέου ζεύγους είναι η τιμή της στήλης στην οποία θες ευρετήριο (π.χ. email), και η τιμή του είναι το **κύριο κλειδί (primary key/BaseTableKey)** της αρχικής εγγραφής.
  - Για να βρεις μια εγγραφή βάσει email:
    1.  Κάνεις `GET` στο ευρετήριο (email -> primary key).
    2.  Παίρνεις το primary key.
    3.  Κάνεις `GET` στην κύρια βάση με το primary key για να πάρεις την πλήρη εγγραφή.
- **Global Indexes (Καθολικά Ευρετήρια) (Slide 43):**
  - Αν οι **εγγραφές του ευρετηρίου** (π.χ. ζεύγη <email, primary_key>) διαμεριστούν και διανεμηθούν στους κόμβους χρησιμοποιώντας κανονικούς μηχανισμούς (π.χ. hash based στο email), η εγγραφή ευρετηρίου για μια γραμμή βασικού πίνακα πιθανότατα θα βρίσκεται σε **διαφορετικό κόμβο** από την ίδια την γραμμή του βασικού πίνακα.
  - Αυτό σημαίνει ότι μια αναζήτηση μέσω δευτερεύοντος ευρετηρίου συνήθως απαιτεί **δύο προσπελάσεις σε κόμβους (two node lookups)** και άρα δύο I/O operations (π.χ. 1 στο κόμβο του ευρετηρίου για να πάρεις το primary key, και 1 στο κόμβο του βασικού πίνακα για να πάρεις την εγγραφή).
  - Αν οι τιμές στο ευρετήριο είναι **μη-μοναδικές** ή υπάρχει μεγάλη **ανισοκατανομή (skew)**, τα entries του ευρετηρίου (και ο φόρτος αναζήτησης) μπορεί να είναι άνισα κατανεμημένα στους κόμβους.
- **Local Indexes (Τοπικά Ευρετήρια) (Slide 44):**
  - Κάθε κόμβος διατηρεί το **δικό του ευρετήριο**, το οποίο αναφέρεται μόνο στα δεδομένα που βρίσκονται **σε αυτόν τον τοπικό κόμβο**.
  - Ερωτήματα που βασίζονται στο ευρετήριο **αποστέλλονται σε όλους τους κόμβους (broadcast)**. Κάθε κόμβος χρησιμοποιεί το τοπικό του ευρετήριο για να βρει τυχόν ταιριασμοί στα _δικά του_ δεδομένα.
  - Οι κόμβοι επιστρέφουν τυχόν ταιριαστά δεδομένα σε ένα **συντονιστή ερωτημάτων (query coordinator)**, ο οποίος συγκεντρώνει (combines) τα αποτελέσματα από όλους τους κόμβους.
  - Αυτή η προσέγγιση είναι καλή για την τοπική αναζήτηση, αλλά η ανάγκη για broadcast του ερωτήματος σε _όλους_ τους κόμβους μπορεί να είναι αναποτελεσματική σε πολύ μεγάλα clusters, εκτός αν η συνάρτηση διαμερισμού του ευρετηρίου "ταιριάζει" με την συνάρτηση διαμερισμού του βασικού πίνακα.

## **Σημαντική Σύνδεση:**

Η ενότητα για τους Key-Value databases συμπληρώνει την εικόνα των NoSQL, δείχνοντας πώς το απλό μοντέλο "Κλειδί-Τιμή" αποτελεί τη βάση για την ανάπτυξη πιο σύνθετων συστημάτων και πώς οι επιλογές σχεδίασης (Tunable Consistency, Data Versioning, Replication/Partitioning) αντικατοπτρίζουν τους συμβιβασμούς του CAP Theorem στην πράξη. Η κατανόηση των προκλήσεων με τα δευτερεύοντα ευρετήρια σε κατανεμημένα KV συστήματα εξηγεί επίσης ένα βασικό σημείο διαφοροποίησης σε σχέση με τα RDBMS.
