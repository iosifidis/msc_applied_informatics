# **Βάσεις Δεδομένων Κλειδιού-Τιμής (Key-Value Databases)**

**1. Εισαγωγή & Τρόπος Λειτουργίας**

*   **Βασική Ιδέα:** Αποθηκεύουν δεδομένα ως συλλογή από ζεύγη **κλειδί-τιμή (key-value pairs)**.
*   **Αντιστοιχία:** Παρόμοιο με δομές δεδομένων όπως **hash tables**, dictionaries (Python), ή objects (JavaScript) σε γλώσσες προγραμματισμού.
*   **Κύρια Διαφορά:** Σε μια βάση δεδομένων κλειδιού-τιμής, τα δεδομένα είναι **μόνιμα (persisted)** και η διαχείρισή τους γίνεται από το σύστημα της βάσης δεδομένων, όχι μόνο στη μνήμη της εφαρμογής.
*   **Μοντέλο Αποθήκευσης:** Συνήθως διατηρούν μια δομή δεδομένων (π.χ., hash table, B-tree) στη μνήμη (RAM) που αντιστοιχίζει τα κλειδιά στις θέσεις των τιμών στον δίσκο (ή στη μνήμη, για in-memory KV stores).
*   **Βελτιστοποίηση Απόδοσης:** Καθώς η RAM είναι πολύ ταχύτερη από τον δίσκο, οι περισσότερες βάσεις χρησιμοποιούν αλγόριθμους για να **διατηρούν τα δεδομένα που προσπελαύνονται συχνά στη RAM (caching)**. Η προσπέλαση του δίσκου γίνεται μόνο αν τα απαραίτητα δεδομένα (ή το index) δεν βρίσκονται ήδη στη μνήμη.
*   **Απλότητα:** Θεωρούνται ο **απλούστερος** τύπος βάσης δεδομένων NoSQL.
*   **Καταλληλότητα:**
    *   Χρήσιμες για **κλιμακούμενα (scalable)** συστήματα δεδομένων.
    *   Ευέλικτες σε **αλλαγές σχήματος (schema changes)**.
    *   Παρέχουν **ευέλικτη ανάκτηση** δεδομένων (μέσω του κλειδιού).

**2. Παράγοντες Διαφοροποίησης**

*   Οι υλοποιήσεις Key-Value (KV) βάσεων μπορεί να διαφέρουν σημαντικά ανάλογα με την προβλεπόμενη χρήση. Οι διαφορές περιλαμβάνουν:
    *   **Μοντέλο Συνέπειας (Consistency Model):** Πώς και πότε οι αλλαγές γίνονται ορατές σε όλο το σύστημα (π.χ., Strong Consistency, Eventual Consistency).
    *   **Ταξινόμηση Κλειδιών (Sorted Keys):** Αν τα κλειδιά διατηρούνται σε ταξινομημένη σειρά, επιτρέποντας range queries.
    *   **Αναπαραγωγή (Replication):** Πώς αντιγράφονται τα δεδομένα σε πολλαπλούς κόμβους.
    *   **Διαμοιρασμός (Sharding/Partitioning):** Πώς κατανέμονται τα δεδομένα σε πολλαπλούς κόμβους.
    *   **Στρατηγικές Σειριοποίησης (Serialization Strategies):** Πώς μετατρέπονται οι δομές δεδομένων για αποθήκευση/μετάδοση.

**3. Χαρακτηριστικά Key-Value Βάσεων**

*   **Βασικές Λειτουργίες (CRUD):**
    *   Η θεμελιώδης απαίτηση είναι η δυνατότητα **δημιουργίας (Create), ενημέρωσης (Update), ανάκτησης (Retrieve), και διαγραφής (Delete)** δεδομένων χρησιμοποιώντας το **μοναδικό κλειδί**.
*   **Προηγμένα Χαρακτηριστικά:**
    *   **Υποστήριξη Τύπων Δεδομένων (Data Type Support):**
        *   Πέρα από απλές τιμές (π.χ., strings, numbers), πολλές KV βάσεις υποστηρίζουν πιο σύνθετους τύπους ή ημι-δομημένα δεδομένα, όπως **πίνακες (arrays), λίστες, sets, ή ένθετες δομές (nested dictionaries/objects)**.
        *   Η παροχή πληροφορίας για τον τύπο δεδομένων επιτρέπει στη βάση να κάνει βελτιστοποιήσεις στην αποθήκευση και την απόδοση των ερωτημάτων.
    *   **Ταξινομημένα Κλειδιά (Sorted Keys):**
        *   Ορισμένες βάσεις διατηρούν τα κλειδιά ταξινομημένα.
        *   Αυτό επιτρέπει **αποτελεσματική επανάληψη (iteration)** πάνω στα κλειδιά και **ερωτήματα εύρους (range queries)**:
            *   Ανάκτηση κλειδιών που ξεκινούν με συγκεκριμένο πρόθεμα.
            *   Ανάκτηση κλειδιών εντός αριθμητικού εύρους.
            *   Ανάκτηση κλειδιών < ή > από μια τιμή.
            *   Ανάκτηση κλειδιών εντός χρονικού διαστήματος (αν το κλειδί είναι timestamp).
    *   **Υποστήριξη Δευτερευόντων Κλειδιών/Ευρετηρίων (Secondary Key/Index Support):**
        *   Επιτρέπει τον ορισμό **πολλαπλών τρόπων (κλειδιών/ευρετηρίων)** για την πρόσβαση στην ίδια πληροφορία (τιμή).
        *   Π.χ., Εύρεση πληροφοριών πελάτη βάσει ονόματος, email, ή τηλεφώνου, όχι μόνο βάσει ενός πρωτεύοντος ID.
    *   **Αναπαραγωγή & Διαμερισμός (Replication and Partitioning):**
        *   **Replication:** Διατήρηση αντιγράφων των δεδομένων σε πολλούς κόμβους για **κλιμάκωση (scalability)** των αναγνώσεων και **ανάκαμψη από καταστροφές (disaster recovery)**.
        *   **Partitioning (Sharding):** Κατανομή των δεδομένων σε πολλαπλούς κόμβους για διαχείριση μεγάλου όγκου δεδομένων και φορτίου. Πολλές βάσεις προσφέρουν προεπιλεγμένους τρόπους διαμερισμού αλλά και δυνατότητα παραμετροποίησης.
        *   Προηγμένες βάσεις υποστηρίζουν αυτόματη κατανομή σε πολλαπλά data centers για βελτιωμένη **αξιοπιστία (reliability)** και **απόδοση (performance)** (π.χ., εξυπηρέτηση χρηστών από κοντινά data centers).
    *   **Υποστήριξη ACID (ACID Support):**
        *   Πολλά κέρδη απόδοσης των NoSQL βάσεων (συμπεριλαμβανομένων των KV) προέρχονται από την **παράλειψη αυστηρής υποστήριξης ACID** (Atomicity, Consistency, Isolation, Durability) συναλλαγών.
        *   Ωστόσο, **πολλές σύγχρονες KV βάσεις προσφέρουν την *επιλογή* χρήσης ACID συναλλαγών** όταν αυτό είναι απαραίτητο, με κάποιο πιθανό κόστος στην απόδοση.
        *   Αυτή η ευελιξία είναι χρήσιμη για τους developers, που μπορούν να επιλέξουν το κατάλληλο μοντέλο (υψηλή απόδοση ή ACID) ανά περίπτωση.

**4. Πλεονεκτήματα Key-Value Βάσεων**

*   **Κλιμάκωση (Scalability):**
    *   Το κύριο πλεονέκτημα έναντι των σχεσιακών βάσεων. Έγιναν δημοφιλείς από μεγάλες εταιρείες (Amazon, Google) που αντιμετώπιζαν τεράστια προβλήματα κλιμάκωσης.
    *   Εγγενής υποστήριξη για replication και sharding.
*   **Παραγωγικότητα Προγραμματιστών (Developer Productivity):**
    *   Λιγότερος χρόνος αφιερώνεται στην προσπάθεια κλιμάκωσης της βάσης.
    *   **Schema-less φύση:** Ευκολότερες αλλαγές στη δομή των δεδομένων χωρίς την ανάγκη για πολύπλοκα migrations και πιθανό downtime, όπως στις RDBMS.
    *   **Μείωση "Impedance Mismatch":** Το μοντέλο key-value είναι συχνά πιο κοντά στον τρόπο που τα δεδομένα αναπαρίστανται και χειρίζονται στον κώδικα της εφαρμογής (π.χ., objects, dictionaries) σε σχέση με το αυστηρό μοντέλο των RDBMS.
*   **Απόδοση (Performance):**
    *   Ακόμα και σε έναν κόμβο (single node), μια KV βάση μπορεί να προσφέρει καλύτερη απόδοση ανάγνωσης/εγγραφής για συγκεκριμένες περιπτώσεις χρήσης σε σχέση με μια γενικού σκοπού RDBMS, λόγω της απλούστερης δομής και των μηχανισμών πρόσβασης.

**5. Μειονεκτήματα Key-Value Βάσεων**

*   **Έλλειψη (Συνήθως) Πλήρους Υποστήριξης ACID:**
    *   Πολλές KV βάσεις θυσιάζουν το ACID για χάρη της κλιμάκωσης και της απόδοσης.
    *   Ιστορικά, η προσπάθεια εξομοίωσης συναλλαγών στον κώδικα της εφαρμογής οδηγούσε σε προβλήματα. (Αν και πλέον πολλές προσφέρουν προαιρετικά ACID).
*   **Ακατάστατο Σχήμα (Messy Schema):**
    *   Η ευελιξία του schema-less μπορεί βραχυπρόθεσμα να αυξήσει την παραγωγικότητα.
    *   Μακροπρόθεσμα, όμως, **αν δεν υπάρχει πειθαρχία και σωστός σχεδιασμός**, το μοντέλο δεδομένων μπορεί να γίνει πολύπλοκο, ασυνεπές και δύσκολο στη διαχείριση ("schema-on-read" αντί "schema-on-write").
    *   Η "αναγκαστική" πειθαρχία του σχεδιασμού μοντέλου σε μια RDBMS μπορεί να θεωρηθεί πλεονέκτημα σε αυτή την περίπτωση.
*   **Περιορισμένη Υποστήριξη Προηγμένων Ερωτημάτων (Advanced Query Support):**
    *   Η βασική λειτουργία είναι η ανάκτηση τιμής βάσει κλειδιού. Η βάση **δεν έχει "επίγνωση" του περιεχομένου της τιμής**.
    *   Φιλτράρισμα ή επεξεργασία δεδομένων βάσει περιεχομένου της τιμής πρέπει συχνά να γίνεται **στον κώδικα της εφαρμογής**, το οποίο είναι λιγότερο αποδοτικό από το να γίνεται στη βάση.
    *   Η έλλειψη πλούσιας γλώσσας ερωτημάτων (όπως η SQL) μεταφέρει πολυπλοκότητα στην εφαρμογή.
    *   Η ενημέρωση ενός μόνο τμήματος μιας σύνθετης τιμής μπορεί να είναι αναποτελεσματική, απαιτώντας την αντικατάσταση ολόκληρης της τιμής.
*   **Πιθανώς Λιγότερο Αποδοτική Αποθήκευση & Βελτιστοποίηση Ερωτημάτων:**
    *   Οι RDBMS, γνωρίζοντας το αυστηρό schema και τους τύπους δεδομένων, μπορούν να εφαρμόσουν προηγμένες τεχνικές βελτιστοποίησης αποθήκευσης (π.χ., συμπίεση) και ερωτημάτων (π.χ., βελτιστοποίηση υπολογισμού aggregates) που μπορεί να μην είναι εφικτές σε μια απλή KV βάση.

**6. Περιπτώσεις Χρήσης (Use Cases)**

*   **Εφαρμογές Ευαίσθητες στην Απόδοση (Performance-sensitive applications):**
    *   Χρήση ως **cache** (π.χ., Redis) μπροστά από μια άλλη βάση (π.χ., RDBMS) για επιτάχυνση των αναγνώσεων. Τα δεδομένα γράφονται στην κύρια βάση (source of truth) και προωθούνται στην KV cache, η οποία είναι συχνά γεωγραφικά κατανεμημένη κοντά στους χρήστες για μειωμένο latency.
    *   Αποθήκευση **προ-υπολογισμένων δεδομένων (pre-computed data)** για γρήγορη εμπειρία χρήστη (π.χ., news feeds στο Twitter που παράγονται εκ των προτέρων και αποθηκεύονται σε cache).
*   **Μηχανή Αποθήκευσης για Βάσεις Υψηλότερου Επιπέδου (Storage engine for higher-level databases):**
    *   Πολλές σύγχρονες βάσεις (SQL ή NoSQL) χρησιμοποιούν εσωτερικά μια KV μηχανή αποθήκευσης (όπως η **RocksDB** ή η **LevelDB**) λόγω της καλής τους απόδοσης, αποφεύγοντας την επανεφεύρεση του τροχού. Παραδείγματα: MySQL (MyRocks engine), Cassandra, MongoDB (WiredTiger engine), InfluxDB.
*   **Διαδίκτυο των Πραγμάτων (Internet of Things - IoT):**
    *   Διαχείριση μεγάλου όγκου δεδομένων από κατανεμημένες συσκευές.
    *   Επεξεργασία δεδομένων κοντά στην πηγή τους ("close to the edge"), δηλαδή στο περιβάλλον όπου οι συσκευές συλλέγουν και αποθηκεύουν αρχικά τα δεδομένα σε μια KV βάση.

**7. Παραδείγματα Key-Value Βάσεων**

*   **Berkeley DB:**
    *   Μία από τις πρώτες υλοποιήσεις KV.
    *   **Ενσωματωμένη (Embedded):** Σχεδιασμένη να ενσωματώνεται απευθείας σε μια εφαρμογή, χωρίς δικτυακή πρόσβαση από προεπιλογή.
    *   Θεωρείται πρόδρομος των NoSQL λόγω της απλότητας και της έμφασης στην απόδοση.
    *   Ενέπνευσε τις RocksDB (Facebook) και LevelDB (Google).
*   **Dynamo (Amazon):**
    *   Εσωτερική KV βάση της Amazon, η δημοσίευση της οποίας (Dynamo Paper, 2007) είχε τεράστια επιρροή στην άνοδο των NoSQL.
    *   Χρησιμοποιήθηκε για την κλιμάκωση του Amazon Marketplace.
    *   Έκανε δημοφιλείς έννοιες που υπήρχαν ήδη, δείχνοντας την εμπορική τους αξία.
*   **Redis:**
    *   Πλήρως **in-memory** KV βάση.
    *   Εξαιρετικά γρήγορη για αναγνώσεις και εγγραφές λόγω λειτουργίας στη RAM.
    *   Μειονέκτημα: Υψηλότερο κόστος αποθήκευσης σε σχέση με δίσκο.
    *   Συνήθης χρήση: Ως **cache** παράλληλα με μια άλλη κύρια βάση δεδομένων.

**8. Ιστορικό Πλαίσιο (Μέσα 2000s)**

*   Η Google κυριαρχεί και εισάγει θεμελιώδεις τεχνολογίες για κατανεμημένα συστήματα:
    *   **2003: GFS (Google File System):** Κατανεμημένο σύστημα αρχείων.
    *   **2004: MapReduce:** Αλγόριθμος για κατανεμημένη παράλληλη επεξεργασία μεγάλων δεδομένων.
    *   **2006: BigTable:** Κατανεμημένη, δομημένη βάση δεδομένων (column-family store).
*   **2007: Hadoop (από τη Yahoo):** Υλοποιεί ως open-source τις παραπάνω ιδέες (HDFS, MapReduce implementation [μετέπειτα YARN], HBase [εμπνευσμένο από BigTable]).
*   **Άλλες εξελίξεις:**
    *   Κοινωνικά δίκτυα (MySpace, Facebook) αντιμετωπίζουν τεράστιες προκλήσεις κλιμάκωσης.
    *   **Oracle RAC:** Ακριβή λύση για κλιμάκωση RDBMS.
    *   **Memcached:** Δημοφιλής κατανεμημένη object cache που χρησιμοποιείται με βάσεις ανοιχτού κώδικα.
    *   **MySQL + Sharding:** Προσέγγιση που χρησιμοποιήθηκε με επιτυχία από Twitter, Facebook κ.ά. για μη αυτόματη κλιμάκωση.
    *   **2008 (Publication 2007): Amazon Dynamo:** Θεμελιώδης δημοσίευση για KV βάσεις δεδομένων σχεδιασμένες για web scale.

**9. Amazon Dynamo (2007) - Στόχοι & Χαρακτηριστικά**

*   **Στόχοι Σχεδιασμού:**
    *   **Συνεχής Διαθεσιμότητα (Continuous Availability):** "Always-on".
    *   **Ανεκτικότητα σε Διαμελισμό Δικτύου (Network Partition Tolerant):** Να συνεχίζει να λειτουργεί ακόμα κι αν η επικοινωνία μεταξύ των κόμβων διακοπεί.
    *   **Επίλυση Συγκρούσεων Χωρίς Απώλειες (No-loss Conflict Resolution):** Μηχανισμοί για διαχείριση ταυτόχρονων εγγραφών στο ίδιο αντικείμενο.
    *   **Αποδοτικότητα (Efficiency):** Χαμηλός χρόνος απόκρισης (response time).
    *   **Οικονομία (Economy):** Χρήση φθηνού hardware.
    *   **Βαθμιαία Κλιμάκωση (Incremental Scalability):** Εύκολη προσθήκη/αφαίρεση κόμβων.
*   **Βασικά Χαρακτηριστικά:**
    *   **Χαλαρή Συνέπεια υπέρ Διαθεσιμότητας (Relaxed Consistency in favor of Availability):** Θυσιάζει την άμεση συνέπεια (όλοι οι κόμβοι βλέπουν την ίδια τιμή ταυτόχρονα) για να διασφαλίσει ότι το σύστημα είναι πάντα διαθέσιμο για εγγραφές/αναγνώσεις, αλλά με ελεγχόμενο τρόπο (Eventual Consistency).
    *   **Παραμετροποιήσιμος Συμβιβασμός (Trade-off Configurable):** Η εφαρμογή μπορεί να επιλέξει τη συμπεριφορά σε περίπτωση διαμελισμού δικτύου (π.χ., προτίμηση συνέπειας ή διαθεσιμότητας).
    *   **Πρόσβαση Μόνο Βάσει Πρωτεύοντος Κλειδιού (Only primary key-based access):** Όχι δευτερεύοντα ευρετήρια στην αρχική σχεδίαση.
    *   **Χωρίς Μοντέλο Δεδομένων (No data model):** Η βάση δεν ερμηνεύει την τιμή (value).
    *   **Μικρά Αντικείμενα:** Σχεδιασμένο για τιμές σχετικά μικρού μεγέθους (< 1MB).

**10. Αρχιτεκτονικό Μοντέλο Amazon Dynamo**

*   **Consistent Hashing:** Αλγόριθμος για την κατανομή κλειδιών (και των replicas τους) στους κόμβους του συστήματος με τρόπο που ελαχιστοποιεί την ανακατανομή όταν προστίθενται/αφαιρούνται κόμβοι.
*   **Tunable Consistency (Ρυθμιζόμενη Συνέπεια):** Επιτρέπει στην εφαρμογή να καθορίσει πόσα αντίγραφα πρέπει να διαβαστούν (R) ή να γραφτούν (W) για να θεωρηθεί επιτυχής μια λειτουργία, επηρεάζοντας την ισορροπία μεταξύ συνέπειας και απόδοσης/διαθεσιμότητας.
*   **Data Versioning:** Μηχανισμοί για τη διαχείριση πολλαπλών, πιθανώς αντικρουόμενων, εκδόσεων του ίδιου αντικειμένου που μπορεί να προκύψουν λόγω ταυτόχρονων εγγραφών.

**11. Consistent Hashing (Λεπτομέρειες)**

*   **Πρόβλημα Standard Hashing:** Σε απλό hashing (`hash(key) % N`, όπου Ν ο αριθμός των κόμβων), η προσθήκη ή αφαίρεση ενός κόμβου απαιτεί την ανακατανομή ενός μεγάλου ποσοστού των κλειδιών.
*   **Λύση Consistent Hashing:**
    *   Και τα κλειδιά και οι servers τοποθετούνται (με hash) σε έναν εννοιολογικό **δακτύλιο (ring)** (π.χ., εύρος 0 έως 2^32-1).
    *   Ένα κλειδί αποθηκεύεται στον **επόμενο server** που συναντάται στον δακτύλιο κατά τη φορά των δεικτών του ρολογιού.
    *   **Πλεονέκτημα:** Η προσθήκη/αφαίρεση ενός server επηρεάζει μόνο τα κλειδιά που αντιστοιχούν στο τόξο μεταξύ του και του προηγούμενου server στον δακτύλιο, ελαχιστοποιώντας την ανακατανομή.
*   **Virtual Nodes/Copies:**
    *   Για να μειωθεί η **ανομοιομορφία (variance)** στην κατανομή κλειδιών (ένας server μπορεί να πάρει δυσανάλογα μεγάλο εύρος του δακτυλίου), κάθε φυσικός server αντιστοιχίζεται σε **πολλαπλούς "εικονικούς" κόμβους (virtual nodes)** στον δακτύλιο (κάθε virtual node έχει διαφορετικό hash).
    *   Αυτό οδηγεί σε πιο ομοιόμορφη κατανομή των κλειδιών.
    *   Χρήσιμο και για **ετερογενείς servers** (με διαφορετικές δυνατότητες/χωρητικότητα), δίνοντας περισσότερα virtual nodes σε πιο ισχυρούς servers.

**12. Tunable Consistency (Ρυθμιζόμενη Συνέπεια - NWR Μοντέλο)**

*   **N:** Ο συνολικός αριθμός των αντιγράφων (replicas) που διατηρούνται για κάθε στοιχείο δεδομένων.
*   **W:** Ο αριθμός των αντιγράφων που πρέπει να επιβεβαιώσουν μια **εγγραφή (write)** για να θεωρηθεί επιτυχής.
*   **R:** Ο αριθμός των αντιγράφων που πρέπει να προσπελαστούν κατά την **ανάγνωση (read)**.
*   **Ισορροπίες:**
    *   **W + R > N => Strong Consistency (Συνήθως):** Εγγυάται ότι η ανάγνωση θα δει τουλάχιστον ένα αντίγραφο με την τελευταία επιτυχημένη εγγραφή (λόγω επικάλυψης των κόμβων εγγραφής/ανάγνωσης - quorum).
        *   *Παράδειγμα (Διαφ. 33, δεξιά):* N=3, W=2, R=2. (2+2 > 3). Faster writes (περιμένει 2 κόμβους), still consistent.
    *   **W = N, R = 1 => Βελτιστοποιημένο για Γρήγορες Αναγνώσεις:** Η εγγραφή περιμένει όλους, η ανάγνωση παίρνει από έναν (γρήγορα), αλλά μπορεί να μην είναι η πιο πρόσφατη τιμή αν η εγγραφή δεν έχει ολοκληρωθεί παντού.
        *   *Παράδειγμα (Διαφ. 33, αριστερά):* N=3, W=3, R=1. Slow writes, fast reads, consistent.
    *   **W = 1, R = N => Βελτιστοποιημένο για Γρήγορες Εγγραφές:** Η εγγραφή επιστρέφει γρήγορα (περιμένει έναν), η ανάγνωση ελέγχει όλους για να βρει την πιο πρόσφατη.
        *   *Παράδειγμα (Διαφ. 34, αριστερά):* N=3, W=1, R=N (άρα R=3). Fastest write, slow but consistent reads.
    *   **W + R <= N (π.χ., W=1, R=1) => Eventual Consistency:** Πολύ γρήγορες εγγραφές και αναγνώσεις, αλλά **χωρίς εγγύηση** άμεσης συνέπειας. Η ανάγνωση μπορεί να επιστρέψει παλιά δεδομένα. Το σύστημα θα συγκλίνει τελικά (eventually).
        *   *Παράδειγμα (Διαφ. 34, δεξιά):* N=3, W=1, R=1. Fast, but not consistent.

**13. Replicas & Τοπολογία (Διαφ. 35)**

*   Ο αλγόριθμος consistent hashing καθορίζει και πού θα αποθηκευτούν τα **N-1** αντίγραφα ενός κλειδιού.
*   **Απλή Στρατηγική:** Τα αντίγραφα γράφονται στους επόμενους κόμβους στον δακτύλιο.
*   **Στρατηγική Τοπολογίας Δικτύου (Network Topology Strategy):** Για μεγαλύτερη ανθεκτικότητα, τα αντίγραφα τοποθετούνται σε κόμβους που βρίσκονται σε διαφορετικά **racks** ή **data centers**, ώστε η αποτυχία ενός ολόκληρου rack/datacenter να μην επηρεάσει όλα τα αντίγραφα.

**14. Data Versioning & Conflict Resolution (Επίλυση Συγκρούσεων)**

*   Πώς χειριζόμαστε την περίπτωση που πολλαπλές εγγραφές συμβαίνουν ταυτόχρονα (ή κατά τη διάρκεια ενός network partition) στο ίδιο κλειδί;
*   **Προσεγγίσεις:**
    1.  **Last Write Wins (LWW):**
        *   Κάθε εγγραφή έχει ένα **timestamp**. Η εγγραφή με το νεότερο timestamp "κερδίζει" και αντικαθιστά τις παλαιότερες.
        *   **Μειονέκτημα:** Απαιτεί συγχρονισμένα ρολόγια (ή λογικά ρολόγια). Κίνδυνος για **χαμένες ενημερώσεις (lost updates)**, ειδικά αν οι λειτουργίες δεν είναι αντιμεταθετικές (π.χ., προσθήκη σε λίστα).
        *   *Λύση για lost updates (σε ορισμένες βάσεις):* Κλείδωμα ολόκληρου του αντικειμένου (row/document) ή επιλογή μικρότερης μονάδας τροποποίησης/σύγκρουσης (π.χ., cell σε column-family store).
    2.  **Vector Clocks:**
        *   Μια πιο σύνθετη προσέγγιση που **δεν απαιτεί συγχρονισμένα ρολόγια**.
        *   Βοηθά στον εντοπισμό **αιτιακής σχέσης (causality)** μεταξύ των γεγονότων/εγγραφών και στον εντοπισμό πιθανών **συγκρούσεων (conflicts)** (ταυτόχρονων γεγονότων).
        *   **Λειτουργία:** Κάθε κόμβος διατηρεί ένα **διάνυσμα (vector)** από μετρητές (logical clocks), έναν για κάθε κόμβο στο σύστημα.
            *   Όταν συμβαίνει ένα εσωτερικό γεγονός ή αποστολή μηνύματος, ο μετρητής του τρέχοντος κόμβου στο διάνυσμά του αυξάνεται.
            *   Όταν στέλνεται μήνυμα, μεταφέρει το vector clock του αποστολέα.
            *   Όταν λαμβάνεται μήνυμα, ο τοπικός μετρητής αυξάνεται και κάθε στοιχείο του τοπικού vector clock ενημερώνεται στο `max` της τοπικής τιμής και της τιμής στο εισερχόμενο vector clock.
        *   **Σχέσεις Γεγονότων:**
            *   `a` **προηγείται αιτιακά** του `b` (`a -> b`): Αν το vector clock του `a` είναι μικρότερο ή ίσο σε κάθε στοιχείο από του `b`, και τουλάχιστον ένα στοιχείο είναι αυστηρά μικρότερο.
            *   `a` και `b` είναι **ταυτόχρονα/ανεξάρτητα** (`a || b`): Αν ούτε `a -> b` ούτε `b -> a`. **Αυτό υποδηλώνει σύγκρουση!**
        *   **Επίλυση Σύγκρουσης (όταν εντοπιστεί με Vector Clocks):**
            *   *Revert to Last Write Wins (παρόλο που ξέρουμε ότι υπάρχει σύγκρουση).*
            *   **Διατήρηση όλων των αντικρουόμενων εκδόσεων (Keep both/all copies - "siblings"):** Η εφαρμογή (ή ο χρήστης) καλείται να επιλύσει τη σύγκρουση διαλέγοντας ή συγχωνεύοντας.
            *   **Αυτόματη Συγχώνευση (Merge):** Προσπάθεια αυτόματης συγχώνευσης από τη βάση (π.χ., DynamoDB) ή χρήση εξειδικευμένων τύπων δεδομένων.
    3.  **Conflict-Free Replicated Data Types (CRDTs):**
        *   Τύποι δεδομένων σχεδιασμένοι ώστε οι συγκρούσεις να επιλύονται **αυτόματα και ντετερμινιστικά**, οδηγώντας πάντα στην ίδια τελική κατάσταση ανεξάρτητα από τη σειρά άφιξης των ενημερώσεων (convergent).
        *   Όταν μια τιμή CRDT διαδίδεται, περιλαμβάνει όχι μόνο την τρέχουσα τιμή αλλά και ένα ιστορικό των λειτουργιών.
        *   *Παράδειγμα:* **g-counter (grow-only counter):** Ένας μετρητής που μόνο αυξάνεται. Η συγχώνευση είναι απλά η λήψη του max για κάθε στοιχείο του counter από διαφορετικούς κόμβους.

**15. Secondary Indexing (Δευτερεύοντα Ευρετήρια σε KV)**

*   Πώς βρίσκουμε δεδομένα χωρίς να ξέρουμε το πρωτεύον κλειδί τους;
*   **DIY (Do It Yourself) Secondary Indexing (Διαφ. 42):**
    *   Η εφαρμογή δημιουργεί και συντηρεί η ίδια "πίνακες ευρετηρίου" (ουσιαστικά άλλες KV εγγραφές).
    *   Π.χ., για να βρεις χρήστες με βάση τη χώρα ("USA"), διατηρείς ένα κλειδί "country:USA" του οποίου η τιμή είναι μια λίστα από τα πρωτεύοντα κλειδιά (RowKey) των χρηστών που ανήκουν στις ΗΠΑ. Απαιτεί δύο αναζητήσεις (μία στο index, μία στον κύριο "πίνακα").
*   **Ενσωματωμένα Δευτερεύοντα Ευρετήρια:**
    *   **Global Indexes (Καθολικά Ευρετήρια - Διαφ. 43):**
        *   Οι εγγραφές του ευρετηρίου κατανέμονται (partitioned) στο cluster ανεξάρτητα από τον κύριο πίνακα (π.χ., με consistent hashing της τιμής του ευρετηριασμένου πεδίου ή χρησιμοποιώντας την τιμή ως shard key).
        *   Μια εγγραφή ευρετηρίου τυπικά βρίσκεται σε **διαφορετικό κόμβο** από την κύρια εγγραφή δεδομένων.
        *   **Μειονέκτημα:** Η αναζήτηση μέσω του ευρετηρίου συνήθως απαιτεί **δύο δικτυακά hops (2 IOs)** - ένα για το ευρετήριο, ένα για τα κύρια δεδομένα.
        *   Πρόβλημα **skew:** Αν η τιμή του ευρετηριασμένου πεδίου δεν είναι μοναδική και έχει ανομοιόμορφη κατανομή (π.χ., πεδίο "χώρα"), ο φόρτος του ευρετηρίου μπορεί να κατανεμηθεί άνισα στους κόμβους.
    *   **Local Indexes (Τοπικά Ευρετήρια - Διαφ. 44):**
        *   Κάθε κόμβος διατηρεί ένα ευρετήριο **μόνο για τα δεδομένα που φιλοξενεί τοπικά** σε αυτόν τον κόμβο (partition).
        *   Οι ερωτήσεις που βασίζονται στο ευρετήριο στέλνονται **σε όλους τους κόμβους**.
        *   Κάθε κόμβος απαντά με τα τοπικά αποτελέσματα χρησιμοποιώντας το τοπικό του ευρετήριο.
        *   Ένας **συντονιστής (query coordinator)** συλλέγει και συνδυάζει τα αποτελέσματα από όλους τους κόμβους.
        *   **Πλεονέκτημα:** Οι εγγραφές είναι πιο γρήγορες (ενημερώνεται μόνο τοπικό index). Οι αναγνώσεις μπορεί να είναι πιο αργές αν πρέπει να ερωτηθούν πολλοί κόμβοι.

