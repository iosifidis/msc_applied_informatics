## **Βάσεις Δεδομένων Κλειδί-Τιμή (Key-Value Databases)**

**1. Τι είναι μια Key-Value Βάση Δεδομένων; (Διαφάνειες 2 & 3)**

*   Είναι η **απλούστερη μορφή βάσης δεδομένων NoSQL**.
*   Κάθε μεμονωμένο στοιχείο (item) στην βάση αποθηκεύεται ως ένα **ζεύγος Κλειδί-Τιμή (Key-Value pair)**.
    *   Το **Κλειδί (Key)** είναι ένα όνομα γνωρίσματος (attribute name) ή, πιο γενικά, ένα μοναδικό αναγνωριστικό για την τιμή.
    *   Η **Τιμή (Value)** είναι τα δεδομένα που σχετίζονται με το συγκεκριμένο κλειδί.
    *   Διάγραμμα: Key 1 → Value 1, Key 2 → Value 2 (κλασική αναπαράσταση).
*   Τα δεδομένα στο σύνολό τους είναι μια **συλλογή από ζεύγη κλειδιού-τιμής**.
*   Η Τιμή μπορεί να είναι απλός τύπος δεδομένων (ακέραιος, συμβολοσειρά) ή πιο σύνθετος (π.χ. σύνολα, λίστες, ή ακόμα και ολόκληρο ένα JSON/XML document).
*   Το **Κλειδί** σε κάθε ζεύγος κλειδί-τιμή **πρέπει να είναι μοναδικό**. Αυτό επιτρέπει την απευθείας αναγνώριση και ανάκτηση της αντίστοιχης τιμής.
*   Η ανάκτηση των δεδομένων γίνεται μέσω **ακριβούς αντιστοίχισης στο κλειδί** (exact match on the key). Δίνεις το κλειδί, παίρνεις την τιμή του.
*   **Ευελιξία Σχήματος:** Νέοι "τύποι δεδομένων" (με την έννοια νέων γνωρισμάτων ή διαφορετικών δομών για την τιμή) μπορούν εύκολα να προστεθούν στην βάση απλά δημιουργώντας νέα ζεύγη κλειδιού-τιμής, χωρίς να επηρεάζονται τα υπάρχοντα ή να απαιτούνται αλλαγές στο σχήμα της βάσης.

**2. Οι Βασικές Λειτουργίες (Operations) (Διαφάνεια 4)**

Οι τρεις κύριες λειτουργίες (ενέργειες) που εκτελούνται σε μια βάση δεδομένων Κλειδί-Τιμή είναι:

1.  **put(κλειδί, τιμή):** Αποθηκεύει (ή ενημερώνει) ένα ζεύγος κλειδιού-τιμής. Αν το κλειδί υπάρχει, η τιμή αντικαθίσταται. Αν δεν υπάρχει, δημιουργείται νέο ζεύγος. (Αντιστοιχεί στα INSERT/UPDATE σε RDBMS).
2.  **get(κλειδί):** Ανακτά την τιμή που αντιστοιχεί στο δεδομένο κλειδί. (Αντιστοιχεί στο SELECT * WHERE primary_key=... σε RDBMS).
3.  **delete(κλειδί):** Διαγράφει το ζεύγος κλειδιού-τιμής που αντιστοιχεί στο δεδομένο κλειδί. (Αντιστοιχεί στο DELETE WHERE primary_key=... σε RDBMS).

Αυτές είναι οι βασικές CRUD (Create, Read, Update, Delete) λειτουργίες, προσαρμοσμένες στο μοντέλο Key-Value.

**3. Παραδείγματα Key-Value ΣΔΒΔ (Διαφάνεια 5)**

Μερικά δημοφιλή παραδείγματα Συστημάτων Διαχείρισης Βάσεων Δεδομένων Κλειδί-Τιμή είναι:

*   **Redis:** Πολύ γνωστή για την in-memory και caching χρήση της.
*   **Riak:** Σχεδιασμένη για υψηλή διαθεσιμότητα και fault tolerance.
*   **Oracle NoSQL:** Η Key-Value προσφορά της Oracle στο χώρο του NoSQL.

**(Σημείωση:** Υπάρχουν και πολλές άλλες, όπως το Amazon Dynamo, Couchbase, Memcached, etcd, κ.λπ.)

**4. Αναπαράσταση Σχεσιακού Σχήματος σε Key-Value Βάση (Διαφάνειες 6 & 7)**

Είναι δυνατόν να αναπαραστήσουμε δεδομένα από ένα σχεσιακό σχήμα σε μια Key-Value βάση, αλλά ο τρόπος είναι διαφορετικός από την παραδοσιακή οργάνωση σε γραμμές και στήλες. Σε μια KV βάση, η έννοια της "σειράς" ή "εγγραφής" από το σχεσιακό μοντέλο πρέπει να μεταφραστεί σε ένα ή περισσότερα ζεύγη κλειδιού-τιμής.

*   **Διαφάνεια 6 (Παράδειγμα STUDENT):**
    *   Έστω ο σχεσιακός πίνακας `STUDENT` με στήλες `SID` (Primary Key), `SFName`, `SPhone`.
    *   Μια εγγραφή όπως `<16s143, Ahmed, 95214785>` μπορεί να αναπαρασταθεί στην KV βάση δημιουργώντας ένα ζεύγος κλειδιού-τιμής **για κάθε γνώρισμα (στήλη) της σχεσιακής εγγραφής**.
    *   Το **Κλειδί** κατασκευάζεται συνήθως συνδυάζοντας το όνομα του πίνακα/σχέσης, την τιμή του Primary Key (από τον σχεσιακό πίνακα) και το όνομα του γνωρίσματος.
    *   Η **Τιμή** είναι η αντίστοιχη τιμή του γνωρίσματος για τη συγκεκριμένη εγγραφή.
    *   Έτσι, η σχεσιακή εγγραφή `<16s143, Ahmed, 95214785>` μετατρέπεται στα εξής ζεύγη Κλειδιού-Τιμής:
        *   **Κλειδί:** `Student:16s143:SFName` -> **Τιμή:** `"Ahmed"`
        *   **Κλειδί:** `Student:16s143:SPhone` -> **Τιμή:** `95214785`
*   **Διαφάνεια 7 (Γενικό Σχήμα):**
    *   Το γενικό μοτίβο για το **Κλειδί** είναι: `όνομα_πίνακα:τιμή_primary_key:όνομα_γνωρίσματος`.
    *   Η **Τιμή** είναι η `τιμή` του συγκεκριμένου `γνωρίσματος`.
    *   Αυτό δείχνει πώς μια "λογική σειρά" από ένα RDBMS **σπάει σε πολλά, ανεξάρτητα ζεύγη κλειδιού-τιμής** στην KV βάση.

**5. Άσκηση: Μετατροπή EMPLOYEE σε Key-Value Σχήμα (Διαφάνεια 8 & 9)**

*   **Διαφάνεια 8:** Σας δίνεται ένας σχεσιακός πίνακας `EMPLOYEE` με στήλες `EmpID` (Primary Key), `EmpName`, `EmpAddress`, `EmpBdate`. Ζητείται να τον μετατρέψετε σε σχήμα Κλειδί-Τιμή ακολουθώντας το παραπάνω μοτίβο.
*   **Διαφάνεια 9:** Παρέχεται η λύση:
    *   Για την εγγραφή με EmpID=100:
        *   `Employee:100:EmpName` = `"Laika Al-Mamari"`
        *   `Employee:100:EmpAddress` = `"Al Batinah, Sohar"`
        *   `Employee:100:EmpBdate` = `"1/21/1980"`
    *   Ανάλογα για τις εγγραφές με EmpID=101 και 102.

**Σημαντικά Σημεία / Βασικές Κατανοήσεις:**

*   Η Key-Value βάση είναι απίστευτα γρήγορη για τις βασικές λειτουργίες **put, get, delete** όταν το κλειδί είναι γνωστό (direct lookup).
*   **Δεν είναι αποδοτική** για αναζητήσεις με **μη-πλήρες κλειδί**, για αναζητήσεις **εντός της τιμής**, ή για σύνθετα **joins** και **aggregations** (όπως SUM, AVG) που είναι συνηθισμένα σε RDBMS. Αυτού του είδους οι λειτουργίες πρέπει να γίνουν από την εφαρμογή *μετά* την ανάκτηση των σχετικών ζευγών κλειδιού-τιμής.
*   Είναι ιδανική για περιπτώσεις όπου η πρόσβαση στα δεδομένα γίνεται **κυρίως μέσω ενός μοναδικού αναγνωριστικού** (ID, username, session token κλπ.), όπως σε cache, user profiles, session stores.
*   Το "σπάσιμο" μιας σχεσιακής εγγραφής σε πολλαπλά KV ζεύγη, όπως δείχνεται στα παραδείγματα STUDENT και EMPLOYEE, είναι ένας τρόπος να αποθηκεύσετε δομημένα δεδομένα. Άλλη προσέγγιση θα ήταν να αποθηκεύσετε ολόκληρο το σχεσιακό "record" ή ένα JSON object ως την **Τιμή** για ένα μοναδικό **Κλειδί** (π.χ. EmpID):
    *   **Κλειδί:** `Employee:100` -> **Τιμή:** `{ "EmpName": "Laika Al-Mamari", "EmpAddress": "Al Batinah, Sohar", "EmpBdate": "1/21/1980" }` (σε μορφή JSON ή άλλη σειριοποιημένη μορφή).
    Αυτή η προσέγγιση, όπου η τιμή είναι ένα πιο σύνθετο, αυτοπεριγραφόμενο document, μας φέρνει πιο κοντά στις **Document Databases** (που θα δούμε αργότερα).

Η κατανόηση αυτού του απλού μοντέλου είναι θεμελιώδης για να εκτιμήσετε τις επιλογές σχεδιασμού και τους συμβιβασμούς των πιο σύνθετων NoSQL μοντέλων.
