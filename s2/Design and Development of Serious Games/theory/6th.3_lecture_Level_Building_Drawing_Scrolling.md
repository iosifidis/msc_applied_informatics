# Level Building Drawing Scrolling

Η δομή αυτής της ενότητας είναι: **Level editor -> Creating and loading game levels -> Collidable tiles, portals, world data**. Θα δούμε πώς να δημιουργούμε σύνθετους χάρτες, πώς να φορτώνουμε τα δεδομένα τους στην εφαρμογή μας και πώς να εμφανίζουμε ένα τμήμα του χάρτη με δυνατότητα κύλισης.

---

## Συντάκτης Επιπέδων - Level Editor (Slides 2-11)

*   **Τι είναι ένα Επίπεδο (Level) (Slide 2):** Ένα επίπεδο παιχνιδιού καθορίζει τους κανόνες, τα εμπόδια και τον κόσμο που πρέπει να ξεπεράσει ο παίκτης.
*   **Σχεδίαση Επιπέδου ως Χάρτη Πλακιδίων (Tilemap) (Slide 2):** Κάθε επίπεδο σχεδιάζεται συνήθως ως ένας **χάρτης πλακιδίων (tilemap)**. Πρόκειται για έναν δισδιάστατο πίνακα πλακιδίων (tiles) με καθορισμένο πλάτος και ύψος.
*   **Διαστάσεις (Slide 2):** Στον συντάκτη που θα δούμε, οι διαστάσεις του χάρτη είναι 128x128 tiles, ή αλλιώς 4096x4096 pixels (αν κάθε tile έχει μέγεθος 32x32 pixels).
*   **Tilemap Editors (Slide 2):** Για τη δημιουργία ενός tilemap, χρησιμοποιούνται ειδικοί συντάκτες (editors) που αναπτύσσονται γι' αυτό το σκοπό (π.χ., Mappy). Σε αρκετές περιπτώσεις, αναπτύσσονται νέοι tilemap editors ειδικά για τις ανάγκες ενός συγκεκριμένου παιχνιδιού. Ένας προσαρμοσμένος editor μας δίνει τη δυνατότητα να δημιουργούμε τον κόσμο του παιχνιδιού (game world) με τις ιδιότητες που χρειαζόμαστε κάθε φορά.

*   **LevelEditor (Slides 3-11):**
    *   **Διασύνδεση (Slide 3):** Ο editor περιλαμβάνει:
        *   Μια **παλέτα πλακιδίων (tile palette)**: Όλα τα διαθέσιμα tiles που μπορούν να χρησιμοποιηθούν. Κάθε tile έχει συνήθως διάσταση 32x32 pixels (Slide 4).
        *   Μια **περιοχή tilemap** (ο χάρτης): Η περιοχή όπου σχεδιάζεται το επίπεδο.
        *   Περιοχές για την **προβολή/επεξεργασία ιδιοτήτων** (properties) και δεδομένων (data) των tiles.
    *   **Ιδιότητες Πλακιδίων (Tile Properties) (Slides 4-5):** Σε ένα tilemap editor, κάθε tile στην παλέτα έχει έναν **αναγνωριστικό αριθμό/κωδικό (tile ID)** (Slide 4). Καθώς ο χρήστης "σχεδιάζει" το επίπεδο με το ποντίκι, κάθε πλακίδιο του χάρτη ενημερώνεται με τον αντίστοιχο αριθμό – tile ID.
        *   Ο editor μας δίνει τη δυνατότητα να προσθέσουμε σε κάθε tile επιπλέον **πεδία** για αποθήκευση δεδομένων (Data 1, 2, 3, 4) (Slide 5).
        *   Μπορούμε να ορίσουμε αν ένα tile αποτελεί **εμπόδιο (Collidable)** που δεν μπορεί να διαπεράσει ο παίκτης (boolean true/false).
        *   Μπορούμε να ορίσουμε αν ένα tile αποτελεί **πύλη (Portal)**, και σε ποια **συντεταγμένη (x, y)** ή σε ποιο άλλο **επίπεδο (file)** οδηγεί (Slide 5).
    *   **Δημιουργία & Αποθήκευση Tilemap (Slides 6-7):**
        *   Τα tilemaps που δημιουργούμε αποθηκεύονται συνήθως σε αρχεία μορφής **XML**. Αν και έχουν επέκταση `.level`, μπορείτε να τα ανοίξετε και να διαπιστώσετε εύκολα ότι είναι σε μορφή XML (Slide 6).
        *   Η επιλογή "Export Level Bitmap" (π.χ., 4096x4096) μπορεί να αποθηκεύσει όλο το επίπεδο ως bitmap, αλλά το μέγεθος είναι μεγάλο (65MB). Αυτή η δυνατότητα χρησιμεύει για προσθήκη εικόνων στο εγχειρίδιο ή tutorial, αλλά δεν είναι πρακτική για την απόδοση κατά την εκτέλεση του παιχνιδιού (Slide 6).
        *   **Δομή XML (Slide 7):** Το αρχείο XML περιλαμβάνει ένα βασικό στοιχείο `DocumentElement` και μέσα σε αυτό, στοιχεία `tiles`. Κάθε στοιχείο `tiles` περιγράφει ένα πλακίδιο του χάρτη, περιλαμβάνοντας το `tile` ID, την `value`, και τα πεδία `data`, `collidable`, `portal`, `portalx`, `portaly`, `portalfile`.
    *   **Προβολή Δεδομένων/Ιδιοτήτων Tiles (Slides 8-9):** Ο editor παρέχει επιλογές για την προβολή των δεδομένων και ιδιοτήτων των tiles στον χάρτη:
        *   "Show Tile #'s": Εμφανίζει τον αριθμό (tile ID) κάθε tile (Slide 8).
        *   "Show Data": Εμφανίζει τα δεδομένα (Data 1-4) του επιλεγμένου tile (Slide 9).
        *   "Show Collidable": Εμφανίζει αν ένα tile είναι Collidable (C) (Slide 9).
        *   "Show Portals": Εμφανίζει αν ένα tile είναι Portal (P) (Slide 9).
    *   **Εξαγωγή Tile Palette (Slide 10):** Ο editor επιτρέπει την εξαγωγή της παλέτας πλακιδίων ως εικόνα (bitmap) σε διάφορες διαστάσεις. Η διάσταση 512x512 συνήθως απαιτείται από τις μηχανές παιχνιδιών.
    *   **Ενημέρωση Tilemap (Slide 11):** Ο editor παρέχει επιλογές για την ενημέρωση του tilemap, όπως Fill Empty Tiles, Fill Whole Map, Clear All Data/Collidables/Portals, Auto Set Collidable.

---

## Φόρτωση & Σχεδίαση Ενός Επιπέδου (Slides 12-20)

*   **LevelViewer (Slide 12):** Το παράδειγμα αυτό δείχνει την φόρτωση και σχεδίαση ενός επιπέδου παιχνιδιού στην εφαρμογή μας.
*   **Διαδικασία Φόρτωσης (Slide 13):**
    *   Φορτώνουμε τα δεδομένα του χάρτη από το αρχείο XML που δημιουργήσαμε με τον tilemap editor.
    *   Όπως αναφέρθηκε στο MazeWorld, ο κόσμος του παιχνιδιού (το επίπεδο) προσθέτει δεδομένα που μας παρέχουν λειτουργικότητα (συμπαγή αντικείμενα/εμπόδια, πύλες τηλεμεταφοράς κτλ.).
    *   Τα δεδομένα περιγράφουν τι πρέπει να συμβεί στον κόσμο και επεξεργάζονται με βάση συγκεκριμένους κανόνες από τον κώδικα που γράφουμε (**data-driven programming**).

*   **Ανάγνωση Δεδομένων XML (Slide 14):**
    *   Για το διάβασμα των δεδομένων από το αρχείο XML, χρησιμοποιούμε .NET κλάσεις από το namespace **`System.Xml`**.
    *   Για την σχεδίαση ενός επιπέδου χρειαζόμαστε: Τα δεδομένα του tilemap από το αρχείο `.xml` και τα αρχικά tiles που αποθηκεύονται σε ένα bitmap (η παλέτα).

*   **Δήλωση Μεταβλητών (Slide 15):**
    *   Δηλώνουμε ένα **δομή (struct)** τύπου `tilemapStruct` για την αποθήκευση των απαραίτητων πληροφοριών για **κάθε** tile: `tilenum` (tile ID), `data1` (extra data), `collidable` (true/false).
    *   Δηλώνουμε σταθερές για τον **αριθμό στηλών** με tiles στην παλέτα (`COLUMNS`).
    *   Δηλώνουμε μια μεταβλητή `Bitmap` για τα αρχικά tiles (`bmpTiles`).
    *   Δηλώνουμε έναν **μονοδιάστατο πίνακα** δομών `tilemapStruct` (`tilemap`) με μέγεθος όσο το συνολικό πλήθος tiles στο tilemap (π.χ., 128x128).

*   **Διάβασμα XML Δεδομένων & Ενημέρωση Πίνακα (Slides 16-18):**
    *   Δημιουργούμε ένα αντικείμενο τύπου `XmlDocument` και φορτώνουμε (`Load`) σε αυτό τα δεδομένα του αρχείου XML.
    *   Ανακτούμε την μεταβλητή-λίστα `nodelist` με τα στοιχεία-κόμβους (`XmlNodeList`) που προσδιορίζονται από το tag "tiles".
    *   Χρησιμοποιούμε ένα βρόχο `foreach` για να διασχίσουμε τη λίστα των κόμβων.
    *   Σε κάθε επανάληψη, ανακτούμε τον επόμενο κόμβο και τον μετατρέπουμε (`casting`) σε αντικείμενο τύπου `XmlElement`.
    *   Ενημερώνουμε τις τοπικές μεταβλητές (`index`, `value`, `data1`, `collidable`) με τα δεδομένα από τα tags εντός του στοιχείου `tiles`.
    *   Τέλος, ενημερώνουμε τον πίνακα `tilemap` με τα στοιχεία του tile που μόλις επεξεργάστηκε (`tilemap[index].tilenum = value;` κ.λπ.).

*   **Σχεδίαση Tilemap (Slides 19-20):**
    *   Ορίζουμε μια μέθοδο `drawTilemap()` που θα σχεδιάζει το επίπεδο.
    *   Χρησιμοποιώντας τα δεδομένα του πίνακα `tilemap`, ο κόσμος/επίπεδο του παιχνιδιού (π.χ., ένα grid 128x128 tiles) σχεδιάζεται.
    *   Στην περίπτωση μας, οι διαστάσεις του παραθύρου είναι 800x600 pixels και κάθε tile έχει διάσταση 32x32 pixels, οπότε το επίπεδο που θα σχεδιαστεί στην οθόνη θα έχει διάσταση 25x19 tiles.
    *   Χρησιμοποιούμε ένα διπλό βρόχο `for` για να διατρέξουμε τα tiles που είναι ορατά στην οθόνη (rows x columns).
    *   Για τη σχεδίαση του κάθε tile, καλείται επαναληπτικά η μέθοδος `drawTileNumber()`.
    *   **`drawTileNumber(int x, int y, int tile)` (Slides 19-20):**
        *   Αυτή η μέθοδος παίρνει ως ορίσματα τη **στήλη (x)** και τη **γραμμή (y)** μέσα στο grid της οθόνης όπου θα σχεδιαστεί ο χάρτης, και τον **αριθμό (tile)** του tile που θα σχεδιαστεί (όπως ορίζεται μέσα στον πίνακα `tilemap`).
        *   Υπολογίζει την περιοχή (`Rectangle src`) μέσα στην παλέτα των tiles (`bmpTiles`) που περιλαμβάνει το tile που πρέπει να σχεδιαστεί, με βάση τον αριθμό του tile (`tile % COLUMNS`, `tile / COLUMNS`) και τη διάσταση των tiles (32x32 pixels).
        *   Υπολογίζει τις συντεταγμένες (`dx, dy`) του σημείου από όπου θα ξεκινήσει η σχεδίαση μέσα στον κόσμο του παιχνιδιού του tile (στην οθόνη), με βάση τις στήλη και γραμμή του στο grid (`x*32`, `y*32`).
        *   Χρησιμοποιεί τη μέθοδο `DrawImage()` του αντικειμένου `Graphics` (`gfxSurface.DrawImage`) για να σχεδιάσει το τμήμα-tile από το `bmpTiles` στην επιφάνεια `Bitmap` (`gfxSurface`) στις συντεταγμένες `dx, dy` με πλάτος και ύψος 32x32 pixels.
        *   Ενημερώνεται το PictureBox (`pbSurface.Image = bmpSurface;`).

---

## Scrolling (Slides 21-27)

*   **LevelScroller (Slide 21):** Το παράδειγμα αυτό δείχνει την υλοποίηση **κύλισης (scrolling)** του χάρτη.
*   **Ανάγκη για Scrolling (Slide 22):** Όταν ένα παιχνίδι έχει έναν κόσμο με μεγάλες διαστάσεις, δεν μπορεί να εμφανιστεί ολόκληρος ταυτόχρονα. Παρουσιάζεται κάθε χρονική στιγμή ένα τμήμα του, και υπάρχει η ανάγκη για μετακίνηση (scrolling) μέσα στον κόσμο. Αυτό μπορεί να επιτευχθεί με 3 βασικούς τρόπους (όπως αναφέρεται και στην προηγούμενη διαφάνεια): Φορτώνοντας μια μεγάλη εικόνα από tiles, Δημιουργώντας μια μεγάλη εικόνα από tiles κατά την εκτέλεση, Σχεδιάζοντας τα tiles απευθείας στην οθόνη.
*   **Παρουσίαση Τμήματος Κόσμου (Slide 23):** Σε αρκετές περιπτώσεις, δεν χρησιμοποιείται ολόκληρη η περιοχή του παιχνιδιού για την παρουσίαση του εικονικού κόσμου. Στα παιχνίδια ρόλων (RPG) για παράδειγμα, ένα μέρος μόνο της οθόνης χρησιμοποιείται για την παρουσίαση του κόσμου.

*   **Full-Tile Scrolling (Slides 24-27):**
    *   **Έννοια:** Έχουμε κύλιση του κόσμου κατά 1 tile κάθε φορά (κύλιση κατά μία γραμμή οριζόντια ή κατακόρυφα).
    *   **Θέση Κύλισης (Scroll Position) (Slide 24):** Αυτό που χρειαζόμαστε είναι να γνωρίζουμε ανά πάσα στιγμή τη θέση κύλισης (scroll position), ή με απλά λόγια τη θέση (X = γραμμή, Y = στήλη) του **πάνω αριστερού** tile από τον χάρτη του παιχνιδιού (όχι της οθόνης) που είναι ορατό κάθε χρονική στιγμή.
    *   **Μεταβλητή `scrollPos` (Slide 24):** Δηλώνουμε μια επιπλέον μεταβλητή τύπου `PointF` για την αποθήκευση αυτής της θέσης κύλισης: `private PointF scrollPos = new PointF(0, 0);`.
    *   **Υλοποίηση `drawTilemap()` (Slides 25-26):** Η διαφορά στην υλοποίηση της `drawTilemap` (σε σχέση με τη σχεδίαση ενός απλού επιπέδου χωρίς κύλιση) έγκειται στον τρόπο εντοπισμού της θέσης `tilenum` του tile που πρόκειται να σχεδιαστεί κάθε φορά μέσα στον μονοδιάστατο πίνακα `tilemap`.
        *   Η θέση αυτή είναι συνάρτηση της θέσης κύλισης `scrollPos`.
        *   Χρησιμοποιούμε ένα διπλό βρόχο `for` για να διατρέξουμε τα tiles **που είναι ορατά στην οθόνη** (π.χ., `x` από 0 έως 25, `y` από 0 έως 19).
        *   Για κάθε ορατό tile στη θέση (`x`, `y`) της οθόνης, το αντίστοιχο tile στον πίνακα `tilemap` βρίσκεται στη θέση (`(int)scrollPos.Y + y`, `(int)scrollPos.X + x`).
        *   Ο αριθμός του tile (`tilenum`) λαμβάνεται από τον πίνακα: `tilenum = tilemap[(int)scrollPos.Y + y][(int)scrollPos.X + x].tilenum;`.
        *   Η συνάρτηση `drawTileNumber()` που σχεδιάζει ένα μεμονωμένο tile **δεν χρειάζεται κάποια αλλαγή**.
    *   **Έλεγχος Κύλισης με Πλήκτρα (Slide 27):** Στη μέθοδο `Form1_KeyUp`, ενημερώνεται κατάλληλα η μεταβλητή `scrollPos` με την τρέχουσα θέση κύλισης.
        *   Για παράδειγμα, αν ο χρήστης πατήσει το πλήκτρο "κάτω" ('S' ή Down), η συντεταγμένη Y της `scrollPos` αυξάνεται κατά 1 tile (`scrollPos.Y += 1;`).
        *   Ελέγχονται τα όρια του χάρτη ώστε η `scrollPos` να μην βγει εκτός.

*   **Full-Tile Smooth Scrolling (Slides 28-32):**
    *   Η προηγούμενη μέθοδος κύλισης κατά 1 tile κάθε φορά (πατώντας πλήκτρο) δεν είναι ιδιαίτερα φιλική προς τον παίκτη. Θα ήταν προτιμότερο να έχουμε **συνεχόμενη κύλιση** όσο είναι πατημένο ένα πλήκτρο.
    *   **Υλοποίηση Συνεχόμενης Κύλισης (Slide 29):** Χρειάζεται να χρησιμοποιηθεί μια **μεταβλητή-σημαία** που θα "παρακολουθεί" συνεχώς (π.χ., ανά 20 milliseconds) τα συμβάντα `KeyDown` και `KeyUp` για τα πλήκτρα κίνησης.
    *   **Μεταβλητές (Slide 30):** Δηλώνουμε μια δομή `keyStates` με boolean πεδία (up, down, left, right) για κάθε πλήκτρο, και ένα χρονόμετρο `timer1` (όπως είδαμε στο μάθημα για τον βρόχο παιχνιδιού).
    *   **Αρχικοποίηση & Χειρισμός Συμβάντος `timer1_tick` (Slide 31):** Στη μέθοδο `Form1_Load`, δημιουργείται και αρχικοποιείται το χρονόμετρο `timer1` (π.χ., Interval 20ms). Συνδέεται ο event handler `timer1_tick`. Μέσα στον `timer1_tick`, περιλαμβάνεται κώδικας για τον έλεγχο της μεταβλητής σημαίας και την κύλιση του κόσμου προς την κατάλληλη κατεύθυνση.
    *   **Χειρισμός `KeyDown` και `KeyUp` (Slide 32):** Στις μεθόδους `Form1_KeyDown` και `Form1_KeyUp`, ενημερώνεται κατάλληλα η τιμή της μεταβλητής-σημαίας `keyState` για τα πλήκτρα που ελέγχονται, κάθε φορά που ο παίκτης πατάει ή ελευθερώνει ένα πλήκτρο.

*   **Sub-Tile Smooth Scrolling (Slides 33-35):**
    *   Η κύλιση κατά 1 tile κάθε φορά είναι κατάλληλη για πλοήγηση, αλλά **όχι** για την κίνηση ενός sprite μέσα στον κόσμο. Η κίνηση ενός χαρακτήρα πρέπει να γίνεται πιο αργά, με μεγαλύτερη ακρίβεια και σε μικρότερο αριθμό pixels (π.χ., 1 pixel κάθε φορά).
    *   **Scroll Buffer (Slide 34):** Για να γίνει αυτό, χρειαζόμαστε ένα επιπλέον **buffer (Bitmap)**, εκτός από τον back buffer όπου σχεδιάζουμε τον κόσμο. Αυτός ο buffer ονομάζεται **scroll buffer**.
    *   **Μέγεθος Scroll Buffer (Slide 35):** Το μέγεθος του scroll buffer εξαρτάται από τη διάσταση των tiles (π.χ., 32 pixels). Έχει μεγαλύτερη διάσταση από την οθόνη του παιχνιδιού. Σχεδιάζονται ολόκληρα tiles σε αυτόν, αλλά τη στιγμή που αντιγράφεται ένα κομμάτι στην οθόνη, λαμβάνονται υπόψη τα τμήματα των tiles που δεν εμφανίζονται ολόκληρα.
    *   **Μεταβλητή `subtile` (Slide 35):** Αυτό επιτυγχάνεται με τη χρήση της μεταβλητής `subtile` (τύπου `Point`), η οποία δίνει τις συντεταγμένες της πάνω αριστερής γωνίας από την οποία θα ξεκινήσει η αντιγραφή του περιχομένου του scroll buffer στην οθόνη. Η `subtile` ενημερώνεται κάθε φορά που ο χαρακτήρας κινείται λιγότερο από 1 tile.

