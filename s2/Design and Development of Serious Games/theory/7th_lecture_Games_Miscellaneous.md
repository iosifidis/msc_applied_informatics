# Games Miscellaneous

Η δομή αυτής της ενότητας είναι: **Προσθήκη αντικειμένων κατά την εκτέλεση -> Κίνηση sprites σε κυλιόμενο χάρτη -> Προσθήκη portals**. Θα δούμε πώς οι έννοιες που μάθαμε σε χαμηλό επίπεδο (σχεδίαση, animation, game loop) εφαρμόζονται σε ένα πιο σύνθετο παιχνίδι με κυλιόμενο χάρτη.

---

## Εισαγωγή (Slide 2)

*   Στα παραδείγματα που προηγήθηκαν, εξετάσαμε βασικά στοιχεία προγραμματισμού παιχνιδιών σε απομονωμένες εφαρμογές.
*   Σε αρκετές περιπτώσεις, γράψαμε κώδικα απευθείας στο αρχείο της φόρμας για λόγους απλότητας και εξοικονόμησης χρόνου.
*   Είναι πλέον καιρός να **οργανώσουμε σωστά τον κώδικα σε κλάσεις** (π.χ., κλάση `Game`, κλάση `Level`, κλάση `Sprite`, κλάση `Character`, κλάση `Dialogue`, κλάση `Inventory` κ.λπ.) και να ορίσουμε κατάλληλα τις **συσχετίσεις** τους.
*   Αυτό είναι απαραίτητο για να μπορεί ο κώδικάς μας να είναι **εύκολα επαναχρησιμοποιήσιμος**, κατανοητός και επεκτάσιμος.
*   Μετά από αυτή την οργάνωση, θα είμαστε έτοιμοι να δούμε πώς:
    *   **Προσθέτουμε αντικείμενα** στο παιχνίδι κατά την εκτέλεση (π.χ., δέντρα, εμπόδια, εχθρούς).
    *   **Κινούμε τον ήρωά μας** μέσα στον κυλιόμενο χάρτη.
    *   **Προσθέτουμε portals** (πύλες τηλεμεταφοράς).

---

## Κλάση Game (Slides 3-4)

*   Η κλάση `Game` είναι μια **υποστηρικτική κλάση** που περιλαμβάνει τις βασικές λειτουργίες σχεδίασης και διαχείρισης (όπως είδαμε στο προηγούμενο μάθημα).
*   **Λειτουργικότητα (Slide 3):**
    *   Διατηρεί αναφορές στη φόρμα (`p_frm`) και στο PictureBox (`p_pb`) όπου σχεδιάζονται τα γραφικά.
    *   Παρέχει τον μηχανισμό σχεδίασης (`p_device` - Graphics) σε ένα Bitmap (`p_surface`) που τελικά ενημερώνει την ιδιότητα `Image` του PictureBox.
    *   Παρέχει μέθοδο (`LoadBitmap`) φόρτωσης δεδομένων ενός bitmap.
    *   Παρέχει μεθόδους σχεδίασης bitmaps.
    *   Παρέχει μεθόδους εμφάνισης/σχεδίασης πληροφοριών και ορισμού γραμματοσειράς.
*   **Επιπλέον Μεθόδοι (Slide 4):**
    *   Προσθέτουμε μια μέθοδο (`FrameRate()`) για τον **υπολογισμό του πραγματικού ρυθμού ανανέωσης** των frames.
    *   Προσθέτουμε **2 μεθόδους `Random`** (στο διάστημα 0..max και min..max) για επιστροφή τυχαίου ακέραιου αριθμού.

---

## Κλάση Sprite (Slides 5-6)

*   Η κλάση `Sprite` χρησιμοποιείται για την **αναπαράσταση των sprites** (όπως είδαμε στο προηγούμενο μάθημα).
*   **Λειτουργικότητα (Slide 5):**
    *   Διατηρεί αναφορά στο αντικείμενο της κλάσης `Game` (`p_game`).
    *   Περιλαμβάνει πεδία για την τρέχουσα θέση (`p_position`), το sprite sheet (`p_bitmap`), τον αριθμό frames (`p_totalFrames`), το τρέχον frame (`p_currentFrame`), την κατεύθυνση και την ταχύτητα (`p_velocity`), αν είναι ζωντανό (`p_alive`), κ.α.
    *   Περιλαμβάνει properties για ευκολότερη πρόσβαση/μετάλλαξη των πεδίων.
    *   Το property `Bounds` ενημερώνεται συνεχώς με το πλαίσιο οριοθέτησης του sprite και σε συνδυασμό με τη μέθοδο `IsColliding` χρησιμοποιείται για τον έλεγχο συγκρούσεων.
    *   Περιλαμβάνει μέθοδο `Animate` που εντοπίζει το frame ανάλογα με την κατεύθυνση κίνησης και τον τρόπο επανάληψης.
    *   Περιλαμβάνει μέθοδο `Draw` για τη σχεδίαση του τρέχοντος frame στην κατάλληλη θέση.

*   **Επέκταση της μεθόδου Draw (Slide 6):**
    *   Στην κλάση `Sprite`, προσθέτουμε μια ακόμα έκδοση της μεθόδου `Draw` (`public void Draw(int x, int y)`).
    *   Αυτή η έκδοση **δέχεται τις συντεταγμένες x, y** και σχεδιάζει σε αυτές ένα **αντίγραφο** του sprite.
    *   Η διαφορά είναι ότι **δεν αλλάζει** την εσωτερική θέση του sprite (τις τιμές των πεδίων/properties). Αυτό είναι χρήσιμο για να σχεδιάζουμε ένα sprite σε συγκεκριμένη θέση στην οθόνη, π.χ., για να το τοποθετήσουμε στον κυλιόμενο χάρτη.

---

## Κλάση Level (Slides 7-11)

*   Η κλάση `Level` χρησιμοποιείται για την **αναπαράσταση και διαχείριση των επιπέδων** του παιχνιδιού (όπως είδαμε στο προηγούμενο μάθημα).
*   **Λειτουργικότητα (Slide 7):**
    *   Ενημερώθηκε ο τύπος δομής (`tilemapStruct`) που χρησιμοποιείται στη δήλωση του πίνακα δομών, ώστε να υπάρχει δυνατότητα αποθήκευσης περισσότερων πληροφοριών για κάθε tile (π.χ., ύπαρξη portal).
    *   Ενημερώθηκε η μέθοδος `loadTilemap` ώστε να μεταφέρονται όλες οι πληροφορίες από το αρχείο XML στον πίνακα δομών.
*   **Σύνοψη Βασικών Στοιχείων (Slide 8):** Συνοψίζουμε κάποια βασικά στοιχεία της κλάσης `Level` που αφορούν στη σχεδίαση:
    *   Ο πίνακας δομών (`tilemapStruct[] p_tilemap`) για την αποθήκευση δεδομένων του tilemap.
    *   Ο πίνακας έχει 128x128 στοιχεία (tiles).
    *   Διατηρεί αναφορά στην κλάση `Game` (`p_game`).
    *   Περιλαμβάνει πεδία για τη διάσταση κάθε tile (`p_tileSize`), την παλέτα των tiles (`p_bmpTiles`) & τον αριθμό στηλών της (`p_columns`), τη διάσταση του παραθύρου σε tiles οριζόντια & κατακόρυφα (`p_windowSize`) και του χάρτη/επιπέδου σε pixels οριζόντια και κατακόρυφα (`p_mapSize`).
*   **Βασικές Μέθοδοι (Slide 9):**
    *   `loadTilemap`: Μεταφέρει πληροφορίες από το αρχείο XML στον πίνακα δομών.
    *   `loadPalette`: Ενημερώνει τα σχετικά πεδία με την παλέτα των tiles (bitmap) & τον αριθμό στηλών της παλέτας.
    *   `drawTileNumber`: Δέχεται γραμμή/στήλη και αριθμό tile στην παλέτα και σχεδιάζει το συγκεκριμένο tile στην κατάλληλη θέση.
*   **Scrolling (Slide 10):** Στην περίπτωση που θέλουμε να έχουμε κύλιση, αυτή δεν αφορά παρά σε ένα μικρό αριθμό από pixels και όχι σε ολόκληρο tile (π.χ., 32 pixels κάθε φορά).
*   **Scroll Buffer (Slide 10):** Αυτό επιτυγχάνεται χρησιμοποιώντας έναν **επιπλέον buffer** (Bitmap `p_bmpScrollBuffer`) – έστω scroll buffer – που έχει διάσταση μεγαλύτερη κατά 1 tile οριζόντια και κατακόρυφα σε σχέση με το παράθυρο σχεδίασης.
*   **Μεταβλητές Scrolling (Slide 10):** Χρησιμοποιούνται 3 πεδία τύπου `PointF` για την παρακολούθηση: `p_oldScrollPos` (προηγούμενο σημείο), `p_scrollPos` (τρέχον σημείο), `p_subtile` (μέγεθος sub tiles).
*   **Μέθοδοι Scrolling (Slide 11):**
    *   `Update`: Σχεδιάζει τον scroll buffer και ενημερώνει κατάλληλα τις 3 προαναφερθείς μεταβλητές.
    *   `Draw (με 4 ορίσματα)`: Αντιγράφει το κατάλληλο τμήμα του scroll buffer προκειμένου αυτό τελικά να εμφανιστεί στο παράθυρο του παιχνιδιού.

---

## Ένας Νέος Βρόχος για το Παιχνίδι (Slides 12-15)

*   Είδαμε ότι η χρήση `Timer` για την υλοποίηση του βρόχου παιχνιδιού οδηγεί σε κατάχρηση CPU.
*   Επίσης, ο βρόχος που υλοποιήσαμε στη μέθοδο `Main` της φόρμας είχε το πρόβλημα να "παγώνει" τη φόρμα αν δεν καλούσαμε την `Application.DoEvents()`.
*   **Νέος Βρόχος (Slides 13-14):** Οι αλλαγές που θα κάνουμε στον βρόχο του παιχνιδιού είναι:
    *   Θα προσθέσουμε έναν βρόχο `while` στο συμβάν `From1_Load` της κλάσης `Form1`.
    *   Θα ορίσουμε τη μέθοδο `doUpdate` για να περιλαμβάνει τον κώδικα του βρόχου.
    *   Τα γραφικά του παιχνιδιού θα ενημερώνονται με ρυθμό 60 FPS καλώντας την `Level.Update`.
    *   Για να μην "παγώνει" η φόρμα, θα καλούμε την `Application.DoEvents()`.
    *   Για να μην έχουμε κατάχρηση της CPU, θα χρησιμοποιούμε `Thread.Sleep(1)`.
*   **Κώδικας `doUpdate` (Slide 14):** Ο βασικός κώδικας περιλαμβάνει:
    *   Έλεγχο και ενημέρωση χρονομέτρου (για FPS).
    *   Κλήση `Level.Update` (ενημέρωση scroll buffer και μεταβλητών scrolling).
    *   Κλήση `Level.Draw` (σχεδίαση ορατού τμήματος χάρτη).
    *   Κλήση `DrawTrees` (σχεδίαση δέντρων στο ορατό τμήμα).
    *   Κλήση `game.Print` (εμφάνιση πληροφοριών).
    *   Κλήση `game.Update` (ενημέρωση PictureBox).
    *   Κλήση `Application.DoEvents()`.
    *   Κλήση `Thread.Sleep(1)`.

---

## Προσθήκη Αντικειμένων κατά την Εκτέλεση (Slides 16-22)

*   **Random Tree Demo (Slide 16):** Το παράδειγμα δείχνει πώς μπορούμε να προσθέσουμε αντικείμενα στον κόσμο του παιχνιδιού κατά την εκτέλεση.
*   **Υλοποίηση (Slide 17):**
    *   Χρησιμοποιούμε μια **λίστα** (`List<Sprite> trees`) στην οποία δημιουργούμε και προσθέτουμε 100 δέντρα ως αντικείμενα της κλάσης `Sprite`.
    *   Επιλέγεται τυχαία ένα από τα διαθέσιμα δέντρα ως "κοστούμι" (`treeImage`) και τυχαίες συντεταγμένες στην περιοχή (π.χ., 1000x1000 pixels).
    *   Δημιουργούνται τα αντικείμενα `Sprite` και προστίθενται στη λίστα.
*   **Σχεδίαση Αντικειμένων (Slide 20):** Η μέθοδος `DrawTrees()` διασχίζει τη λίστα των δέντρων. Για κάθε δέντρο, **ελέγχει αν βρίσκεται στο ορατό τμήμα του επιπέδου** και σχεδιάζει το δέντρο (Sprite) στο ορατό τμήμα του επιπέδου του παιχνιδιού (στο παράθυρο) χρησιμοποιώντας την υπερφορτωμένη μέθοδο `Draw(int x, int y)` της κλάσης Sprite.

*   **Ο Κώδικας του Βρόχου (Slides 21-22):**
    *   Η μέθοδος `doUpdate` περιλαμβάνει πλέον κώδικα για την ενημέρωση της κατάστασης των πλήκτρων κύλισης, την ενημέρωση της ιδιότητας `ScrollPos` του `level`, την κλήση `Level.Update`, την κλήση `FrameRate`, την κλήση `Level.Draw`, την κλήση `DrawTrees`, την εμφάνιση πληροφοριών, την ενημέρωση PictureBox, την `Application.DoEvents()` και την `Thread.Sleep(1)`.

---

## Προσθήκη Ελεγχόμενου Κινούμενου Χαρακτήρα (WalkAboutDemo) (Slides 23-27)

*   **WalkAboutDemo (Slide 23):** Το παράδειγμα δείχνει την υλοποίηση ενός ελεγχόμενου κινούμενου χαρακτήρα σε κυλιόμενο χάρτη.
*   **Δήλωση Μεταβλητών & Δημιουργία Sprite (Slide 24):** Δηλώνουμε μεταβλητές για τον χαρακτήρα (`Sprite hero`) και την αρχική του κατεύθυνση (`int heroDir = 0;`). Δημιουργούμε και αρχικοποιούμε το sprite του χαρακτήρα. Τοποθετούμε τον χαρακτήρα στο κέντρο της φόρμας.
*   **Ενημέρωση Μεταβλητών (Slides 25-26):**
    *   Στη μέθοδο `doUpdate` ελέγχεται η κατάσταση των πλήκτρων κύλισης και ενημερώνεται η ιδιότητα `ScrollPos` του αντικειμένου `level` με τις συντεταγμένες του νέου σημείου κύλισης.
    *   Ελέγχεται η κατάσταση των πλήκτρων κύλισης και ενημερώνεται η κατεύθυνση του χαρακτήρα (`heroDir`).
    *   **ΣΗΜΑΝΤΙΚΟ:** Μιας και η κύλιση μέσα στον χάρτη γίνεται βάσει της κίνησης του βασικού ήρωα, πρέπει να φροντίσουμε να ενημερώσουμε τις συντεταγμένες του (`hero.Position`).
    *   **Σχεδίαση Sprite (Slide 27):** Στη μέθοδο `doUpdate` (εντός του χρονομετρούμενου τμήματος) καλείται η μέθοδος `Animate` της κλάσης `Sprite` για την εύρεση του κατάλληλου frame και στη συνέχεια καλείται η μέθοδος `Draw` για τη σχεδίασή του.

---

## Portals (Slides 28-32)

*   **Portal Demo (Slide 28):** Το παράδειγμα δείχνει την υλοποίηση **portals** (πύλες τηλεμεταφοράς).
*   **Ορισμός Portals (Slide 29):** Ο tilemap editor μας δίνει τη δυνατότητα καθορισμού σημείων τηλεμεταφοράς (portals) στο χάρτη του παιχνιδιού (ή και σε άλλο χάρτη/επίπεδο). Τα σχετικά δεδομένα διαβάζονται από το αρχείο XML.
*   **Εντοπισμός Portals (Slide 29):** Αυτό που χρειάζεται να κάνουμε είναι να απομονώσουμε το τμήμα του sprite (τα πόδια του ήρωα) που ακουμπάει στο “έδαφος” για να ελέγχουμε αν βρίσκεται σε ένα portal tile.
*   **Υλοποίηση Portals (Slides 30-32):**
    *   Αν ο ήρωας βρίσκεται σε κάποιο portal, για να τηλεμεταφερθεί πρέπει να πατήσουμε το Space (Slide 30). Θα μπορούσε βέβαια απευθείας να μεταβαίνει στη νέα θέση.
    *   **Έλεγχος Collidable (Slide 31):** Στο κώδικα ελέγχεται επιπλέον η ιδιότητα Collidable για κάθε tile, χωρίς όμως ακόμα ο ήρωας μας να ανταποκρίνεται στα εμπόδια.

