# Collision Detection

Η δομή αυτής της ενότητας είναι: **Αλληλεπίδραση με συμπαγή αντικείμενα -> Τομή πλαισίων (ορθογωνίων) οριοθέτησης -> Έλεγχος συγκρούσεων (collision detection)**. Θα δούμε πώς να ανιχνεύουμε αντικειμενικά αν δύο sprites αλληλεπιδρούν με βάση τα ορθογώνια που τα περιβάλλουν.

---

## Έλεγχος Συγκρούσεων - ShootingGame (Slides 2-3)

*   Το παράδειγμα "ShootingGame" παρουσιάζει ένα απλό παιχνίδι σκοποβολής.
*   **Στόχος:** Ο τοξοβόλος πετάει βέλη με σκοπό να πετύχει διάφορα πλάσματα.
*   **Σύγκρουση:** Κάθε επιτυχημένη βολή (όταν το βέλος "αγγίζει" ένα πλάσμα) δίνει 1 πόντο.
*   **Τερματισμός:** Το παιχνίδι τελειώνει όταν το αποφασίσει ο παίκτης (π.χ., πατώντας ESC), καθώς δεν υπάρχουν αντίπαλοι που να σε κυνηγούν ή χρονικό όριο. Ωστόσο, αντίπαλοι μπορούν εύκολα να προστεθούν!

*   **Σημασία Collision Detection (Slide 3):** Ο έλεγχος συγκρούσεων είναι **απαραίτητος** σε κάθε παιχνίδι και αποτελεί σημαντικό στοιχείο του gameplay.
    *   Χωρίς αυτόν, δεν μπορεί να υπάρξει **αλληλεπίδραση** μεταξύ των sprites (actors ή props).
    *   Δεν αφορά απαραίτητα στην πρόκληση **ζημιάς** (damage) ή στην καταστροφή ενός αντιπάλου/στόχου.
    *   Μπορεί να χρησιμοποιηθεί για να **εμποδίσουμε** τον παίκτη να προχωρήσει σε συγκεκριμένες **μη προσβάσιμες περιοχές** στο παιχνίδι (π.χ., μια λίμνη, ένα απροσπέλαστο βουνό).

---

## Έλεγχος Συγκρούσεων & Πλαίσια Οριοθέτησης (Slides 4-6)

*   Ο έλεγχος σύγκρουσης μεταξύ αντικειμένων πραγματοποιείται εύκολα χρησιμοποιώντας τα **πλαίσια οριοθέτησης** των αντικειμένων-sprites.
*   **Πλαίσιο Οριοθέτησης (Bounding Box) (Slide 4):** Είναι ένα **ορθογώνιο** (αντικείμενο της κλάσης `System.Drawing.Rectangle`) που περιβάλλει ένα αντικείμενο/sprite. Δημιουργείται χρησιμοποιώντας τη **θέση** και το **μέγεθος** του αντικειμένου/sprite.
*   **Δημιουργία Πλαισίου Οριοθέτησης (Slide 5):** Το πλαίσιο οριοθέτησης έχει οριστεί ως **ιδιότητα (Property)** στην κλάση `Sprite` (βλ. προηγούμενο μάθημα, Slide 19).
    *   Η ιδιότητα `Bounds` επιστρέφει ένα αντικείμενο τύπου `Rectangle`.
    *   Αυτό το αντικείμενο `Rectangle` ορίζεται από τις **συντεταγμένες (X, Y)** του **πάνω αριστερού άκρου** του sprite (`p_position.X`, `p_position.Y`), το **πλάτος** (`p_size.Width`) και το **ύψος** (`p_size.Height`) του sprite.

*   **Έλεγχος Τομής Πλαισίων Οριοθέτησης (Slides 4 & 6):**
    *   Αφού δημιουργήσουμε το πλαίσιο οριοθέτησης για δύο αντικείμενα/sprites, ελέγχουμε αν τα δύο ορθογώνια **τέμνονται** (δηλαδή αν επικαλύπτονται) χρησιμοποιώντας τη μέθοδο **`IntersectsWith()`** της κλάσης `Rectangle`.
    *   **Μέθοδος `IsColliding()` (Slide 6):** Για τον έλεγχο σύγκρουσης μεταξύ δύο sprites, ορίζουμε μια μέθοδο `IsColliding(ref Sprite other)`.
        *   Μέσα σε αυτή, ελέγχουμε με τη μέθοδο `IntersectsWith()` αν το πλαίσιο οριοθέτησης (`Bounds`) του sprite για το οποίο καλούμε τη μέθοδο τέμνεται με το πλαίσιο οριοθέτησης (`other.Bounds`) του sprite που περάσαμε ως αναφορά (`other`).
        *   Η μέθοδος `IntersectsWith()` επιστρέφει boolean (true αν τέμνονται, false αλλιώς).

---

## Ο Κώδικας της Φόρμας (ShootingGame) (Slides 7-12)

Στο παράδειγμα ShootingGame, η κλάση `Form1` (η φόρμα Windows Forms) διαχειρίζεται τους διάφορους sprites, τον έλεγχο συγκρούσεων και την ενημέρωση του σκορ.

*   **Μεταβλητές Sprite και Σκορ (Slide 7):** Στον κώδικα της κλάσης `Form1` θα πρέπει να προστεθούν μεταβλητές για να αναπαριστούν τα διάφορα sprites (dragon, zombie, spider, skeleton, archer, arrow) και το σκορ (`int score = 0;`).
*   **Δημιουργία & Αρχικοποίηση Sprites (Slide 8):**
    *   Η μέθοδος `Game_Init()` καλείται πριν την έναρξη του βρόχου του παιχνιδιού (βλ. προηγούμενο μάθημα).
    *   Στη `Game_Init()` δημιουργούνται και αρχικοποιούνται όλα τα sprites.
    *   **Παράδειγμα:** Δημιουργία και αρχικοποίηση του archer (τοξοβόλος) και του arrow (βέλος). Φορτώνονται τα sprite sheets (`LoadBitmap`), δημιουργούνται τα sprites (`new Sprite`), ορίζονται ιδιότητες (μέγεθος, στήλες, frames, animation rate, θέση, ταχύτητα, κατεύθυνση). Το βέλος αρχικά δεν είναι ενεργό (`arrow.Alive = false;`).
*   **Έλεγχος Επιτυχούς Βολής - GameUpdate (Slides 9-10 & 12):**
    *   Η μέθοδος `Game_Update()` εκτελείται επαναληπτικά στο βρόχο του παιχνιδιού (βλ. προηγούμενο μάθημα).
    *   Στη `Game_Update()` περιλαμβάνεται κώδικας για τη συνεχή ενημέρωση της κατάστασης όλων των actors (π.χ., κίνηση) και του σκορ.
    *   Πιο συγκεκριμένα, ελέγχεται αν το βέλος είναι ενεργό (`if (arrow.Alive)`). Αν ναι, ενημερώνεται η θέση του (`arrow.Y += arrow.Velocity.Y;`), σχεδιάζεται (`arrow.Draw();`) και ελέγχεται αν έχει χτυπήσει κάποιο πλάσμα (zombie, spider, skeleton, dragon).
    *   **Έλεγχος Σύγκρουσης (Slide 9):** Για κάθε τύπο πλάσματος, καλείται η μέθοδος `IsColliding()` του βέλους, περνώντας ως όρισμα το αντίστοιχο sprite.
        *   **Παράδειγμα:** Έλεγχος σύγκρουσης με spider: `if (arrow.IsColliding(ref spider))`.
    *   **Συνέπειες Σύγκρουσης (Slide 9):** Αν το βέλος συγκρουστεί με ένα πλάσμα:
        *   Το βέλος γίνεται ανενεργό (`arrow.Alive = false;`).
        *   Το σκορ αυξάνεται κατά 1 (`score++;`).
        *   Το πλάσμα μετακινείται εκτός οθόνης (π.χ., `spider.X = 800;`).
    *   **Σχεδίαση Sprites (Slide 10):** Η μέθοδος `Game_Draw()` σχεδιάζει το background και καλεί τις μεθόδους `Animate()` και `Draw()` για όλα τα sprites που είναι ενεργά.
    *   **Σχεδίαση Πλασμάτων (Slide 12):** Στη `Game_Draw()` υπάρχει κώδικας για τη σχεδίαση των zombies, spiders, skeletons και dragons.

*   **Ρίψη Βέλους - GameKeyPressed (Slide 11):**
    *   Η μέθοδος `Game_KeyPressed()` παρέχει τη δυνατότητα ελέγχου του παιχνιδιού από το πληκτρολόγιο (βλ. προηγούμενο μάθημα).
    *   **Πλήκτρο Space:** Αν πατηθεί το πλήκτρο Space και το βέλος δεν είναι ήδη ενεργό (`if (!arrow.Alive)`), τότε:
        *   Το βέλος γίνεται ενεργό (`arrow.Alive = true;`).
        *   Η θέση του βέλους αρχικοποιείται στην τρέχουσα θέση του archer (`arrow.Position = new PointF(archer.Position.X + 32, archer.Position.Y);`) με ένα offset (+32) για να ξεκινάει από το τόξο.
        *   Η κατεύθυνση animation του archer ορίζεται σε FORWARD (`archer.AnimateDirection = Sprite.AnimateDir.FORWARD;`), ώστε να κάνει την κίνηση βολής (η κίνηση animation ξεκινά από το frame 10).
    *   **Πλήκτρα Κατεύθυνσης (Slide 11):** Τα πλήκτρα κατεύθυνσης (Right, Down, Left) αλλάζουν το πεδίο `direction` του archer.
