# Greenfoot crab lobster

## Greenfoot: Εκπαιδευτικό Περιβάλλον Προγραμματισμού (Slides 2-4)

*   **Τι είναι:** Το Greenfoot είναι ένα **εκπαιδευτικό περιβάλλον προγραμματισμού** ειδικά σχεδιασμένο για τη δημιουργία **παιχνιδιών και προσομοιώσεων** με **2D γραφικά**.
*   **Στόχος:** Απλοποιεί τη διαδικασία δημιουργίας της **γραφικής διασύνδεσης** και τον **προγραμματισμό της συμπεριφοράς των χαρακτήρων** (αντικειμένων).
*   **Βασικές Έννοιες:** Στο Greenfoot, ο κόσμος (η σκηνή/το επίπεδο) και οι χαρακτήρες/αντικείμενα μοντελοποιούνται ως **κλάσεις**. Οι χαρακτήρες/αντικείμενα δημιουργούνται ως **υποκλάσεις** της ενσωματωμένης κλάσης **`Actor`**, ενώ ο κόσμος/επίπεδο δημιουργείται ως **υποκλάση** της ενσωματωμένης κλάσης **`World`**.
*   **Γλώσσα Προγραμματισμού:** Η γλώσσα που χρησιμοποιείται στο Greenfoot είναι η **Java**. Το περιβάλλον παρέχει μια **απλοποιημένη API** για βασικές λειτουργίες παιχνιδιών & προσομοιώσεων.
*   **Σημαντικές Κλάσεις της Greenfoot API (Slide 3):**
    *   `Actor`: Η βάση για όλα τα αντικείμενα (χαρακτήρες, αντικείμενα παιχνιδιού) που ζουν στον κόσμο Greenfoot. Παρέχει μεθόδους όπως `move()`, `turn()`, `getRotation()`, `getX()`, `getY()`, `setLocation()`, `isTouching()`, `getOneIntersectingObject()`, `getObjectsInRange()`, `getWorld()`.
    *   `Greenfoot`: Παρέχει static μεθόδους για τον έλεγχο της προσομοίωσης/παιχνιδιού και την αλληλεπίδραση με το σύστημα. Παραδείγματα: `isKeyDown()`, `playSound()`, `stop()`, `getRandomNumber()`.
    *   `GreenfootImage`: Αναπαριστά μια εικόνα που μπορεί να εμφανιστεί στην οθόνη.
    *   `GreenfootSound`: Αναπαριστά ήχο που μπορεί να παιχτεί.
    *   `MouseInfo`: Παρέχει πληροφορίες για την τρέχουσα κατάσταση του ποντικιού.
    *   `UserInfo`: Μπορεί να χρησιμοποιηθεί για αποθήκευση δεδομένων χρήστη (π.χ. σκορ) μόνιμα σε server.
    *   `World`: Αναπαριστά τον κόσμο (επίπεδο) όπου ζουν οι `Actor`s. Παρέχει μεθόδους όπως `addObject()`, `removeObject()`, `getObjects()`, `getHeight()`, `getWidth()`.

*   **Δυνατότητες Χρήστη (Slide 4):**
    *   **Δημοσίευση:** Μπορείτε να δημοσιεύσετε τα έργα σας στην online gallery του Greenfoot.
    *   **Εξαγωγή ως αυτόνομη εφαρμογή (.jar file):** Προσοχή! Αυτή η λειτουργία **δεν δουλεύει σωστά** αν δεν υπάρχει εγκατεστημένη **Java 11+** στο σύστημα που τρέχει την εφαρμογή. Υπάρχουν περιορισμοί που αναφέρονται στο https://www.greenfoot.org/doc/run_standalone. Για να μετατρέψετε το `.jar` σε `.exe` που ενσωματώνει το JRE (Java Runtime Environment), μπορείτε να δείτε το YouTube video: https://www.youtube.com/watch?v=h68WlAn_Vfg.
    *   **Εξαγωγή ως αρχείο project (.gfar):** Αυτό είναι το προτεινόμενο format για να μοιραστείτε το project σας με άλλους χρήστες του Greenfoot.

---

## Ανάπτυξη Ενός Απλού Παιχνιδιού: Crabs, Worms and Lobsters

Θα δημιουργήσουμε βήμα προς βήμα ένα απλό παιχνίδι όπου ένας κάβουρας προσπαθεί να φάει σκουλήκια αποφεύγοντας αστακούς.

*   **Εισαγωγή στο Παιχνίδι (Slide 5):** Θα ξεκινήσουμε παίζοντας την τελική έκδοση του παιχνιδιού για να καταλάβουμε τους κανόνες και τη λογική του.
*   **Δημιουργία Νέου Project (Slide 6):**
    *   Όταν δημιουργείτε ένα νέο project, υπάρχει ήδη μια default υποκλάση της `World` με όνομα `MyWorld`. Αυτή αποτελεί το πρώτο επίπεδο του παιχνιδιού μας.
    *   **Αλλαγή Φόντου:** Κάντε δεξί κλικ στο ορθογώνιο της κλάσης `MyWorld`, επιλέξτε `Set Image...` και διαλέξτε το φόντο που θέλετε (π.χ., `sand.jpg` από τα `backgrounds` στην library).
    *   **Επεξεργασία Κώδικα:** Με διπλό κλικ στην κλάση ανοίγει ο editor για να επεξεργαστείτε τον κώδικα. Μπορείτε να αλλάξετε και το όνομα της κλάσης.
    *   **Διαγραφή Κλάσης:** Με δεξί κλικ στην κλάση και επιλογή `Remove`, μπορείτε να τη διαγράψετε.

*   **Δημιουργία Υποκλάσης World για το Επίπεδο (Slide 7):**
    *   Με δεξί κλικ στο εικονίδιο της υπερκλάσης `World` και επιλογή `New Subclass...`, μπορείτε να δημιουργήσετε μια νέα υποκλάση (ένα νέο επίπεδο). Στο παράδειγμά μας, θα τη ονομάσουμε `CrabWorld`.

*   **Καθορισμός Διάστασης Κόσμου (Slide 8):**
    *   Στον **κατασκευαστή** της κλάσης `CrabWorld`, καλείται η μέθοδος `super(width, height, cellsize)`.
    *   `width`, `height`: Ορίζουν τις διαστάσεις του κόσμου σε **μονάδες κελιών**.
    *   `cellsize`: Ορίζει το μέγεθος κάθε κελιού σε **pixels**.
    *   Στο παράδειγμα: `super(600, 400, 1)` δημιουργεί έναν κόσμο 600x400 pixels (με μέγεθος κελιού 1x1 pixel).

*   **Οι Χαρακτήρες του Παιχνιδιού (Slide 9 & 10):**
    *   **Κάβουρας:** Κινείται/Στρίβει ελεγχόμενος από τον παίκτη, εντοπίζει όρια κόσμου, ελέγχει αν υπάρχει σκουλήκι/αστακός, τρώει σκουλήκι (αυξάνει σκορ), τρώει καβούρι (τερματίζει - για τον αστακό).
    *   **Αστακός:** Κινείται/Στρίβει τυχαία, εντοπίζει όρια κόσμου, ελέγχει αν υπάρχει καβούρι, τρώει καβούρι (τερματίζει).
    *   **Σκουλήκι:** Παραμένει στη θέση του.
    *   **Κοινές Λειτουργίες/Συμπεριφορές:** Κάβουρας και Αστακός έχουν πολλά κοινά σημεία (έλεγχος ορίων, έλεγχος αντικειμένου, "φάγωμα"). Αυτό υποδεικνύει τη χρήση **κληρονομικότητας** στον αντικειμενοστρεφή σχεδιασμό. Θα ορίσουμε μια **υπερκλάση `Animal`** (υποκλάση της `Actor`) για να υλοποιήσουμε τις κοινές μεθόδους, και οι κλάσεις `Crab` και `Lobster` θα είναι υποκλάσεις της `Animal`.

*   **Ορισμός Υπερκλάσης Animal (Slide 11):**
    *   Θα ορίσουμε την κλάση `Animal` ως υποκλάση της `Actor`.
    *   **Ιδιότητες/Πεδία:** `WALKING_SPEED` (σταθερά για την ταχύτητα κίνησης σε pixels/βήμα).
    *   **Λειτουργίες/Μέθοδοι:**
        *   `turn(int angle)`: Στροφή κατά 'angle' μοίρες.
        *   `move()`: Μετακίνηση προς την τρέχουσα κατεύθυνση κατά `WALKING_SPEED` pixels.
        *   `atWorldEdge()`: Έλεγχος εντοπισμού των ορίων του κόσμου.
        *   `canSee(Class clss)`: Έλεγχος ύπαρξης αντικειμένου ενός συγκεκριμένου τύπου στην τρέχουσα θέση.
        *   `eat(Class clss)`: Ένα ζώο τρώει κάποιο άλλο που βρίσκεται στην ίδια θέση.

*   **Υλοποίηση Μεθόδων στην κλάση Animal (Slides 12-17):**
    *   **`turn(int angle)` (Slide 12):** Χρησιμοποιεί την ενσωματωμένη μέθοδο `setRotation(getRotation() + angle)` της κλάσης `Actor`. Η `getRotation()` επιστρέφει την τρέχουσα περιστροφή.
    *   **`move()` (Slides 13-14):** Υπολογίζει τη νέα θέση (x, y) βασιζόμενη στην τρέχουσα θέση (`getX()`, `getY()`), την κατεύθυνση (`getRotation()`, μετατρέπεται σε ακτίνια με `Math.toRadians`) και την ταχύτητα (`WALKING_SPEED`) χρησιμοποιώντας τριγωνομετρία (`Math.cos`, `Math.sin`). Η νέα θέση ορίζεται με `setLocation(x, y)`. Η `Math.round` χρησιμοποιείται για να μετατρέψει το αποτέλεσμα σε ακέραιο pixel.
    *   **`atWorldEdge()` (Slide 15):** Ελέγχει αν η θέση του αντικειμένου (`getX()`, `getY()`) βρίσκεται κοντά στα όρια του κόσμου (`getWorld().getWidth()`, `getWorld().getHeight()`). Επιστρέφει `true` αν είναι κοντά στο όριο, `false` αλλιώς.
    *   **`canSee(Class clss)` (Slide 16):** Χρησιμοποιεί την ενσωματωμένη μέθοδο `getOneObjectAtOffset(0, 0, clss)` της κλάσης `Actor` για να ελέγξει αν υπάρχει αντικείμενο του τύπου `clss` στην τρέχουσα θέση (offset 0,0). Επιστρέφει `true` αν βρεθεί αντικείμενο, `false` αλλιώς.
    *   **`eat(Class clss)` (Slide 17):** Χρησιμοποιεί τη `canSee` (ή απευθείας την `getOneObjectAtOffset`). Αν βρεθεί αντικείμενο του τύπου `clss`, το αφαιρεί από τον κόσμο χρησιμοποιώντας την ενσωματωμένη μέθοδο `getWorld().removeObject(actor)` της κλάσης `World`.

*   **Είναι απαραίτητος ο ορισμός της υπερκλάσης Animal ??? (Slide 18):**
    *   Όπως είδαμε, η κλάση `Actor` παρέχει ήδη μεθόδους όπως `turn()`.
    *   **ΣΗΜΑΝΤΙΚΟ:** Το Greenfoot παρέχει μια **προ-ορισμένη κλάση `Animal`** που **ήδη υλοποιεί** τις μεθόδους `move()`, `atWorldEdge()`, `canSee()`, `eat()`.
    *   Δεν χρειάζεται να γράψουμε εμείς τον κώδικα για αυτές τις μεθόδους! Αρκεί να εισάγουμε την έτοιμη κλάση `Animal`. Κάντε `Edit -> Import Class...` και επιλέξτε `animal` από τη λίστα. Τώρα μπορείτε να ορίσετε τις κλάσεις `Crab` και `Lobster` ως υποκλάσεις της **εισαχθείσας** κλάσης `Animal`.

*   **Ορισμός κλάσης Worm (Slide 19):**
    *   Δημιουργήστε την κλάση `Worm` ως υποκλάση της `Animal`.
    *   Προς το παρόν, τα σκουλήκια απλώς κάθονται και περιμένουν να φαγωθούν.
    *   Κληρονομούν τις μεθόδους από τις κλάσεις `Animal` και `Actor`.

*   **Προσθήκη σκουληκιών στο παιχνίδι (Slide 20):**
    *   Επιλέξτε την κλάση `Worm`.
    *   Κάντε δεξί κλικ στην κλάση `Worm` και επιλέξτε `new Worm()`. Στη συνέχεια κάντε κλικ στην περιοχή του κόσμου όπου θέλετε να εμφανιστεί το σκουλήκι.
    *   Για να προσθέσετε πολλά σκουλήκια γρήγορα, κρατήστε πατημένο το πλήκτρο **Shift** και κάντε κλικ στις επιθυμητές θέσεις.
    *   **Αποθήκευση:** Με δεξί κλικ στην περιοχή του παιχνιδιού και επιλογή `Save World`, αποθηκεύετε την τρέχουσα κατάσταση του κόσμου.

*   **Ορισμός κλάσης Crab (Slide 21):**
    *   Δημιουργήστε την κλάση `Crab` ως υποκλάση της `Animal`.
    *   **Ιδιότητες/Πεδία:** `wormsEaten` (μετρά τα σκουλήκια που έχει φάει ο κάβουρας).
    *   **Λειτουργίες/Μέθοδοι:**
        *   `checkKeypress()`: Ελέγχει τα πλήκτρα αριστερά/δεξιά και στρίβει τον κάβουρα.
        *   `lookForWorm()`: Ψάχνει για σκουλήκι στην τρέχουσα θέση, το τρώει, αυξάνει το σκορ και ελέγχει αν ο παίκτης κέρδισε.
        *   `act()`: Η βασική μέθοδος συμπεριφοράς, καλείται συνεχώς. Καλεί τις `checkKeypress`, `move` (κληρονομημένη), `lookForWorm`.
    *   **Συνθήκη Νίκης:** Ο παίκτης κερδίζει αν ο κάβουρας φάει **8 σκουλήκια**.

*   **Υλοποίηση Μεθόδων στην κλάση Crab:**
    *   **`checkKeypress()` (Slide 22):** Χρησιμοποιεί `Greenfoot.isKeyDown("left")` και `Greenfoot.isKeyDown("right")` για να ελέγξει αν πατιούνται τα αριστερά/δεξιά βελάκια. Αν ναι, καλεί την κληρονομημένη μέθοδο `turn()` με κατάλληλη γωνία (-4 για αριστερά, 4 για δεξιά).
    *   **`lookForWorm()` (Slide 23):** Χρησιμοποιεί την κληρονομημένη μέθοδο `canSee(Worm.class)` για να ελέγξει αν υπάρχει σκουλήκι. Αν βρεθεί:
        *   Καλεί την κληρονομημένη μέθοδο `eat(Worm.class)`.
        *   Παίζει έναν ήχο (`Greenfoot.playSound("slurp.wav")`).
        *   Αυξάνει την ιδιότητα `wormsEaten`.
        *   Ελέγχει αν `wormsEaten == 8`. Αν ναι (συνθήκη νίκης):
            *   Παίζει έναν ήχο (`Greenfoot.playSound("fanfare.wav")`).
            *   Σταματά την προσομοίωση (`Greenfoot.stop()`).

*   **Βασική συμπεριφορά καβουριού - act() (Slide 24):**
    *   Η μέθοδος `act()` υλοποιεί τον βασικό βρόχο συμπεριφοράς του αντικειμένου. Καλείται αυτόματα κάθε φορά που πατιέται το κουμπί 'Act' ή 'Run' στο περιβάλλον.
    *   Στην `act()` του κάβουρα καλούνται: `checkKeypress()`, `move()` (κληρονομημένη), `lookForWorm()`.

*   **Προσθήκη καβουριού στο παιχνίδι (Slide 25):**
    *   Όπως κάναμε με τα σκουλήκια, δημιουργήστε ένα στιγμιότυπο της κλάσης `Crab` (`new Crab()`) και τοποθετήστε το στον κόσμο. Τώρα μπορείτε να δοκιμάσετε την πρώτη έκδοση του παιχνιδιού!

*   **Βελτιώνοντας την κίνηση του καβουριού (Slide 25 & 26):**
    *   Για πιο φυσική κίνηση, μπορούμε να χρησιμοποιήσουμε animation εναλλάσσοντας δύο εικόνες του κάβουρα (μία με τα πόδια μέσα, μία με τα πόδια έξω).
    *   Προσθέστε δύο ιδιότητες τύπου `GreenfootImage` (`image1`, `image2`) στην κλάση `Crab`.
    *   Στον κατασκευαστή της κλάσης `Crab`, φορτώστε τις δύο εικόνες (`"crab.png"`, `"crab2.png"`) στις ιδιότητες. Αρχικά, ορίστε την εικόνα του αντικειμένου στην `image1` με `setImage(image1)`.
    *   Προσθέστε μια μέθοδο `switchImage()` που εναλλάσσει την εικόνα του αντικειμένου μεταξύ `image1` και `image2` χρησιμοποιώντας την `setImage()`. Ελέγχει ποια είναι η τρέχουσα εικόνα με την `getImage()`.
    *   Προσθέστε μια κλήση στη μέθοδο `switchImage()` μέσα στη μέθοδο `act()` του κάβουρα, ώστε η εικόνα να αλλάζει σε κάθε βήμα.

*   **Προσθήκη αντίπαλου - Ορισμός κλάσης Lobster (Slides 27 & 28):**
    *   Δημιουργήστε την κλάση `Lobster` ως υποκλάση της `Animal`.
    *   **Λειτουργίες/Μέθοδοι:**
        *   `turnAtEdge()`: Στρίβει αν είναι στα όρια του κόσμου.
        *   `randomTurn()`: Στρίβει τυχαία (ή όχι).
        *   `lookForCrab()`: Ελέγχει αν υπάρχει καβούρι στην τρέχουσα θέση και αν ναι, το τρώει και τερματίζει το παιχνίδι (συνθήκη ήττας).
        *   `act()`: Η βασική μέθοδος συμπεριφοράς. Καλεί τις `turnAtEdge`, `randomTurn`, `move` (κληρονομημένη), `lookForCrab`.

*   **Υλοποίηση Μεθόδων στην κλάση Lobster:**
    *   **`turnAtEdge()` (Slide 29):** Χρησιμοποιεί την κληρονομημένη μέθοδο `atWorldEdge()`. Αν επιστρέψει `true`, καλεί την κληρονομημένη μέθοδο `turn()` με μια σταθερή γωνία (π.χ., 17 μοίρες).
    *   **`randomTurn()` (Slide 30):** Χρησιμοποιεί `Greenfoot.getRandomNumber(100)` για να δημιουργήσει έναν τυχαίο αριθμό μεταξύ 0 (inclusive) και 100 (exclusive). Αν ο αριθμός είναι > 90 (10% πιθανότητα), καλεί την κληρονομημένη μέθοδο `turn()` με έναν τυχαίο αριθμό από -45 έως +45 μοίρες (`Greenfoot.getRandomNumber(90)-45`).
    *   **`lookForCrab()` (Slide 31):** Χρησιμοποιεί την κληρονομημένη μέθοδο `canSee(Crab.class)`. Αν βρεθεί καβούρι:
        *   Καλεί την κληρονομημένη μέθοδο `eat(Crab.class)`.
        *   Παίζει έναν ήχο (`Greenfoot.playSound("au.wav")`).
        *   Σταματά την προσομοίωση (`Greenfoot.stop()`).

*   **Βασική συμπεριφορά αστακού - act() (Slide 32):**
    *   Η μέθοδος `act()` του αστακού καλεί τις: `turnAtEdge()`, `randomTurn()`, `move()` (κληρονομημένη), `lookForCrab()`.

---

## Προσθήκη Επιπέδων (Levels) (Slides 33-38)

*   **Δημιουργία 2ου Επιπέδου (Slide 33):**
    *   Για να έχουμε περισσότερα επίπεδα, δημιουργήστε μια **2η υποκλάση της `World`**, π.χ., `CrabWorld2`.
    *   Το 2ο επίπεδο μπορεί να είναι πιο δύσκολο (π.χ., περισσότεροι εχθροί, μικρότερη περιοχή).
    *   Μπορείτε να δημιουργήσετε ένα **στιγμιότυπο** της νέας κλάσης `CrabWorld2` με δεξί κλικ πάνω της και επιλογή `new CrabWorld2()`.
    *   Μην ξεχνάτε να αποθηκεύετε την κατάσταση του κόσμου! Για να επιστρέψετε/επεξεργαστείτε το 1ο επίπεδο, απλά δημιουργήστε ένα στιγμιότυπο της κλάσης `CrabWorld`.

*   **Μετακίνηση Πρωταγωνιστή μεταξύ Επιπέδων (Slides 35-36):**
    *   Αφού υπάρχουν πλέον επίπεδα, ο πρωταγωνιστής (κάβουρας) πρέπει να μπορεί να μεταφέρεται από το ένα επίπεδο στο άλλο.
    *   Ο κάβουρας θα πρέπει να **περνάει ως όρισμα** στον κατασκευαστή του *επόμενου* επιπέδου.
    *   Αυτό απαιτεί αλλαγή στον **κατασκευαστή** της κλάσης `CrabWorld2` ώστε να δέχεται ένα αντικείμενο `Crab` ως παράμετρο: `public CrabWorld2(Crab crab)`.
    *   Μέσα στον κατασκευαστή της `CrabWorld2`, καλείται ο `super()` constructor για να οριστεί η διάσταση του κόσμου. Στη συνέχεια, στην μέθοδο `prepare` (η οποία καλείται από τον κατασκευαστή), αντί να δημιουργείται νέο στιγμιότυπο κάβουρα, **προστίθεται στον κόσμο το αντικείμενο `crab`** που περάστηκε ως παράμετρος: `addObject(crab, 308, 303);`.

*   **Παρακολούθηση/Αλλαγή Επιπέδων στον Crab (Slides 35 & 37-38):**
    *   Ο κάβουρας πρέπει να "γνωρίζει" σε ποιο επίπεδο βρίσκεται. Προσθέστε μια ιδιότητα/πεδίο `private int level;` στην κλάση `Crab`.
    *   Στον κατασκευαστή της `Crab`, αρχικοποιήστε το `level` στο 1 (`level = 1;`).
    *   Προσθέστε μια μέθοδο `checkNextLevel()` στην κλάση `Crab` που ελέγχει αν ο κάβουρας πρέπει να προχωρήσει στο επόμενο επίπεδο.
    *   Καλέστε τη μέθοδο `checkNextLevel()` μέσα στη μέθοδο `act()` του κάβουρα.
    *   **Υλοποίηση `checkNextLevel()` (Slide 38):**
        *   Ελέγχει αν η τρέχουσα κατάσταση ικανοποιεί τη συνθήκη μετάβασης στο επόμενο επίπεδο (π.χ., `level == 1 && wormsEaten == 8`).
        *   Αν ναι, ενημερώνει το `level` (`level = 2;`), μηδενίζει το `wormsEaten` (`wormsEaten = 0;`), αφαιρεί τον κάβουρα από τον τρέχοντα κόσμο (`getWorld().removeObject(this);`), παίζει ήχο και, το σημαντικότερο, **αλλάζει τον κόσμο** θέτοντας ως νέο ενεργό κόσμο ένα **νέο στιγμιότυπο της κλάσης `CrabWorld2`**, περνώντας τον εαυτό του (`this`) ως όρισμα: `Greenfoot.setWorld(new CrabWorld2(this));`.
        *   Προσθέστε έλεγχο για τη συνθήκη νίκης στο 2ο επίπεδο (π.χ., `level == 2 && wormsEaten == 8`). Αν ναι, εμφανίζει μήνυμα νίκης (`winMessage()`) και σταματά το παιχνίδι (`Greenfoot.stop()`).
        *   Η μέθοδος `winMessage()` είναι βοηθητική για να γράψει το μήνυμα "WINNER" χρησιμοποιώντας `GreenfootImage` και `Font`.

---

## Επεκτάσεις (Challenges) (Slides 39-40)

Αυτές είναι προαιρετικές ασκήσεις για εξάσκηση και περαιτέρω ανάπτυξη του παιχνιδιού:

*   **Challenge 1 (Slide 39):**
    *   Προσθέστε έλεγχο κίνησης για πάνω/κάτω στον κάβουρα μέσω πληκτρολογίου (χρησιμοποιώντας `Greenfoot.isKeyDown`).
    *   Υλοποιήστε ένα "πηδηματάκι" προς τα πίσω (10 pixels) όταν ο κάβουρας συναντά αστακό, πατώντας ένα πλήκτρο (π.χ., 'j').
    *   Σκεφτείτε και άλλες λειτουργίες ελεγχόμενες από πληκτρολόγιο.
*   **Challenge 2 (Slide 39):**
    *   Τροποποιήστε τη μέθοδο `prepare` του **πρώτου** επιπέδου (`CrabWorld`) ώστε να προσθέτει **τυχαίο** αριθμό σκουληκιών (μεταξύ 8 και 30) και αστακών (μεταξύ 1 και 3) σε **τυχαίες** θέσεις. Χρησιμοποιήστε την μέθοδο `Greenfoot.getRandomNumber`.
*   **Challenge 3 (Slide 39):**
    *   Δώστε στα σκουλήκια κάποιο **εφέ κίνησης** (παραμένοντας στη θέση τους).
    *   Υλοποιήστε τη **δυναμική εμφάνιση νέων σκουληκιών** όταν ο κάβουρας τρώει κάποια, ή σε τυχαίες χρονικές στιγμές.
*   **Challenge 4 (Slide 40):**
    *   Υλοποιήστε **παιχνίδι 2 παικτών**: ένας ελέγχει τον κάβουρα, ο άλλος τον αστακό, με ξεχωριστά πλήκτρα για τον καθένα. Θα υπάρχει πάντα ένας κάβουρας και ένας αστακός.
*   **Challenge 5 (Slide 40):**
    *   Προσθέστε **εμπόδια** (π.χ., βράχους, θάμνους - ως νέα υποκλάση της `Actor` με εικόνα) όπου ο κάβουρας μπορεί να κρυφτεί από τον αστακό (ο αστακός δεν τον τρώει αν κρύβεται). Προσθέστε τυχαίο αριθμό εμποδίων (όχι πάνω από 3).
*   **Challenge 6 (Slide 40):**
    *   Υλοποιήστε μια **ποινή** όταν οι χαρακτήρες αγγίζουν τα όρια του κόσμου (αν υπάρχουν 2 παίκτες, όπως στο Challenge 4).
    *   Όταν ο κάβουρας αγγίζει τα όρια: χάνει 1 πόντο, αλλά εμφανίζεται ένα νέο σκουλήκι.
    *   Όταν ο αστακός αγγίζει τα όρια: κερδίζει 1 πόντο στο σκορ του κάβουρα (δηλαδή, το σκορ του κάβουρα αυξάνεται κατά 1). Θα χρειαστεί να διαχειριστείτε ένα score system (π.χ., μια κλάση `Counter` ή μια ιδιότητα στην `World` κλάση).
