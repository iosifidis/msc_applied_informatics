# Greenfoot crab lobster

## Greenfoot: Εκπαιδευτικό Περιβάλλον Προγραμματισμού (Slides 2-4)

- **Τι είναι:** Το Greenfoot είναι ένα **εκπαιδευτικό περιβάλλον προγραμματισμού** ειδικά σχεδιασμένο για τη δημιουργία **παιχνιδιών και προσομοιώσεων** με **2D γραφικά**.
- **Στόχος:** Απλοποιεί τη διαδικασία δημιουργίας της **γραφικής διασύνδεσης** και τον **προγραμματισμό της συμπεριφοράς των χαρακτήρων** (αντικειμένων).
- **Βασικές Έννοιες:** Στο Greenfoot, ο κόσμος (η σκηνή/το επίπεδο) και οι χαρακτήρες/αντικείμενα μοντελοποιούνται ως **κλάσεις**. Οι χαρακτήρες/αντικείμενα δημιουργούνται ως **υποκλάσεις** της ενσωματωμένης κλάσης **`Actor`**, ενώ ο κόσμος/επίπεδο δημιουργείται ως **υποκλάση** της ενσωματωμένης κλάσης **`World`**.
- **Γλώσσα Προγραμματισμού:** Η γλώσσα που χρησιμοποιείται στο Greenfoot είναι η **Java**. Το περιβάλλον παρέχει μια **απλοποιημένη API** για βασικές λειτουργίες παιχνιδιών & προσομοιώσεων.
- **Σημαντικές Κλάσεις της Greenfoot API (Slide 3):**

  - `Actor`: Η βάση για όλα τα αντικείμενα (χαρακτήρες, αντικείμενα παιχνιδιού) που ζουν στον κόσμο Greenfoot. Παρέχει μεθόδους όπως `move()`, `turn()`, `getRotation()`, `getX()`, `getY()`, `setLocation()`, `isTouching()`, `getOneIntersectingObject()`, `getObjectsInRange()`, `getWorld()`.
  - `Greenfoot`: Παρέχει static μεθόδους για τον έλεγχο της προσομοίωσης/παιχνιδιού και την αλληλεπίδραση με το σύστημα. Παραδείγματα: `isKeyDown()`, `playSound()`, `stop()`, `getRandomNumber()`.
  - `GreenfootImage`: Αναπαριστά μια εικόνα που μπορεί να εμφανιστεί στην οθόνη.
  - `GreenfootSound`: Αναπαριστά ήχο που μπορεί να παιχτεί.
  - `MouseInfo`: Παρέχει πληροφορίες για την τρέχουσα κατάσταση του ποντικιού.
  - `UserInfo`: Μπορεί να χρησιμοποιηθεί για αποθήκευση δεδομένων χρήστη (π.χ. σκορ) μόνιμα σε server.
  - `World`: Αναπαριστά τον κόσμο (επίπεδο) όπου ζουν οι `Actor`s. Παρέχει μεθόδους όπως `addObject()`, `removeObject()`, `getObjects()`, `getHeight()`, `getWidth()`.

- **Δυνατότητες Χρήστη (Slide 4):**
  - **Δημοσίευση:** Μπορείτε να δημοσιεύσετε τα έργα σας στην online gallery του Greenfoot.
  - **Εξαγωγή ως αυτόνομη εφαρμογή (.jar file):** Προσοχή! Αυτή η λειτουργία **δεν δουλεύει σωστά** αν δεν υπάρχει εγκατεστημένη **Java 11+** στο σύστημα που τρέχει την εφαρμογή. Υπάρχουν περιορισμοί που αναφέρονται στο https://www.greenfoot.org/doc/run_standalone. Για να μετατρέψετε το `.jar` σε `.exe` που ενσωματώνει το JRE (Java Runtime Environment), μπορείτε να δείτε το YouTube video: https://www.youtube.com/watch?v=h68WlAn_Vfg.
  - **Εξαγωγή ως αρχείο project (.gfar):** Αυτό είναι το προτεινόμενο format για να μοιραστείτε το project σας με άλλους χρήστες του Greenfoot.

---

## Ανάπτυξη Ενός Απλού Παιχνιδιού: Crabs, Worms and Lobsters

Θα δημιουργήσουμε βήμα προς βήμα ένα απλό παιχνίδι όπου ένας κάβουρας προσπαθεί να φάει σκουλήκια αποφεύγοντας αστακούς.

- **Εισαγωγή στο Παιχνίδι (Slide 5):** Θα ξεκινήσουμε παίζοντας την τελική έκδοση του παιχνιδιού για να καταλάβουμε τους κανόνες και τη λογική του.
- **Δημιουργία Νέου Project (Slide 6):**

  - Όταν δημιουργείτε ένα νέο project, υπάρχει ήδη μια default υποκλάση της `World` με όνομα `MyWorld`. Αυτή αποτελεί το πρώτο επίπεδο του παιχνιδιού μας.
  - **Αλλαγή Φόντου:** Κάντε δεξί κλικ στο ορθογώνιο της κλάσης `MyWorld`, επιλέξτε `Set Image...` και διαλέξτε το φόντο που θέλετε (π.χ., `sand.jpg` από τα `backgrounds` στην library).
  - **Επεξεργασία Κώδικα:** Με διπλό κλικ στην κλάση ανοίγει ο editor για να επεξεργαστείτε τον κώδικα. Μπορείτε να αλλάξετε και το όνομα της κλάσης.
  - **Διαγραφή Κλάσης:** Με δεξί κλικ στην κλάση και επιλογή `Remove`, μπορείτε να τη διαγράψετε.

- **Δημιουργία Υποκλάσης World για το Επίπεδο (Slide 7):**

  - Με δεξί κλικ στο εικονίδιο της υπερκλάσης `World` και επιλογή `New Subclass...`, μπορείτε να δημιουργήσετε μια νέα υποκλάση (ένα νέο επίπεδο). Στο παράδειγμά μας, θα τη ονομάσουμε `CrabWorld`.

- **Καθορισμός Διάστασης Κόσμου (Slide 8):**
  - Στον **κατασκευαστή** της κλάσης `CrabWorld`, καλείται η μέθοδος `super(width, height, cellsize)`.
  - `width`, `height`: Ορίζουν τις διαστάσεις του κόσμου σε **μονάδες κελιών**.
  - `cellsize`: Ορίζει το μέγεθος κάθε κελιού σε **pixels**.
  - Στο παράδειγμα: `super(600, 400, 1)` δημιουργεί έναν κόσμο 600x400 pixels (με μέγεθος κελιού 1x1 pixel).

```java
// Στην κλάση CrabWorld
import greenfoot.*; // (World, Actor, GreenfootImage, Greenfoot and MouseInfo)

public class CrabWorld extends World
{
    /**
     * Constructor for objects of class CrabWorld.
     *
     */
    public CrabWorld()
    {
        // Create a new world with 600x400 cells with a cell size of 1x1 pixels.
        // Διάσταση του κόσμου 600x400 κελιά με μέγεθος κελιού 1x1 pixels.
        super(600, 400, 1);
    }
}
```

- **Οι Χαρακτήρες του Παιχνιδιού (Slide 9 & 10):**

  - **Κάβουρας:** Κινείται/Στρίβει ελεγχόμενος από τον παίκτη, εντοπίζει όρια κόσμου, ελέγχει αν υπάρχει σκουλήκι/αστακός, τρώει σκουλήκι (αυξάνει σκορ), τρώει καβούρι (τερματίζει - για τον αστακό).
  - **Αστακός:** Κινείται/Στρίβει τυχαία, εντοπίζει όρια κόσμου, ελέγχει αν υπάρχει καβούρι, τρώει καβούρι (τερματίζει).
  - **Σκουλήκι:** Παραμένει στη θέση του.
  - **Κοινές Λειτουργίες/Συμπεριφορές:** Κάβουρας και Αστακός έχουν πολλά κοινά σημεία (έλεγχος ορίων, έλεγχος αντικειμένου, "φάγωμα"). Αυτό υποδεικνύει τη χρήση **κληρονομικότητας** στον αντικειμενοστρεφή σχεδιασμό. Θα ορίσουμε μια **υπερκλάση `Animal`** (υποκλάση της `Actor`) για να υλοποιήσουμε τις κοινές μεθόδους, και οι κλάσεις `Crab` και `Lobster` θα είναι υποκλάσεις της `Animal`.

- **Ορισμός Υπεκλάσης Animal (Slide 11):**

  - Θα ορίσουμε την κλάση `Animal` ως υποκλάση της `Actor`.
  - **Ιδιότητες/Πεδία:** `WALKING_SPEED` (σταθερά για την ταχύτητα κίνησης σε pixels/βήμα).
  - **Λειτουργίες/Μέθοδοι:**
    - `turn(int angle)`: Στροφή κατά 'angle' μοίρες.
    - `move()`: Μετακίνηση προς την τρέχουσα κατεύθυνση κατά `WALKING_SPEED` pixels.
    - `atWorldEdge()`: Έλεγχος εντοπισμού των ορίων του κόσμου.
    - `canSee(Class clss)`: Έλεγχος ύπαρξης αντικειμένου ενός συγκεκριμένου τύπου στην τρέχουσα θέση.
    - `eat(Class clss)`: Ένα ζώο τρώει κάποιο άλλο που βρίσκεται στην ίδια θέση.

- **Υλοποίηση Μεθόδων στην κλάση Animal (Slides 12-17):**
  - **`turn(int angle)` (Slide 12):**

```java
// Μέθοδος στην κλάση Animal (κληρονομείται από Actor)
/**
 * Στροφή προς τη φορά των δεικτών του ρολογιού κατά 'angle' μοίρες
 */
public void turn(int angle)
{
    setRotation(getRotation() + angle);
}
```

    *   **`move()` (Slides 13-14):**

```java
// Μέθοδος στην κλάση Animal
/**
 * Κίνηση προς τα εμπρός.
 */
public void move()
{
    double angle = Math.toRadians( getRotation() );
    int x = (int) Math.round(getX() + Math.cos(angle) * WALKING_SPEED);
    int y = (int) Math.round(getY() + Math.sin(angle) * WALKING_SPEED);

    setLocation(x, y);
}
// Απαιτείται επίσης η δήλωση της σταθεράς WALKING_SPEED, π.χ.
// protected static final int WALKING_SPEED = ... ; // Ορισμός στην κλάση Animal
```

_(Σημείωση: Το `WALKING_SPEED` πρέπει να δηλωθεί ως σταθερά στην κλάση `Animal`, π.χ., `protected static final int WALKING_SPEED = 5;`)_

    *   **`atWorldEdge()` (Slide 15):**

```java
// Μέθοδος στην κλάση Animal (κληρονομείται από Actor, αλλά συνήθως υλοποιείται στην Animal)
/**
 * Επιστρέφει true αν βρίσκεται στα όρια του κόσμου.
 */
public boolean atWorldEdge()
{
    // Έλεγχος αν απέχει λιγότερο από 20 pixels από τα όρια
    if(getX() < 20 || getX() > getWorld().getWidth() - 20)
        return true;
    if(getY() < 20 || getY() > getWorld().getHeight() - 20)
        return true;
    return false;
}
```

    *   **`canSee(Class clss)` (Slide 16):**

```java
// Μέθοδος στην κλάση Animal (κληρονομείται από Actor, αλλά συνήθως υλοποιείται στην Animal)
/**
 * Επίστρεψε true αν υπάρχει αντικείμενο τύπου 'clss' στην τρέχουσα θέση,
 * false διαφορετικά.
 */
public boolean canSee(Class clss)
{
    // Χρησιμοποιούμε getOneObjectAtOffset(0, 0, clss) για έλεγχο στην ίδια θέση
    Actor actor = (Actor) getOneObjectAtOffset(0, 0, clss);
    return actor != null;
}
```

    *   **`eat(Class clss)` (Slide 17):**

```java
// Μέθοδος στην κλάση Animal (κληρονομείται από Actor, αλλά συνήθως υλοποιείται στην Animal)
/**
 * Προσπάθησε να φας ένα αντικείμενο τύπου'clss'. Αν δεν υπάρχει αντικείμενο
 * αυτού του τύπου στην τρέχουσα θέση η μέθοδος δεν έχει κάποιο αποτέλεσμα
 */
public void eat(Class clss)
{
    Actor actor = (Actor) getOneObjectAtOffset(0, 0, clss);
    if(actor != null) {
        getWorld().removeObject(actor);
    }
}
```

- **Είναι απαραίτητος ο ορισμός της υπερκλάσης Animal ??? (Slide 18):**

  - Όπως είδαμε, η κλάση `Actor` παρέχει ήδη μεθόδους όπως `turn()`.
  - **ΣΗΜΑΝΤΙΚΟ:** Το Greenfoot παρέχει μια **προ-ορισμένη κλάση `Animal`** που **ήδη υλοποιεί** τις μεθόδους `move()`, `atWorldEdge()`, `canSee()`, `eat()`.
  - Δεν χρειάζεται να γράψουμε εμείς τον κώδικα για αυτές τις μεθόδους! Αρκεί να εισάγουμε την έτοιμη κλάση `Animal`. Κάντε `Edit -> Import Class...` και επιλέξτε `animal` από τη λίστα. Τώρα μπορείτε να ορίσετε τις κλάσεις `Crab` και `Lobster` ως υποκλάσεις της **εισαχθείσας** κλάσης `Animal`.

- **Ορισμός κλάσης Worm (Slide 19):**
  - Δημιουργήστε την κλάση `Worm` ως υποκλάση της `Animal`.
  - Προς το παρόν, τα σκουλήκια απλώς κάθονται και περιμένουν να φαγωθούν.
  - Κληρονομούν τις μεθόδους από τις κλάσεις `Animal` και `Actor`.
  - Δεν χρειάζεται να προσθέσετε κώδικα στην κλάση `Worm` για την αρχική υλοποίηση. Η δήλωση της κλάσης είναι αρκετή:

```java
// Στην κλάση Worm
import greenfoot.*;  // (World, Actor, GreenfootImage, Greenfoot and MouseInfo)

public class Worm extends Animal
{
    /**
     * Act - do whatever the Worm wants to do. This method is called whenever
     * the 'Act' or 'Run' button gets pressed in the environment.
     */
    public void act()
    {
        // Add your action code here.
    }
}
```

_(Σημείωση: Ο κώδικας μέσα στην `act()` μπορεί να προστεθεί αργότερα για animation ή κίνηση, όπως αναφέρεται στις επεκτάσεις)_

- **Προσθήκη σκουληκιών στο παιχνίδι (Slide 20):**

  - Επιλέξτε την κλάση `Worm`.
  - Κάντε δεξί κλικ στην κλάση `Worm` και επιλέξτε `new Worm()`. Στη συνέχεια κάντε κλικ στην περιοχή του κόσμου όπου θέλετε να εμφανιστεί το σκουλήκι.
  - Για να προσθέσετε πολλά σκουλήκια γρήγορα, κρατήστε πατημένο το πλήκτρο **Shift** και κάντε κλικ στις επιθυμητές θέσεις.
  - **Αποθήκευση:** Με δεξί κλικ στην περιοχή του παιχνιδιού και επιλογή `Save World`, αποθηκεύετε την τρέχουσα κατάσταση του κόσμου.

- **Ορισμός κλάσης Crab (Slide 21):**

  - Δημιουργήστε την κλάση `Crab` ως υποκλάση της `Animal`.
  - **Ιδιότητες/Πεδία:** `wormsEaten` (μετρά τα σκουλήκια που έχει φάει ο κάβουρας).
  - **Λειτουργίες/Μέθοδοι:**
    - `checkKeypress()`: Ελέγχει τα πλήκτρα αριστερά/δεξιά και στρίβει τον κάβουρα.
    - `lookForWorm()`: Ψάχνει για σκουλήκι στην τρέχουσα θέση, το τρώει, αυξάνει το σκορ και ελέγχει αν ο παίκτης κέρδισε.
    - `act()`: Η βασική μέθοδος συμπεριφοράς, καλείται συνεχώς. Καλεί τις `checkKeypress`, `move` (κληρονομημένη), `lookForWorm`.
  - **Συνθήκη Νίκης:** Ο παίκτης κερδίζει αν ο κάβουρας φάει **8 σκουλήκια**.

- **Υλοποίηση Μεθόδων στην κλάση Crab:**
  - **`checkKeypress()` (Slide 22):**

```java
// Μέθοδος στην κλάση Crab
/**
 * Έλεγξε αν έχει πατηθεί το αριστερό ή δεξί βελάκι από το πληκτρολόγιο
 * και στρίψε κατάλληλα.
 */
public void checkKeypress()
{
    if (Greenfoot.isKeyDown("left"))
    {
        turn(-4); // Στρίψε 4 μοίρες αριστερά
    }
    if (Greenfoot.isKeyDown("right"))
    {
        turn(4); // Στρίψε 4 μοίρες δεξιά
    }
}
```

    *   **`lookForWorm()` (Slide 23):**

```java
// Μέθοδος στην κλάση Crab
// Προσθέστε την ιδιότητα στην κλάση Crab: private int wormsEaten = 0;
/**
 * Έλεγξε αν έχεις πέσει πάνω σε ένα σκουλήκι προκειμένου να το φας.
 * Αν έχεις φάει 8 σκουλήκια κερδίζεις.
 */
public void lookForWorm()
{
    if (canSee(Worm.class) ) // Χρησιμοποιεί την κληρονομημένη canSee
    {
        eat(Worm.class); // Χρησιμοποιεί την κληρονομημένη eat
        Greenfoot.playSound("slurp.wav"); // Παίζει ήχο

        wormsEaten = wormsEaten + 1; // Αύξησε το σκορ

        if (wormsEaten == 8) // Έλεγχος συνθήκης νίκης
        {
            Greenfoot.playSound("fanfare.wav"); // Παίζει ήχο νίκης
            Greenfoot.stop(); // Σταματά το παιχνίδι
        }
    }
}
```

    *   **Βασική συμπεριφορά καβουριού - act() (Slide 24):**

```java
// Μέθοδος στην κλάση Crab
/**
 * Υλοποίηση βασικής συμπεριφοράς καβουριού. Καλείται κάθε φορά που πατάμε
 * το κουμπί 'Act' ή 'Run' στο περιβάλλον.
 */
public void act()
{
    checkKeypress(); // Έλεγξε αν πατήθηκαν πλήκτρα κίνησης
    move(); // Μετακινήσου προς την τρέχουσα κατεύθυνση (κληρονομημένη μέθοδος)
    lookForWorm(); // Ψάξε για σκουλήκι και φάτο
}
```

- **Προσθήκη καβουριού στο παιχνίδι (Slide 25):**

  - Όπως κάναμε με τα σκουλήκια, δημιουργήστε ένα στιγμιότυπο της κλάσης `Crab` (`new Crab()`) και τοποθετήστε το στον κόσμο. Τώρα μπορείτε να δοκιμάσετε την πρώτη έκδοση του παιχνιδιού!

- **Βελτιώνοντας την κίνηση του καβουριού (Slide 25 & 26):**
  - Για πιο φυσική κίνηση, μπορούμε να χρησιμοποιήσουμε animation εναλλάσσοντας δύο εικόνες του κάβουρα (μία με τα πόδια μέσα, μία με τα πόδια έξω).
  - Προσθέστε δύο ιδιότητες τύπου `GreenfootImage` (`image1`, `image2`) στην κλάση `Crab`.
  - Στον κατασκευαστή της κλάσης `Crab`, φορτώστε τις δύο εικόνες (`"crab.png"`, `"crab2.png"`) στις ιδιότητες. Αρχικά, ορίστε την εικόνα του αντικειμένου στην `image1` με `setImage(image1)`.
  - Προσθέστε μια μέθοδο `switchImage()` που εναλλάσσει την εικόνα του αντικειμένου μεταξύ `image1` και `image2` χρησιμοποιώντας την `setImage()`. Ελέγχει ποια είναι η τρέχουσα εικόνα με την `getImage()`.
  - Προσθέστε μια κλήση στη μέθοδο `switchImage()` μέσα στη μέθοδο `act()` του κάβουρα, ώστε η εικόνα να αλλάζει σε κάθε βήμα.

```java
// Στην κλάση Crab - Προσθήκες για animation
import greenfoot.*; // (World, Actor, GreenfootImage, Greenfoot and MouseInfo)

public class Crab extends Animal
{
    private int wormsEaten = 0; // Ιδιότητα για το σκορ

    // Προσθέστε αυτές τις ιδιότητες για το animation
    private GreenfootImage image1;
    private GreenfootImage image2;

    /**
     * Constructor for objects of class Crab.
     */
    public Crab()
    {
        // Αρχικοποίηση των εικόνων στον κατασκευαστή
        image1 = new GreenfootImage("crab.png");
        image2 = new GreenfootImage("crab2.png");

        // Ορισμός αρχικής εικόνας
        setImage(image1);

        wormsEaten = 0; // Αρχικοποίηση σκορ
    }

    /**
     * Act - do whatever the Crab wants to do. This method is called whenever
     * the 'Act' or 'Run' button gets pressed in the environment.
     */
    public void act()
    {
        checkKeypress();
        move();
        lookForWorm();
        // Προσθέστε την κλήση για εναλλαγή εικόνας
        switchImage();
    }

    // ... checkKeypress() και lookForWorm() όπως παραπάνω ...

    /**
     * Εναλλάσσει την εικόνα του καβουριού για animation.
     */
    public void switchImage()
    {
        if (getImage() == image1)
        {
            setImage(image2);
        }
        else
        {
            setImage(image1);
        }
    }
}
```

- **Προσθήκη αντίπαλου - Ορισμός κλάσης Lobster (Slides 27 & 28):**

  - Δημιουργήστε την κλάση `Lobster` ως υποκλάση της `Animal`.
  - **Λειτουργίες/Μέθοδοι:**
    - `turnAtEdge()`: Στρίβει αν είναι στα όρια του κόσμου.
    - `randomTurn()`: Στρίβει τυχαία (ή όχι).
    - `lookForCrab()`: Ελέγχει αν υπάρχει καβούρι στην τρέχουσα θέση και αν ναι, το τρώει και τερματίζει το παιχνίδι (συνθήκη ήττας).
    - `act()`: Η βασική μέθοδος συμπεριφοράς. Καλεί τις `turnAtEdge`, `randomTurn`, `move` (κληρονομημένη), `lookForCrab`.

- **Υλοποίηση Μεθόδων στην κλάση Lobster:**
  - **`turnAtEdge()` (Slide 29):**

```java
// Μέθοδος στην κλάση Lobster
/**
 * Έλεγξε αν είσαι στα όρια του κόσμου και στρίψε.
 */
public void turnAtEdge()
{
    if (atWorldEdge() ) // Χρησιμοποιεί την κληρονομημένη atWorldEdge
    {
        turn(17); // Στρίβε 17 μοίρες
    }
}
```

    *   **`randomTurn()` (Slide 30):**

```java
// Μέθοδος στην κλάση Lobster
/**
 * Αποφασίζεται τυχαία να στρίψει ή όχι (πιθανότητα να στρίψει 9 /100)
 * Αν στρίψει, στρίβει τυχαία λίγο προς τα αριστερά ή δεξιά (-45..45 μοίρες)
 */
public void randomTurn()
{
    // 10% πιθανότητα να στρίψει (τυχαίος αριθμός από 0 έως 99)
    if (Greenfoot.getRandomNumber(100) > 90) {
        // Στρίψε τυχαία από -45 έως +44 μοίρες
        turn(Greenfoot.getRandomNumber(90)-45);
    }
}
```

    *   **`lookForCrab()` (Slide 31):**

```java
// Μέθοδος στην κλάση Lobster
/**
 * Έλεγξε αν έπεσες πάνω σε ένα καβούρι. Αν ναι απομάκρυνε το και τελείωσε
 * το παιχνίδι
 */
public void lookForCrab()
{
    if (canSee(Crab.class) ) // Χρησιμοποιεί την κληρονομημένη canSee
    {
        eat(Crab.class); // Χρησιμοποιεί την κληρονομημένη eat
        Greenfoot.playSound("au.wav"); // Παίζει ήχο
        Greenfoot.stop(); // Σταματά το παιχνίδι
    }
}
```

    *   **Βασική συμπεριφορά αστακού - act() (Slide 32):**

```java
// Μέθοδος στην κλάση Lobster
/**
 * Υλοποίηση βασικής συμπεριφοράς αστακού. Καλείται κάθε φορά που πατάμε
 * το κουμπί 'Act' ή 'Run' στο περιβάλλον.
 */
public void act()
{
    turnAtEdge(); // Στρίψε αν είσαι στα όρια
    randomTurn(); // Στρίψε τυχαία
    move(); // Κινήσου (κληρονομημένη μέθοδος)
    lookForCrab(); // Ψάξε για καβούρι και φάτο
}
```

---

## Προσθήκη Επιπέδων (Levels) (Slides 33-38)

- **Δημιουργία 2ου Επιπέδου (Slide 33):**

  - Για να έχουμε περισσότερα επίπεδα, δημιουργήστε μια **2η υποκλάση της `World`**, π.χ., `CrabWorld2`.
  - Το 2ο επίπεδο μπορεί να είναι πιο δύσκολο (π.χ., περισσότεροι εχθροί, μικρότερη περιοχή).
  - Μπορείτε να δημιουργήσετε ένα **στιγμιότυπο** της νέας κλάσης `CrabWorld2` με δεξί κλικ πάνω της και επιλογή `new CrabWorld2()`.
  - Μην ξεχνάτε να αποθηκεύετε την κατάσταση του κόσμου! Για να επιστρέψετε/επεξεργαστείτε το 1ο επίπεδο, απλά δημιουργήστε ένα στιγμιότυπο της κλάσης `CrabWorld`.

- **Μετακίνηση Πρωταγωνιστή μεταξύ Επιπέδων (Slides 35-36):**
  - Αφού υπάρχουν πλέον επίπεδα, ο πρωταγωνιστής (κάβουρας) πρέπει να μπορεί να μεταφέρεται από το ένα επίπεδο στο άλλο.
  - Ο κάβουρας θα πρέπει να **περνάει ως όρισμα** στον κατασκευαστή του _επόμενου_ επιπέδου.
  - Αυτό απαιτεί αλλαγή στον **κατασκευαστή** της κλάσης `CrabWorld2` ώστε να δέχεται ένα αντικείμενο `Crab` ως παράμετρο: `public CrabWorld2(Crab crab)`.
  - Μέσα στον κατασκευαστή της `CrabWorld2`, καλείται ο `super()` constructor για να οριστεί η διάσταση του κόσμου. Στη συνέχεια, στην μέθοδο `prepare` (η οποία καλείται από τον κατασκευαστή - μπορεί να χρειαστεί να τη δημιουργήσετε αν δεν υπάρχει), αντί να δημιουργείται νέο στιγμιότυπο κάβουρα, **προστίθεται στον κόσμο το αντικείμενο `crab`** που περάστηκε ως παράμετρος: `addObject(crab, 308, 303);`.
  - **Σημείωση:** Η μέθοδος `prepare` δημιουργείται αυτόματα από το Greenfoot αν προσθέσετε αντικείμενα στον κόσμο και αποθηκεύσετε την κατάσταση. Αντί να χρησιμοποιήσετε την αυτόματη `prepare`, μπορείτε να τη δημιουργήσετε χειροκίνητα και να προσθέσετε τα αντικείμενα του 2ου επιπέδου.

```java
// Στην κλάση CrabWorld2
import greenfoot.*; // (World, Actor, GreenfootImage, Greenfoot and MouseInfo)

public class CrabWorld2 extends World
{
    /**
     * Constructor for objects of class CrabWorld2.
     * Αλλαγή κατασκευαστή ώστε να δέχεται τον πρωταγωνιστή (τον κάβουρα)
     */
    public CrabWorld2(Crab crab) // Δέχεται ένα αντικείμενο Crab
    {
        // Create a new world with 600x600 cells with a cell size of 1x1 pixels.
        super(600, 600, 1); // Μπορείτε να αλλάξετε τις διαστάσεις ή το μέγεθος κελιού
        prepare(crab); // Καλέστε τη μέθοδο prepare, περνώντας τον κάβουρα
    }

    /**
     * Prepare the world for the start of the program.
     * That is: create the initial objects and add them to the world.
     * Χρειάζεται τροποποίηση για να δέχεται τον κάβουρα
     */
    private void prepare(Crab crab)
    {
        //ο αστακός περνάει πλέον μέσω παραμέτρου (αν υπήρχε)
        // αλλά ο κάβουρας ΠΡΕΠΕΙ να περαστεί ως παράμετρος

        // Προσθέστε τον κάβουρα που περάστηκε ως όρισμα
        addObject(crab, 308, 303); // Προσθέστε τον κάβουρα σε κάποια αρχική θέση

        // Προσθέστε άλλα αντικείμενα για το Level 2 (π.χ. περισσότερα σκουλήκια/αστακούς)
        // Worm worm = new Worm();
        // addObject(worm, 100, 100);
        // ... κ.ο.κ.
    }
}
```

- **Παρακολούθηση/Αλλαγή Επιπέδων στον Crab (Slides 35 & 37-38):**
  - Ο κάβουρας πρέπει να "γνωρίζει" σε ποιο επίπεδο βρίσκεται. Προσθέστε μια ιδιότητα/πεδίο `private int level;` στην κλάση `Crab`.
  - Στον κατασκευαστή της `Crab`, αρχικοποιήστε το `level` στο 1 (`level = 1;`).
  - Προσθέστε μια μέθοδο `checkNextLevel()` στην κλάση `Crab` που ελέγχει αν ο κάβουρας πρέπει να προχωρήσει στο επόμενο επίπεδο.
  - Καλέστε τη μέθοδο `checkNextLevel()` μέσα στη μέθοδο `act()` του κάβουρα.
  - **Υλοποίηση `checkNextLevel()` (Slide 38):**
    - Ελέγχει αν η τρέχουσα κατάσταση ικανοποιεί τη συνθήκη μετάβασης στο επόμενο επίπεδο (π.χ., `level == 1 && wormsEaten == 8`).
    - Αν ναι, ενημερώνει το `level` (`level = 2;`), μηδενίζει το `wormsEaten` (`wormsEaten = 0;`), αφαιρεί τον κάβουρα από τον τρέχοντα κόσμο (`getWorld().removeObject(this);`), παίζει ήχο και, το σημαντικότερο, **αλλάζει τον κόσμο** θέτοντας ως νέο ενεργό κόσμο ένα **νέο στιγμιότυπο της κλάσης `CrabWorld2`**, περνώντας τον εαυτό του (`this`) ως όρισμα: `Greenfoot.setWorld(new CrabWorld2(this));`.
    - Προσθέστε έλεγχο για τη συνθήκη νίκης στο 2ο επίπεδο (π.χ., `level == 2 && wormsEaten == 8`). Αν ναι, εμφανίζει μήνυμα νίκης (`winMessage()`) και σταματά το παιχνίδι (`Greenfoot.stop()`).
    - Η μέθοδος `winMessage()` είναι βοηθητική για να γράψει το μήνυμα "WINNER" χρησιμοποιώντας `GreenfootImage` και `Font`. Χρειάζεται να την προσθέσετε στην κλάση `Crab`.

```java
// Στην κλάση Crab - Προσθήκες για διαχείριση επιπέδων
import greenfoot.*; // (World, Actor, GreenfootImage, Greenfoot and MouseInfo)
import java.awt.Color; // Import για το χρώμα του κειμένου
import java.awt.Font; // Import για τη γραμματοσειρά

public class Crab extends Animal
{
    private int wormsEaten = 0;
    private GreenfootImage image1;
    private GreenfootImage image2;

    // Προσθέστε την ιδιότητα για το τρέχον επίπεδο
    private int level;

    /**
     * Constructor for objects of class Crab.
     */
    public Crab()
    {
        image1 = new GreenfootImage("crab.png");
        image2 = new GreenfootImage("crab2.png");
        setImage(image1);

        wormsEaten = 0;
        // Αρχικοποίηση επιπέδου
        level = 1;
    }

    /**
     * Act - do whatever the Crab wants to do. This method is called whenever
     * the 'Act' or 'Run' button gets pressed in the environment.
     */
    public void act()
    {
        checkKeypress();
        move();
        lookForWorm();
        switchImage();
        // Προσθέστε τον έλεγχο για αλλαγή επιπέδου
        checkNextLevel();
    }

    // ... checkKeypress(), lookForWorm(), switchImage() όπως παραπάνω ...

    /**
     * Ελέγχει αν ο κάβουρας έχει φάει αρκετά σκουλήκια
     * για να προχωρήσει στο επόμενο επίπεδο ή να κερδίσει.
     */
    private void checkNextLevel()
    {
        // Έλεγχος συνθήκης μετάβασης στο Level 2
        if (level == 1 && wormsEaten == 8)
        {
            level = 2; // Ενημέρωσε το επίπεδο
            wormsEaten = 0; // Μηδένισε το σκορ για το νέο επίπεδο
            getWorld().removeObject(this); // Αφαίρεσε τον κάβουρα από τον τρέχοντα κόσμο
            Greenfoot.playSound("fanfare.wav"); // Παίξε ήχο επιπέδου
            // Αλλαγή κόσμου και πέρασμα του ΕΙΔΙΟΥ αντικειμένου κάβουρα
            Greenfoot.setWorld(new CrabWorld2(this));
        }
        // Έλεγχος συνθήκης νίκης στο Level 2
        else if (level == 2 && wormsEaten == 8) // Υποθέτουμε 8 σκουλήκια και στο Level 2 για νίκη
        {
            Greenfoot.playSound("fanfare.wav"); // Παίξε ήχο νίκης
            winMessage(); // Εμφάνισε μήνυμα νίκης
            Greenfoot.stop(); // Σταμάτα το παιχνίδι
        }
    }

    /**
     * Εμφανίζει μήνυμα νίκης στην οθόνη.
     * Βοηθητική μέθοδος.
     */
    private void winMessage()
    {
        // Πάρε την εικόνα φόντου του κόσμου
        GreenfootImage bg = getWorld().getBackground();
        // Πάρε την τρέχουσα γραμματοσειρά του φόντου
        Font font = bg.getFont();
        // Όρισε χρώμα για το κείμενο
        bg.setColor(Color.RED); // Χρησιμοποιούμε Color από το java.awt
        // Δημιούργησε μια μεγαλύτερη γραμματοσειρά
        bg.setFont(font.deriveFont(48f)); // float size 48
        // Σχεδίασε το μήνυμα στην εικόνα φόντου
        bg.drawString("WINNER", 200, 250); // Θέση εμφάνισης
        // Ορισμός της τροποποιημένης εικόνας φόντου
        getWorld().setBackground(bg); // Ενημέρωσε το φόντο του κόσμου
    }
}
```

*(Σημείωση: Θα χρειαστεί να τροποποιήσετε την κλάση CrabWorld2 για να έχει το δικό της layout με αντικείμενα, και να βεβαιωθείτε ότι η μέθοδος `prepare` σε αυτήν προσθέτει τον *ίδιο* κάβουρα που της περάστηκε.)*

---

## Επεκτάσεις (Challenges) (Slides 39-40)

Αυτές είναι προαιρετικές ασκήσεις για εξάσκηση και περαιτέρω ανάπτυξη του παιχνιδιού. Δεν παρέχεται κώδικας στις διαφάνειες, αλλά περιγράφεται τι πρέπει να υλοποιηθεί.

- **Challenge 1 (Slide 39):**
  - Προσθέστε έλεγχο κίνησης για πάνω/κάτω στον κάβουρα μέσω πληκτρολογίου (χρησιμοποιώντας `Greenfoot.isKeyDown("up")` και `Greenfoot.isKeyDown("down")` και τροποποιώντας την `move()` ή προσθέτοντας νέα λογική κίνησης).
  - Υλοποιήστε ένα "πηδηματάκι" προς τα πίσω (10 pixels) όταν ο κάβουρας συναντά αστακό, πατώντας ένα πλήκτρο (π.χ., 'j'). Θα χρειαστείτε έναν έλεγχο `if (canSee(Lobster.class) && Greenfoot.isKeyDown("j"))` και αλλαγή θέσης.
  - Σκεφτείτε και άλλες λειτουργίες ελεγχόμενες από πληκτρολόγιο (π.χ. ταχύτερη κίνηση, άλλη ικανότητα).
- **Challenge 2 (Slide 39):**
  - Τροποποιήστε τη μέθοδο `prepare` του **πρώτου** επιπέδου (`CrabWorld`) ώστε να προσθέτει **τυχαίο** αριθμό σκουληκιών (μεταξύ 8 και 30) και αστακών (μεταξύ 1 και 3) σε **τυχαίες** θέσεις. Χρησιμοποιήστε την μέθοδο `Greenfoot.getRandomNumber(limit)` για να πάρετε έναν τυχαίο αριθμό (από 0 έως limit-1) και την `addObject(object, x, y)` με τυχαίες συντεταγμένες (π.χ., `Greenfoot.getRandomNumber(getWidth())`).
- **Challenge 3 (Slide 39):**
  - Δώστε στα σκουλήκια κάποιο **εφέ κίνησης** (παραμένοντας στη θέση τους, π.χ., εναλλαγή εικόνων ή μικρές περιστροφές).
  - Υλοποιήστε τη **δυναμική εμφάνιση νέων σκουληκιών** στην `act()` του κάβουρα (μετά το φάγωμα) ή στην `act()` της `World` (σε τυχαίες χρονικές στιγμές, χρησιμοποιώντας έναν μετρητή ή `Greenfoot.getRandomNumber`).
- **Challenge 4 (Slide 40):**
  - Υλοποιήστε **παιχνίδι 2 παικτών**: ορίστε διαφορετικά πλήκτρα για την κίνηση του κάβουρα και του αστακού (π.χ., WASD για τον αστακό). Θα υπάρχει πάντα ένας κάβουρας και ένας αστακός.
- **Challenge 5 (Slide 40):**
  - Προσθέστε **εμπόδια** (π.χ., βράχους - νέα κλάση `Rock` υποκλάση της `Actor`). Τροποποιήστε τη λογική "φαγώματος" στον αστακό έτσι ώστε να μην μπορεί να "φάει" τον κάβουρα αν ο κάβουρας βρίσκεται σε κελί που έχει `Rock` (π.χ., ελέγξτε `if (!isTouching(Rock.class) && canSee(Crab.class))`). Προσθέστε τυχαίο αριθμό εμποδίων (όχι πάνω από 3) στην `prepare`.
- **Challenge 6 (Slide 40):**
  - Υλοποιήστε μια **ποινή** όταν οι χαρακτήρες αγγίζουν τα όρια του κόσμου (αν υπάρχουν 2 παίκτες, όπως στο Challenge 4).
  - Όταν ο κάβουρας αγγίζει τα όρια: χάνει 1 πόντο (αν έχετε προσθέσει σύστημα σκορ, αλλιώς μπορείτε να μειώσετε το `wormsEaten`), αλλά εμφανίζεται ένα νέο σκουλήκι.
  - Όταν ο αστακός αγγίζει τα όρια: κερδίζει 1 πόντο στο σκορ του κάβουρα (αυξήστε το `wormsEaten` του κάβουρα). Θα χρειαστεί πρόσβαση στο αντικείμενο του κάβουρα από τον αστακό ή διαχείριση του σκορ από την `World` κλάση. Χρησιμοποιήστε τον κληρονομημένο έλεγχο `atWorldEdge()` στην `act()` κάθε ζώου.
