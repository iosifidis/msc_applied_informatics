# Greenfoot Asteroids

## Εισαγωγή στο Project Asteroids (Slides 2-4)

*   Το Greenfoot παρέχει ένα έτοιμο project/σενάριο με όνομα **"Asteroids-1"** που μπορούμε να ανοίξουμε και να εξερευνήσουμε.
*   **Εξερεύνηση Asteroids-1 (Slides 2-3):**
    *   Ανοίξτε το project και πειραματιστείτε. Τι παρατηρείτε;
    *   **Τι δουλεύει:** Ο πύραυλος στρίβει αριστερά/δεξιά με τα βελάκια (όπως είδαμε και στον κάβουρα).
    *   **Τι δεν δουλεύει:**
        *   Ο πύραυλος δεν κινείται.
        *   Τίποτα δεν συμβαίνει όταν ένα αστεροειδές προσκρούει στον πύραυλο – απλά διαπερνάει τον πύραυλο, αντί να τον καταστρέφει (ΔΕΝ ΥΠΑΡΧΕΙ ΕΛΕΓΧΟΣ ΣΥΓΚΡΟΥΣΕΩΝ).
        *   Το παιχνίδι δεν τελειώνει ποτέ.
        *   Το τελικό σκορ δεν εμφανίζεται.
        *   Οι κλάσεις `ScoreBoard`, `Explosion`, `ProtonWave` εμφανίζονται στο διάγραμμα κλάσεων, αλλά δεν χρησιμοποιούνται ακόμη.
*   **Εξερεύνηση Asteroids-3 (Slide 4):**
    *   Χρησιμοποιήστε την τελική έκδοση του παιχνιδιού (`asteroids-3.jar`) για να δείτε τη λειτουργικότητα που θα προσθέσουμε στην πορεία (κίνηση πυραύλου, σύγκρουση, έκρηξη, game over, σκορ, proton wave).

---

## Asteroids-1: Σχεδίαση Σκηνικού με Κώδικα (Slides 5-7)

*   Στα προηγούμενα σενάρια, χρησιμοποιήσαμε μια έτοιμη εικόνα από το σύστημα αρχείων ως σκηνικό.
*   Στο Asteroids-1, το σκηνικό **δημιουργείται με κώδικα** κατά την εκτέλεση του προγράμματος.
*   **Κατασκευαστής κλάσης Space (Slides 5-6):**
    *   Στον κατασκευαστή της κλάσης `Space` (`public Space()`) ορίζονται οι διαστάσεις του κόσμου (`super(600, 400, 1)`).
    *   Το υπόβαθρο (background) ανακτάται (`GreenfootImage background = getBackground();`).
    *   Το χρώμα του υποβάθρου αλλάζει σε μαύρο (`background.setColor(Color.BLACK);`).
    *   Το υπόβαθρο γεμίζει με μαύρο χρώμα (`background.fill();`).
    *   Δημιουργείται και προστίθεται ο **πύραυλος** (στιγμιότυπο της κλάσης `Rocket`).
    *   Καλούνται μέθοδοι για τη δημιουργία και προσθήκη των **αστεροειδών** (`addAsteroids(startAsteroids);`) και του **μετρητή σκορ** (`addObjects(scoreCounter, 60, 380);`).
    *   Αρχικοποιούνται οι εικόνες για την **έκρηξη** (`Explosion.initializeImages();`) και το **proton wave** (`ProtonWave.initializeImages();`) καλώντας τις static μεθόδους `initializeImages` των αντίστοιχων κλάσεων.
*   **Σχεδίαση Αστεριών με Κώδικα (Slide 7):**
    *   Η κλάση `Space` περιέχει μια ιδιωτική μέθοδο `createStars(int number)` που δημιουργεί τον επιθυμητό αριθμό αστεριών σε τυχαίες θέσεις και με διαφορετική φωτεινότητα. Αυτή η μέθοδος καλείται στον κατασκευαστή της κλάσης `Space`.

---

## Rocket: Στροφή και Κίνηση (Slides 8-11)

*   **Στροφή (Slide 8):**
    *   Στην κλάση `Rocket`, η μέθοδος `checkKeys()` (την οποία καλεί η `act()`) ελέγχει αν πατιούνται τα πλήκτρα αριστερά/δεξιά και καλεί την κληρονομημένη μέθοδο `turn(-5)` ή `turn(5)` για στροφή.
*   **Κίνηση (Slides 9-10):**
    *   Στην `act()` μέθοδο του Rocket, καλείται η μέθοδος `move()` (κληρονομημένη από την `SmoothMover`).
    *   **Γιατί δεν κινείται ο πύραυλος αρχικά;** Όπως είδαμε στο προηγούμενο μάθημα, η κλάση `SmoothMover` χρησιμοποιεί ένα διάνυσμα κίνησης (`Vector movement`). Στον κατασκευαστή του Rocket, αυτό το διάνυσμα δεν έχει αρχικοποιηθεί με μήκος μεγαλύτερο από 0 (δηλαδή η αρχική ταχύτητα είναι 0).
    *   **Προσθήκη Αρχικής Ώθησης (Slide 10):** Για να ξεκινήσει να κινείται, μπορούμε να δώσουμε μια μικρή αρχική ώθηση στον πύραυλο στον κατασκευαστή του. Δημιουργούμε ένα νέο διάνυσμα με τυχαία κατεύθυνση και μικρό μήκος (π.χ., 0.3) και χρησιμοποιούμε τη μέθοδο `addForce()` της κλάσης `SmoothMover` για να εφαρμόσουμε αυτό το διάνυσμα στον πύραυλο.
*   **Έλεγχος Κίνησης - Ανάφλεξη με Πλήκτρο (Slide 11):**
    *   Στο παιχνίδι Asteroids, ο παίκτης συνήθως ελέγχει την ώθηση του πυραύλου πατώντας το πλήκτρο "πάνω" (↑).
    *   Προσθέστε στην `checkKeys()` μέθοδο έλεγχο για το πλήκτρο "up" (`Greenfoot.isKeyDown("up")`).
    *   Αν πατηθεί, καλέστε μια νέα μέθοδο, π.χ., `ignite(boolean boosterOn)`, η οποία θα αλλάζει την εικόνα του πυραύλου σε μια εικόνα με ανάφλεξη (`rocketWithThrust.png`) και θα εφαρμόζει μια δύναμη (π.χ., με `addForce`) προς την κατεύθυνση που κοιτάζει ο πύραυλος (`new Vector(getRotation(), 0.3)`). Αν το πλήκτρο δεν πατιέται, η εικόνα επιστρέφει στην κανονική (`rocket.png`).

---

## Έλεγχος Συγκρούσεων (Collision Detection) (Slides 12-18)

*   **Στόχος:** Αν ο πύραυλος συγκρουστεί με ένα αστεροειδές, να συμβούν συγκεκριμένα γεγονότα (π.χ., απομάκρυνση πυραύλου, έκρηξη, εμφάνιση game over/σκορ).
*   **Μέθοδοι Εντοπισμού Σύγκρουσης στην κλάση Actor (Slides 13-16):**
    *   Η κλάση `Actor` του Greenfoot παρέχει διάφορες μεθόδους για τον εντοπισμό συγκρούσεων ή την ύπαρξη άλλων αντικειμένων κοντά:
        *   `getIntersectingObjects(Class clss)`: Επιστρέφει μια `java.util.List` με **όλα** τα αντικείμενα του τύπου `clss` που τέμνονται (βρίσκονται σε επαφή) με το πλαίσιο οριοθέτησης (bounding box) του τρέχοντος αντικειμένου.
        *   `getOneIntersectingObject(Class clss)`: Επιστρέφει **ένα** αντικείμενο του τύπου `clss` που τέμνεται με το πλαίσιο οριοθέτησης.
        *   `getNeighbours(int distance, boolean diagonal, Class clss)`: Επιστρέφει τα αντικείμενα του τύπου `clss` που βρίσκονται σε συγκεκριμένη απόσταση. Χρησιμοποιείται όταν έχουμε χαμηλή ανάλυση και κάθε Actor "ζει" σε ένα κελί (Slide 14).
        *   `getObjectsAtOffset(int dx, int dy, Class clss)`: Επιστρέφει όλα τα αντικείμενα του τύπου `clss` που βρίσκονται στην καθορισμένη offset θέση σε σχέση με το κέντρο του τρέχοντος αντικειμένου. Χρησιμοποιείται σε χαμηλή ανάλυση (κάθε Actor "ζει" σε ένα κελί), π.χ., `offset(2, 0)` (Slide 15).
        *   `getObjectsInRange(int radius, Class clss)`: Εντοπίζει αντικείμενα του τύπου `clss` των οποίων το **κέντρο** απέχει από το κέντρο του τρέχοντος αντικειμένου απόσταση μικρότερη ή ίση του `radius` (Slide 16).
    *   **Πλαίσιο Οριοθέτησης vs Ορατή Εικόνα (Slide 13 & 18):** Είναι σημαντικό να κατανοήσουμε ότι οι μέθοδοι `getIntersectingObjects` και `getOneIntersectingObject` ελέγχουν για επαφή μεταξύ των **ορθογώνιων πλαισίων οριοθέτησης (bounding boxes)** των αντικειμένων, όχι των pixel της ορατής εικόνας.
    *   **Πρόβλημα:** Αν οι εικόνες είναι διάφανες ή έχουν περίπλοκο σχήμα (όπως ο πύραυλος ή οι αστεροειδείς), η σύγκρουση μπορεί να ανιχνευθεί ενώ οι ορατές εικόνες δεν αγγίζουν, επειδή τα ορθογώνια πλαίσια επικαλύπτονται (Slide 18). Στο παιχνίδι Asteroids, αυτό μπορεί να μας πειράζει λίγο. Μπορούμε να ελέγξουμε μόνο τα ορατά τμήματα των εικόνων, αλλά αυτό είναι πιο δύσκολο.

*   **Rocket: Σύγκρουση με Αστεροειδή (Slides 12 & 17):**
    *   **Στόχος:** Αν ο πύραυλος συγκρουστεί με ένα αστεροειδές (`Asteroid.class`).
    *   **Ποια μέθοδος θα χρησιμοποιήσουμε;** Η `getOneIntersectingObject(Asteroid.class)` είναι κατάλληλη για να ελέγξουμε αν ο πύραυλος αγγίζει οποιονδήποτε αστεροειδή.
    *   Προσθέστε μια νέα μέθοδο `checkCollision()` στην κλάση `Rocket`.
    *   Μέσα στη `checkCollision()`:
        *   Χρησιμοποιήστε `Actor a = getOneIntersectingObject(Asteroid.class);` για να ελέγξετε αν υπάρχει αστεροειδές σε επαφή. Η μέθοδος επιστρέφει `null` αν δεν υπάρχει επαφή.
        *   Αν `a != null` (υπάρχει σύγκρουση):
            *   Αφαιρέστε τον πύραυλο από τον κόσμο (`getWorld().removeObject(this);`).
            *   Προσθέστε μια έκρηξη (`space.addObject(new Explosion(), getX(), getY());`) - η κλάση Space είναι ο κόσμος, την ανακτούμε με `(Space) getWorld()`.
            *   Εμφανίστε το μήνυμα "Game Over" και το τελικό σκορ (θα το δούμε παρακάτω).
    *   Καλέστε τη μέθοδο `checkCollision()` μέσα στη μέθοδο `act()` του Rocket.

---

## Δημιουργία Εκρήξεων (Explosions) (Slide 19)

*   Στο Asteroids project, η κλάση `Explosion` έχει ήδη υλοποιηθεί για να δημιουργεί οπτικά εφέ έκρηξης.
*   Η κλάση `Explosion` χρησιμοποιεί animation με πολλά frames (όπως είδαμε με τον κάβουρα), τα οποία φορτώνονται στην static μέθοδο `initializeImages()`.
*   Μπορείτε να δείτε videos στο YouTube που εξηγούν την υλοποίηση της κλάσης `Explosion` (links στη διαφάνεια). Αν θέλετε πιο θεαματικές εκρήξεις, μπορείτε να τις δημιουργήσετε.

---

## Game Over και Score Board (Slides 20-23)

*   Το παιχνίδι πρέπει να τερματίζει όταν ο παίκτης χάνει (σύγκρουση με αστεροειδή).
*   Πρέπει να εμφανίζεται ένα μήνυμα "Game Over" και το τελικό σκορ.
*   Στο Asteroids project, υπάρχει μια κλάση `ScoreBoard` για αυτόν τον σκοπό.
*   **Κλάση `ScoreBoard` (Slides 21-22):**
    *   Είναι υποκλάση της `Actor`.
    *   Δηλώνει σταθερές για το μέγεθος και τη θέση του score board (`FONT_SIZE`, `WIDTH`, `HEIGHT`).
    *   Στον κατασκευαστή (`public ScoreBoard(int score)`), δημιουργεί την εικόνα του score board καλώντας τη μέθοδο `makeImage()`.
    *   Η μέθοδος `makeImage()` δημιουργεί μια `GreenfootImage` συγκεκριμένων διαστάσεων, γεμίζει ένα ορθογώνιο με χρώμα, ορίζει γραμματοσειρά και χρώμα κειμένου, και σχεδιάζει τις συμβολοσειρές "Game Over", "Score:", και την τιμή του σκορ στην εικόνα.
    *   Μπορείτε να πειραματιστείτε αλλάζοντας χρώματα, διαστάσεις, κείμενο κ.λπ.
*   **Εμφάνιση Score Board (Slides 20 & 23):**
    *   Προσθέστε μια μέθοδο `gameOver()` στην κλάση **`Space`**. Αυτή η μέθοδος θα καλείται όταν ο παίκτης χάνει.
    *   Μέσα στην `gameOver()` της κλάσης `Space`, δημιουργήστε ένα νέο στιγμιότυπο της κλάσης `ScoreBoard`, περνώντας ως όρισμα το σκορ του παίκτη (π.χ., `999` για παράδειγμα προς το παρόν), και προσθέστε το στον κόσμο σε μια κεντρική θέση (`addObject(new ScoreBoard(999), getWidth()/2, getHeight()/2);`).
    *   **Ενημέρωση `checkCollision()`:** Στη μέθοδο `checkCollision()` της κλάσης **`Rocket`**, αφού αφαιρεθεί ο πύραυλος και προστεθεί η έκρηξη, καλέστε τη μέθοδο `gameOver()` του κόσμου: `((Space)getWorld()).gameOver();`.
    *   **Σημαντικό:** Χρειάζεται να αποκτήσουμε πρόσβαση στο αντικείμενο του κόσμου και να το μετατρέψουμε σε τύπο `Space` (`(Space)getWorld()`) για να καλέσουμε την `gameOver()`, καθώς η `getWorld()` επιστρέφει τύπο `World`.

---

## Προσθήκη ενός Πιο Ισχυρού Όπλου: Proton Wave (Slides 24-35)

*   Στο παιχνίδι Asteroids, ο πύραυλος έχει συνήθως και ένα πιο ισχυρό όπλο. Στην περίπτωσή μας, είναι ένα κύμα πρωτονίων (Proton Wave).
*   **Proton Wave:** Ένα ισχυρό κύμα που εκτοξεύεται από τον πύραυλο, μεγαλώνει σταδιακά σε μέγεθος και προκαλεί ζημιά ή καταστρέφει αστεροειδείς εντός της ακτίνας του (Slide 24).
*   **Κλάση ProtonWave:** Υπάρχει ήδη στο project ως υποκλάση της `Actor`.
*   **Στατικές Μεταβλητές & Σταθερές (Slide 25):**
    *   Η κλάση `ProtonWave` δηλώνει σταθερές όπως `DAMAGE` (η ζημιά που προκαλεί το κύμα) και `NUMBER_IMAGES` (ο αριθμός των εικόνων animation για το κύμα).
    *   Δηλώνει επίσης έναν πίνακα `GreenfootImage[] images` για να αποθηκεύσει τις εικόνες animation.
*   **Αρχικοποίηση Πίνακα Εικόνων Κύματος (Slides 26-27):**
    *   Οι `NUMBER_IMAGES` εικόνες για το κύμα δημιουργούνται από **μία και μόνο εικόνα** (`"wave.png"`) χρησιμοποιώντας τη μέθοδο **`scale(int width, int height)`** της κλάσης `GreenfootImage`.
    *   Η static μέθοδος **`initializeImages()`** της κλάσης `ProtonWave` (που καλείται στον κατασκευαστή της κλάσης `Space`) φορτώνει την αρχική εικόνα `"wave.png"`.
    *   Χρησιμοποιεί έναν βρόχο για να δημιουργήσει κάθε frame στον πίνακα `images`, κλιμακώνοντας την αρχική εικόνα σε κατάλληλο μέγεθος (π.χ., `images[i].scale(size, size);`) όπου το `size` αυξάνεται σε κάθε επανάληψη.
*   **Σταδιακή Εμφάνιση Εικόνων Κύματος (Slide 28):**
    *   Για να εμφανίζονται σταδιακά οι εικόνες animation, η κλάση `ProtonWave` χρειάζεται:
        *   Ένα πεδίο `private int imageCount;` για να διατηρεί τον δείκτη της τρέχουσας εικόνας.
        *   Μια μέθοδο `grow()` που, σε κάθε κλήση, αυξάνει τον δείκτη, επιλέγει την επόμενη εικόνα από τον πίνακα (`setImage(images[imageCount]);`), και αν ο δείκτης φτάσει στο `NUMBER_IMAGES`, αφαιρεί το αντικείμενο `ProtonWave` από τον κόσμο (`getWorld().removeObject(this);`).
    *   Η μέθοδος `grow()` καλείται από τη μέθοδο `act()` της κλάσης `ProtonWave`.
*   **Δημιουργία Κύματος (Slide 29):**
    *   Στον κατασκευαστή της κλάσης `ProtonWave`, καλείται η `initializeImages()`, ορίζεται η εικόνα στο πρώτο frame (`setImage(images[0]);`) και παίζει έναν ήχο (`Greenfoot.playSound("proton.wav");`).
*   **Ενεργοποίηση Proton Wave - Εκτόξευση με Πλήκτρο (Slides 29-33):**
    *   Πως ενεργοποιείται το κύμα; Ο πύραυλος πρέπει να το εκτοξεύει.
    *   Στην `checkKeys()` μέθοδο του Rocket, προσθέστε έλεγχο για ένα πλήκτρο (π.χ., 'z').
    *   Αν πατηθεί το 'z', καλέστε μια νέα μέθοδο, π.χ., `startProtonWave()`.
    *   **Υλοποίηση `startProtonWave()` (Slide 30):** Αυτή η μέθοδος αρκεί να δημιουργεί ένα αντικείμενο `ProtonWave` (`new ProtonWave()`) και να το προσθέτει στον κόσμο στην τρέχουσα θέση του πύραυλου (`getWorld().addObject(wave, getX(), getY());`).
*   **Επαναφόρτιση & Καθυστέρηση (Slides 31-33):**
    *   Επειδή το proton wave είναι ισχυρό, δεν πρέπει να είναι συνεχώς διαθέσιμο. Πρέπει να υπάρχει **ελάχιστος χρόνος επαναφόρτισης**.
    *   Προσθέστε πεδία στην κλάση Rocket: `private static final int gunReloadTime = 5;` (ελάχιστος χρόνος μεταξύ πυροβολισμών), `private static final int protonReloadTime = 500;` (ελάχιστος χρόνος μεταξύ proton waves).
    *   Προσθέστε έναν **μετρητή χρόνου** (`private int protonDelayCount;`) για την καθυστέρηση μετά την εκτόξευση του proton wave.
    *   Στον κατασκευαστή του Rocket, αρχικοποιήστε το `protonDelayCount` με την τιμή της σταθεράς `protonReloadTime` ώστε να είναι σε θέση να εκτοξεύσει το κύμα αμέσως στην αρχή.
    *   Ενημερώνετε τον μετρητή (`protonDelayCount++`) σε κάθε βήμα της `act()` μεθόδου.
    *   Τροποποιήστε τη μέθοδο `startProtonWave()` ώστε να επιτρέπει την εκτόξευση **μόνο** αν ο μετρητής (`protonDelayCount`) είναι μεγαλύτερος ή ίσος από το `protonReloadTime`. Αν γίνει εκτόξευση, μηδενίστε τον μετρητή (`protonDelayCount = 0;`).

*   **Έλεγχος Σύγκρουσης Proton Wave - Αστεροειδών (Slides 33-35):**
    *   Το κύμα πρέπει να προκαλεί ζημιά στους αστεροειδείς εντός της ακτίνας του.
    *   Ποια μέθοδος εντοπισμού σύγκρουσης είναι κατάλληλη για έλεγχο εντός ακτίνας; Η μέθοδος **`getObjectsInRange(int radius, Class clss)`**.
    *   Προσθέστε τη μέθοδο ελέγχου σύγκρουσης (π.χ., `checkCollision()`) στην κλάση **`ProtonWave`**.
    *   Μέσα στη `checkCollision()` της `ProtonWave`:
        *   Υπολογίστε την **ακτίνα** του κύκλου ελέγχου. Μια καλή προσέγγιση είναι να χρησιμοποιήσετε την τρέχουσα διάσταση της εικόνας-κύματος (π.χ., `int range = getImage().getWidth()/2;`).
        *   Χρησιμοποιήστε `List<Asteroid> asteroids = getObjectsInRange(range, Asteroid.class);` για να πάρετε μια λίστα με όλους τους αστεροειδείς των οποίων το κέντρο βρίσκεται εντός της ακτίνας.
        *   Για **κάθε** αστεροειδή `a` σε αυτή τη λίστα, καλέστε μια νέα μέθοδο `hit()` στην κλάση `Asteroid`, περνώντας ως όρισμα τη ζημιά που προκαλεί το κύμα (`DAMAGE`). `a.hit(DAMAGE);`.
    *   Καλέστε την `checkCollision()` μέσα στη μέθοδο `act()` της κλάσης `ProtonWave`.
    *   **Μέθοδος `hit()` στην κλάση Asteroid (Slide 35):**
        *   Προσθέστε μια ιδιότητα `private int stability;` στην κλάση `Asteroid`. Η σταθερότητα ενημερώνεται μετά τη ζημιά.
        *   Στη μέθοδο `hit(int damage)`, μειώστε τη σταθερότητα του αστεροειδούς κατά τη ζημιά: `stability = stability - damage;`.
        *   Αν η `stability` φτάσει στην τιμή 0 ή κάτω από 0 (`if (stability <= 0)`), καλέστε μια νέα μέθοδο `breakUp()`.

*   **Διάσπαση/Καταστροφή Αστεροειδούς - `breakUp()` (Slide 36):**
    *   Η μέθοδος `breakUp()` στην κλάση `Asteroid` υλοποιεί τι συμβαίνει όταν ένας αστεροειδής καταστρέφεται.
    *   Παίζει έναν ήχο έκρηξης (`Greenfoot.playSound("Explosion.wav");`).
    *   Αν το μέγεθος του αστεροειδούς που χτυπήθηκε είναι μικρότερο ή ίσο από μια τιμή (π.χ., 16), ο αστεροειδής απλώς αφαιρείται από το παιχνίδι (`getWorld().removeObject(this);`).
    *   Αν το μέγεθος είναι μεγαλύτερο, ο αστεροειδής **διασπάται σε δύο μικρότερα** αστεροειδή (μισό μέγεθος). Δημιουργούνται δύο νέα στιγμιότυπα της κλάσης `Asteroid` με το νέο μέγεθος και διαφορετικές ταχύτητες/κατευθύνσεις (χρησιμοποιώντας το διάνυσμα κίνησης του αρχικού αστεροειδούς και την κλάση `Vector`) και προστίθενται στον κόσμο. Το αρχικό αστεροειδές αφαιρείται.

---

## Επεκτάσεις (Challenges) (Slide 37)

Αυτές είναι προαιρετικές ασκήσεις για εξάσκηση και περαιτέρω ανάπτυξη του παιχνιδιού:

*   **Challenge 1:** Διορθώστε τον μετρητή του σκορ (`ScoreBoard`) ώστε να ενημερώνεται και να εμφανίζει το **πραγματικό σκορ** του παίκτη (θα χρειαστεί να προσθέσετε ένα πεδίο σκορ στον κόσμο - κλάση `Space` - και να το ενημερώνετε κάθε φορά που καταστρέφεται/διασπάται αστεροειδές).
*   **Challenge 2:** Προσθέστε νέα επίπεδα. Κάθε φορά που καταστρέφονται όλοι οι αστεροειδείς ενός επιπέδου, ο παίκτης να αλλάζει επίπεδο (π.χ., με περισσότερους αστεροειδείς).
*   **Challenge 3:** Προσθέστε μια οπτική ένδειξη επαναφόρτισης του proton wave (π.χ., μια μπάρα ή ένα εικονίδιο).
*   **Challenge 4:** Προσθέστε μια ασπίδα για τον πύραυλο (π.χ., που ενεργοποιείται αφού συγκεντρωθούν κάποιοι πόντοι ή για περιορισμένο χρόνο) και τον προστατεύει από συγκρούσεις.
