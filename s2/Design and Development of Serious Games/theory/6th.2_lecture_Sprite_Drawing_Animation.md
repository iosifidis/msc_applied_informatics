# Sprite Drawing Animation

## Κινούμενα Σχέδια - Sprites (Slides 2-8)

*   **Τι είναι ένα Sprite (Slide 2):** Ένα sprite είναι ένα **διαφανές κινούμενο σχέδιο** που αποτελεί ένα αντικείμενο του παιχνιδιού. Συνήθως κινείται στην οθόνη και αλληλεπιδρά με άλλα sprites.
*   **Τύποι Sprite (Slide 2):** Υπάρχουν δύο βασικοί τύποι:
    *   **Ηθοποιοί - Actors:** Sprites που **κινούνται** και **αλληλεπιδρούν** ενεργά με άλλα sprites (π.χ., ο χαρακτήρας του παίκτη, οι εχθροί). Χαρακτηρίζονται ως **δυναμικά sprites (dynamic sprites)**.
    *   **Σκηνικά - Props:** **Στατικά sprites (static sprites)** που αποτελούν τμήμα του σκηνικού ή αντικείμενα που χρησιμοποιεί/μαζεύει ο παίκτης (π.χ., δέντρα, τοίχοι, νομίσματα).
*   **Σχεδίαση Sprites (Slides 3-8):**
    *   **Αντίληψη Υπολογιστή (Slide 3):** Ο υπολογιστής "αντιλαμβάνεται" ένα sprite ως ένα **ορθογώνιο**. Δεν υπάρχει απλός τρόπος αποθήκευσης ενός sprite χωρίς το ορθογώνιο πλαίσιο οριοθέτησης (boundary box) που το περιβάλλει.
    *   **Πραγματικότητα Sprite (Slide 3):** Ένα sprite αποτελείται κυρίως από τα pixels που συγκεντρώνονται στο κέντρο της εικόνας και αποτελούν συνήθως περίπου το μισό του συνολικού μεγέθους του ορθογωνίου πλαισίου.
    *   **Διαφανή Pixels (Slides 3-8):** Τι γίνεται με τα pixels ενός sprite που δεν θέλουμε να εμφανίζονται (τα "διαφανή" μέρη); Υπάρχουν διάφορες τεχνικές:
        *   **Σχεδίαση μόνο συμπαγών (solid) pixels (Slides 4-5):** Μια προφανής λύση θα ήταν να σχεδιάζονται μόνο τα pixels που δεν είναι διαφανή. Ωστόσο, η εκτέλεση ενός τέτοιου κώδικα pixel-προς-pixel είναι **αργή**, ειδικά με πολλούς sprites, και δεν ανταποκρίνεται σε πραγματικό χρόνο. Η διαδικασία μεταφοράς μιας εικόνας με διαφανή τμήματα από μια επιφάνεια σε μια άλλη παρέχεται **hardware-accelerated** από τις κάρτες video/γραφικών μέσω μιας βελτιστοποιημένης διαδικασίας γνωστής ως **bit block transfer** ή απλά **blit** (Slide 5). Δεν χρειάζεται να υλοποιήσουμε τον δικό μας blitter.
        *   **Alpha Blending (Slide 6):** Η κάρτα γραφικών χρησιμοποιεί μια διαδικασία γνωστή ως **alpha blending** για ημιδιαφανή εφέ (translucent effects) ή πλήρως διαφανή σχεδίαση. Το alpha channel είναι ένα επιπλέον κανάλι (πέρα από τα κόκκινο, πράσινο, μπλε) σε ένα 32-bit σύστημα γραφικών που αποθηκεύει την πληροφορία για το βαθμό διαφάνειας.
            *   0% διαύγεια (alpha = 0) σημαίνει **πλήρως διαφανές** (transparent) χρώμα.
            *   100% διαύγεια (alpha = 255) σημαίνει **συμπαγές** (opaque) χρώμα.
            *   50% διαύγεια σημαίνει μια **ημιδιαφανή** εικόνα.
        *   **Color Key (Slide 7):** Όταν ένα sprite πρέπει να σχεδιαστεί με διαφανή τμήματα, μπορεί να οριστεί ένα **χρώμα κλειδί (color key)**. Τα pixels με αυτό το συγκεκριμένο χρώμα σχεδιάζονται με 100% διαύγεια (πλήρως διαφανή) μέσω alpha blending. Όλα τα υπόλοιπα pixels δεν επηρεάζονται. Αυτή η μέθοδος δεν χρησιμοποιείται ιδιαίτερα σήμερα, έχει αντικατασταθεί από το alpha channel.
        *   **Alpha Channel (Slide 8):** Είναι ένα από τα 4 κανάλια ενός 32-bit συστήματος γραφικών που αποθηκεύει πληροφορίες για το βαθμό διαφάνειας. Στην ουσία πρόκειται για μια **μάσκα** που καθορίζει πώς θα αναμειχθούν τα χρώματα ενός pixel με ένα άλλο όταν το ένα επικαλύπτει το άλλο. Η χρήση του alpha channel δεν υποστηρίζεται από όλους τους τύπους αρχείων (π.χ., υποστηρίζεται από tga και png, αλλά όχι από bmp).

---

## Sprite Animation – Sprite Sheet (Slides 9-11)

*   Η κίνηση (animation) των sprite επιτυγχάνεται χρησιμοποιώντας ένα **sprite sheet**.
*   **Τι είναι ένα Sprite Sheet (Slide 9):** Ένα sprite sheet είναι ένα **bitmap** που περιλαμβάνει **γραμμές και στήλες από πλακάκια (tiles)**, όπου το καθένα περιλαμβάνει ένα **frame** της κίνησης.
*   **Frames ανά Κατεύθυνση (Slide 9):** Για ένα sprite που κινείται σε 8 κατευθύνσεις, υπάρχουν συνήθως 8 ή περισσότερα frames για κάθε κίνηση (π.χ., 64 frames συνολικά).
*   **Διαχείριση Animation (Slide 9):** Για την κίνηση ενός sprite, πρέπει να γνωρίζουμε ποιο είναι το **τρέχον frame** καθώς και τον **συνολικό αριθμό frames** για τη συγκεκριμένη κατεύθυνση κίνησης.
*   **Αντιγραφή Frame από Sprite Sheet (Slides 10-11):**
    *   Για την αντιγραφή ενός συγκεκριμένου frame από το sprite sheet, χρειάζεται να υπολογίσουμε τις συντεταγμένες (X, Y) του **πάνω αριστερού άκρου** του frame μέσα στο sprite sheet bitmap.
    *   **Υπολογισμός Υ συντεταγμένης (γραμμής) (Slide 10):** Διαιρούμε τον **αύξοντα αριθμό** (ΑΑ) του τρέχοντος frame (αρίθμηση ξεκινά από 0) με τον **αριθμό στηλών** (ΑΣ) στο sprite sheet και πολλαπλασιάζουμε το ακέραιο αποτέλεσμα με το **ύψος** του frame (ή αλλιώς του κάθε tile). `Y = (AA / ΑΣ) * tile-height`.
    *   **Υπολογισμός X συντεταγμένης (στήλης) (Slide 10):** Κρατάμε το **ακέραιο υπόλοιπο** της διαίρεσης του αύξοντα αριθμού (ΑΑ) του τρέχοντος frame με τον αριθμό στηλών (ΑΣ) και πολλαπλασιάζουμε το αποτέλεσμα με το **πλάτος** του frame (ή αλλιώς του κάθε tile). `X = (AA % ΑΣ) * tile-width`.
    *   **Ορθογώνιο Frame:** Έχοντας τις συντεταγμένες X και Y, το ορθογώνιο τμήμα (Rectangle) του sprite sheet που περιλαμβάνει το frame προσδιορίζεται χρησιμοποιώντας το ύψος και πλάτος του sprite/frame/tile. Αυτό το ορθογώνιο μπορεί να αντιγραφεί και να σχεδιαστεί στην οθόνη.
    *   **Παράδειγμα Υπολογισμού (Slide 11):** Αν ΑΑ = 17 και ΑΣ = 8: `Y = (17 / 8) * tile-height = 2 * tile-height`. `X = (17 % 8) * tile-width = 1 * tile-width`.

---

## Sprite Class (Slides 12-19)

*   Για να υλοποιήσουμε την κίνηση των sprites, θα ορίσουμε μια τυπική **κλάση `Sprite`** (Slide 12).
*   Στο παράδειγμα, η κλάση `Sprite` αναπαριστά έναν δράκο που κινείται σε 4 κατευθύνσεις και αλλάζει κατεύθυνση ελεγχόμενος από τον χρήστη.
*   **Enumerations (Slide 13):** Χρησιμοποιούνται enumerations (απαριθμήσεις) για τη διαχείριση των καταστάσεων animation:
    *   `AnimateWrap`: Για την επανάληψη της κίνησης αφού ολοκληρωθεί η ακολουθία frames (`WRAP` - επανάληψη από την αρχή, `BOUNCE` - κίνηση αντίστροφα).
    *   `AnimateDir`: Για την επιλογή του επόμενου frame (`NONE` - καμία κίνηση, `FORWARD` - επόμενο frame, `BACKWARD` - προηγούμενο frame).

*   **Πεδία της κλάσης `Sprite` (Slide 14):**
    *   `p_game`: Αναφορά σε αντικείμενο της **κλάσης `Game`** (για λειτουργίες σχεδίασης, εικόνων, κειμένου).
    *   `p_position` (τύπου `PointF`): Τρέχουσα θέση (συντεταγμένες X, Y).
    *   `p_velocity` (τύπου `PointF`): Ταχύτητα (μετατόπιση ως προς τους άξονες X και Y).
    *   `p_size` (τύπου `Size`): Width και Height κάθε frame/tile.
    *   `p_bitmap` (τύπου `Bitmap`): Το sprite sheet.
    *   `p_columns`: Αριθμός στηλών του sprite sheet.
    *   `p_totalFrames`: Συνολικός αριθμός frames του sprite sheet.
    *   `p_currentFrame`: Αύξων αριθμός τρέχοντος frame (0..`p_totalFrames`-1).
    *   `p_animationDir` (τύπου `AnimateDir`): Κατεύθυνση animation (NONE, FORWARD, BACKWARD).
    *   `p_animationWrap` (τύπου `AnimateWrap`): Επανάληψη animation (WRAP, BOUNCE).
    *   `p_lastTime`: Χρόνος της τελευταίας αλλαγής frame (σε milliseconds).
    *   `p_animationRate`: Ρυθμός ανανέωσης εικόνας (frames per second).

*   **Properties (Slide 15):** Η κλάση `Sprite` έχει ορίσει properties για πρόσβαση στις ιδιωτικές μεταβλητές-πεδία. Σε κάποιες περιπτώσεις (π.χ., `AnimationRate`), η τιμή που ανατίθεται ελέγχεται και το πεδίο ενημερώνεται κατάλληλα (π.χ., η τιμή της ιδιότητας είναι frames per second, ενώ το πεδίο αποθηκεύει milliseconds ανά frame).

*   **Μέθοδος `Animate` (Slides 16-17):**
    *   Η μέθοδος (`public void Animate(int startFrame, int endFrame)`) περνάει ως ορίσματα τον αύξοντα αριθμό του 1ου και του τελευταίου frame/tile στο sprite sheet που αντιστοιχεί στην τρέχουσα κατεύθυνση κίνησης.
    *   **Έλεγχος Χρόνου (Slide 16):** Χρησιμοποιεί το `Environment.TickCount` (αριθμός milliseconds από την έναρξη του παιχνιδιού) για να ελέγξει αν έχουν περάσει αρκετά milliseconds (`p_animationRate`) από την προηγούμενη ενημέρωση του frame.
    *   **Επιλογή Επόμενου Frame (Slide 17):** Η μεταβλητή `p_currentFrame` ενημερώνεται με τον αύξοντα αριθμό του επόμενου frame. Ανάλογα με την τιμή της `p_animationDir` (NONE, FORWARD, BACKWARD), το frame μπορεί να παραμείνει το ίδιο, να επιλεγεί το επόμενο ή το προηγούμενο.
    *   **Έλεγχος Ορίων Frame:** Ελέγχεται αν η `p_currentFrame` έχει πάρει τιμή εκτός του επιτρεπτού διαστήματος (`startFrame` έως `endFrame`).
    *   **Επανάληψη Animation (Slide 17):** Αν το frame φτάσει το τέλος του εύρους, ο έλεγχος και η ενημέρωση πραγματοποιούνται κατάλληλα για τις 2 διαφορετικές περιπτώσεις συνέχισης της κίνησης (WRAP, BOUNCE), οι οποίες καθορίζονται από την μεταβλητή `p_animationWrap`.

*   **Μέθοδος `Draw` (Slide 18):**
    *   Η μέθοδος (`public void Draw()`) σχεδιάζει το τρέχον frame του sprite στην οθόνη.
    *   Υπολογίζει το ορθογώνιο τμήμα (Rectangle) του sprite sheet (`p_bitmap`) που περιλαμβάνει το τρέχον frame (με βάση το `p_currentFrame`, `p_columns`, `p_size.Width`, `p_size.Height`).
    *   Χρησιμοποιεί τη μέθοδο **`DrawImage()`** του αντικειμένου `Graphics` (`p_game.Device`) για να σχεδιάσει το frame στην οθόνη στη θέση (`p_position.X, p_position.Y`).

*   **Έλεγχος Σύγκρουσης (Slide 19):**
    *   Προσθέτουμε μια μέθοδο (`public bool IsColliding(ref Sprite other)`) για έλεγχο σύγκρουσης με άλλο sprite.
    *   Υπολογίζει το ορθογώνιο πλαίσιο οριοθέτησης (`Bounds`) του τρέχοντος sprite.
    *   Χρησιμοποιεί τη μέθοδο **`IntersectsWith()`** της κλάσης `Rectangle` για να ελέγξει αν το ορθογώνιο του τρέχοντος sprite τέμνεται με το ορθογώνιο του άλλου sprite (`other.Bounds`).

---

## Επέκταση της Κλάσης Game (Slide 20)

Για να κάνουμε το framework πιο χρήσιμο, η κλάση `Game` μπορεί να επεκταθεί ώστε να περιλαμβάνει επιπλέον μεθόδους για κοινές λειτουργίες σχεδίασης και διαχείρισης:

*   `SetFont()`: Αλλαγή γραμματοσειράς.
*   `Print()`: Εμφάνιση κειμένου οπουδήποτε στο παράθυρο.
*   `DrawBitmap()`: Σχεδίαση ενός bitmap οπουδήποτε στο παράθυρο με επιθυμητές διαστάσεις (π.χ., για background).

---

## Ο Κώδικας της Φόρμας (Slides 21-27)

Η κλάση `Form1` (η φόρμα του Windows Forms) διαχειρίζεται τον βασικό βρόχο του παιχνιδιού και τα συμβάντα.

*   **Πεδία της κλάσης Form1 (Slide 22):**
    *   `p_game` (τύπου `Game`): Αναφορά στην game engine (το framework που φτιάξαμε).
    *   `p_gameOver` (boolean): Flag για τον έλεγχο τερματισμού του παιχνιδιού.
    *   `p_startFrame` (int), `p_currentTime` (int): Χρησιμοποιούνται ως χρονόμετρο για τον υπολογισμό του πραγματικού αριθμού FPS (Frames Per Second).
    *   `p_currentFrame` (int): Τρέχουσα "ώρα" (milliseconds) από την έναρξη του παιχνιδιού μέχρι τη στιγμή της ενημέρωσης.
    *   `dragonSprite` (τύπου `Sprite`): Το sprite sheet για τον δράκο.
    *   `grass` (τύπου `Bitmap`): Το sprite sheet για το γρασίδι (background).
    *   `frameCounter` (int), `frameTimer` (int), `frameRate` (float): Χρησιμοποιούνται για τον υπολογισμό του πραγματικού αριθμού FPS.
    *   `velocity` (τύπου `PointF`): Ταχύτητα του δράκου.
    *   `direction` (int): Κατεύθυνση κίνησης (αρχική: 2 = EAST).

*   **Μέθοδοι της κλάσης Form1 (Slide 23):**
    *   `Main()`: Παίζει το ρόλο του κυρίως προγράμματος και υλοποιεί τον **βρόχο του παιχνιδιού**.
    *   `Game_KeyPressed()`: Event handler για το πάτημα πλήκτρου. Παρέχει δυνατότητα ελέγχου της κίνησης του δράκου από το πληκτρολόγιο.
        *   Ελέγχει αν ο χρήστης πάτησε ESC, οπότε καλεί τη μέθοδο `Shutdown()` για τερματισμό.
        *   Αν πάτησε κάποιο από τα βελάκια, ενημερώνει το πεδίο `direction` που καθορίζει την κίνηση του δράκου.
    *   `ShutDown()`: Τερματίζει το παιχνίδι (ενημερώνει το `p_gameOver` flag και καλεί `Application.Exit()`).

*   **Ο Βρόχος του Παιχνιδιού - `Main()` (Slides 24-27):**
    *   **Αρχικοποίηση (Slide 24):**
        *   Δημιουργία του αντικειμένου `Game` (framework) περνώντας αναφορά στη φόρμα και διαστάσεις: `game = new Game(ref form, 800, 600);`.
        *   Κλήση της μεθόδου `Game_Init()` (βλ. παρακάτω) για φόρτωση και αρχικοποίηση των περιουσιακών στοιχείων του παιχνιδιού (`game assets`).
    *   **Βασικός Βρόχος (Slide 24):** Υλοποιείται με ένα βρόχο `while (!p_gameOver)`.
        *   **Χρονόμετρο (Slide 25):** Ενημέρωση της μεταβλητής `p_currentTime` με τον αριθμό των milliseconds που πέρασαν από την έναρξη. Λειτουργεί ως χρονόμετρο για την ενημέρωση της στιγμής.
        *   **Gameplay Code Update (Slide 25):** Κλήση της μεθόδου `Game_Update(p_currentTime)` (βλ. παρακάτω) η οποία ενημερώνει την κατάσταση του παιχνιδιού (π.χ., έλεγχος συγκρούσεων, σκορ κτλ.).
        *   **Refresh at 60 FPS (Slides 26-27):** Ένας `if` όρος ελέγχει αν έχουν περάσει τουλάχιστον 16 milliseconds (`p_currentTime > p_startTime + 16`) από την προηγούμενη ενημέρωση γραφικών. Αυτό εξασφαλίζει εκτέλεση του κώδικα εντός του if με ρυθμό τουλάχιστον 60 frames per second.
            *   Εντός του if: Ενημέρωση της `p_startTime` με την τρέχουσα "ώρα" (`p_currentTime`). Κλήση της μεθόδου `Game_Draw()` (βλ. παρακάτω) για την ενημέρωση των γραφικών του παιχνιδιού.
            *   Επεξεργασία Συμβάντων (Slide 26): Κλήση της `Application.DoEvents()` για να επεξεργαστούν όλα τα μηνύματα/συμβάντα που βρίσκονται στην ουρά. Χωρίς αυτό, η εφαρμογή δεν θα ανταποκρίνεται σε ενέργειες χρήστη.
        *   **Τέλος Βρόχου:** Ο βρόχος τερματίζει όταν το `p_gameOver` γίνει `true`. Καλείται η `Game_End()` (βλ. παρακάτω) και η εφαρμογή τερματίζει (`Application.Exit()`).
        *   **Υπολογισμός FPS (Slide 27):** Εντός του if, υπολογίζεται ο πραγματικός αριθμός FPS. Αυξάνεται ο μετρητής `frameCount`. Αν έχει περάσει ένα δευτερόλεπτο (`p_currentTime > frameTimer + 1000`), ο `frameTimer` ενημερώνεται, η `frameRate` υπολογίζεται (frames ανά δευτερόλεπτο) και ο `frameCount` μηδενίζεται.

---

## Gameplay Μέθοδοι (Slides 28-31)

*   **`Game_Init()` (Slide 28):** Εκτελείται πριν από την έναρξη του βρόχου του παιχνιδιού. Στη μέθοδο αυτή φορτώνονται και αρχικοποιούνται τα περιουσιακά στοιχεία του παιχνιδιού (game assets), όπως τα sprite sheets.
*   **`Game_Update(int time)` (Slide 29):** Εκτελείται επαναληπτικά στο βρόχο του παιχνιδιού. Ενημερώνει την κατάσταση του παιχνιδιού (π.χ., ελέγχει για συγκρούσεις sprite, ενημερώνει το σκορ κτλ.).
*   **`Game_Draw()` (Slide 30):** Εκτελείται εντός του χρονομετρούμενου τμήματος του βρόχου (για σταθερό FPS). Σχεδιάζει το background και καλεί τις μεθόδους κίνησης (`Animate`, `Draw`) του δράκου.
*   **`Game_KeyPressed(System.Windows.Forms.Keys key)` (Slide 31):** Ο event handler για το πάτημα πλήκτρου. Ελέγχει ποιο πλήκτρο πατήθηκε και ενημερώνει την κατάσταση του παιχνιδιού (π.χ., κατεύθυνση δράκου, τερματισμός).

