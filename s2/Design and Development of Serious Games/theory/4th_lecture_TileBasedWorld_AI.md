# Greenfoot TileBasedWorld AI

## MazeWorld: Ένα Παράδειγμα Σύνθετου Κόσμου (Slide 2)

*   Το project "MazeWorld" παρουσιάζει ένα παιχνίδι όπου ο παίκτης (ένας πεζοπόρος - Hiker) κινείται σε ένα **λαβύρινθο** γεμάτο **εμπόδια** και **εχθρούς**.
*   Οι εχθροί έχουν διαφορετικά επίπεδα **νοημοσύνης**, κάνοντας το παιχνίδι πιο δύσκολο και ενδιαφέρον.

---

## Σχεδίαση του Χάρτη του Παιχνιδιού (Slides 3-5)

*   Στο MazeWorld, ο χάρτης του παιχνιδιού δημιουργείται από **πλακίδια (tiles)**. Κάθε πλακίδιο έχει συγκεκριμένη διάσταση (25x25 pixels).
*   **Τύποι Πλακιδίων (Slide 3):** Υπάρχουν 4 διαφορετικοί τύποι πλακιδίων, συμβολιζόμενοι με χαρακτήρες και σχεδιασμένοι με τη βοήθεια 4 κλάσεων (υποκλάσεις της `ScrollingObstacle`):
    *   **B:** Μη προσβάσιμη περιοχή (μαύρο χρώμα - `BlackBlock`).
    *   **U:** Σταθερό εμπόδιο (μπλε χρώμα - `BlueBlock`).
    *   **W:** Προσβάσιμη περιοχή (λευκό χρώμα - `WhiteBlock`).
    *   **G:** Στόχος - θησαυρός (κίτρινο χρώμα - `GoldBlock`).
*   **Αποθήκευση Πληροφορίας Χάρτη (Slide 3-4):** Η πληροφορία για τον τύπο κάθε πλακιδίου αποθηκεύεται σε έναν **πίνακα αλφαριθμητικών (String[])** με όνομα `WORLD`. Κάθε στοιχείο του πίνακα αναπαριστά μια σειρά πλακιδίων (ένα "string") και ο συνολικός πίνακας αναπαριστά τον δισδιάστατο χάρτη.
*   **Δημιουργία Κόσμου από Πλακίδια (Slide 5):**
    *   Η κλάση `MazeWorld` **κληρονομεί** από την `World`.
    *   Υπάρχει μια ιδιωτική μέθοδος `createWorldFromTiles()` που διαβάζει τον πίνακα `WORLD`.
    *   Χρησιμοποιεί ένα **διπλό βρόχο `for`** για να διατρέξει τα στοιχεία του πίνακα (σειρές και στήλες).
    *   Για κάθε χαρακτήρα (πλακίδιο) στον πίνακα, καλεί μια μέθοδο `addActorAtTileLocation()` που δημιουργεί το αντίστοιχο αντικείμενο (π.χ., `new BlueBlock()`) και το προσθέτει στον κόσμο στην σωστή θέση, βασιζόμενη στη θέση του στον πίνακα και τη διάσταση των πλακιδίων.
*   **Κλάσεις για Πλακίδια και Χαρακτήρες (Slide 5):**
    *   `ScrollingObstacle`: Αφηρημένη κλάση για εμπόδια.
    *   `BlueBlock`, `BlackBlock`, `WhiteBlock`, `GoldBlock`: Υποκλάσεις της `ScrollingObstacle` για τους διάφορους τύπους πλακιδίων.
    *   `ScrollingEnemy`: Αφηρημένη κλάση για εχθρούς (Spider, Snake, Mouse είναι υποκλάσεις).
    *   `Hiker`: Η κλάση του παίκτη.

---

## Χαρακτήρες με Νοημοσύνη (Slides 6-11)

*   Στο MazeWorld, οι εχθροί έχουν διαφορετικά επίπεδα νοημοσύνης (`AI`) για να δυσκολεύουν τον παίκτη.
*   **Τεχνικές Τεχνητής Νοημοσύνης (Slide 6):**
    *   **Τυχαία κίνηση:** Η πιο απλή τεχνική (π.χ., `Spider`).
    *   **Ευρετικοί κανόνες συμπεριφοράς:** Βασίζονται σε απλούς κανόνες "αν-τότε" (π.χ., `Snake`).
    *   **Έξυπνη εύρεση μονοπατιού:** Χρήση αλγορίθμων όπως ο Α\* για εύρεση βέλτιστου μονοπατιού αποφεύγοντας εμπόδια (π.χ., `Mouse`).

*   **Αφηρημένη κλάση ScrollingEnemy (Slides 7-8):**
    *   Ορίζει κοινά σημεία στη συμπεριφορά των "έξυπνων" χαρακτήρων.
    *   Η μέθοδος `act()` περιλαμβάνει 3 αφηρημένες ενέργειες (μεθόδους) που υλοποιούνται στις υποκλάσεις:
        *   `sense()`: Αισθάνεται το περιβάλλον (π.χ., αν είναι κοντά στον παίκτη).
        *   `reaction()`: Επιλέγει τον τρόπο δράσης ανάλογα με το τι αισθάνθηκε στο προηγούμενο βήμα.
        *   `boundedMove()`: Μετακινεί κατάλληλα τον χαρακτήρα, λαμβάνοντας υπόψη τα όρια του κόσμου ή άλλα εμπόδια.
    *   **Ενημέρωση κίνησης:** Οι μέθοδοι `sense` και `reaction` αλλάζουν τις τιμές των μεταβλητών `speedX` και `speedY` του εχθρού, επηρεάζοντας την κίνηση.
    *   **`boundedMove()`:** Υλοποιείται στην `ScrollingEnemy`. Μετακινεί το αντικείμενο κατά `speedX`, `speedY` και ελέγχει αν η νέα θέση τέμνεται με εμπόδιο (`ScrollingObstacle`). Αν ναι, επαναφέρει την προηγούμενη θέση.

*   **Τυχαία κίνηση: Spider (Slide 9):**
    *   Υποκλάση της `ScrollingEnemy`.
    *   Απλή τεχνική: Η αράχνη κινείται με τυχαίο τρόπο.
    *   Δεν υλοποιεί τη μέθοδο `sense()`.
    *   Η μέθοδος `reaction()` θέτει στις μεταβλητές `speedX` και `speedY` την τιμή 1, 0, ή -1 με μικρή πιθανότητα (π.χ., 2%) για να αλλάξει κατεύθυνση σποραδικά.

*   **Ευρετικοί κανόνες συμπεριφοράς: Snake (Slides 10-11):**
    *   Υποκλάση της `ScrollingEnemy`.
    *   Η μέθοδος `sense()` ελέγχει αν ο παίκτης (`Hiker`) βρίσκεται σε μια ακτίνα γύρω από το φίδι (`getObjectsInRange(INRANGE, Hiker.class)`). Ενημερώνει ένα πεδίο `pathing` (boolean ή άλλο) ανάλογα.
    *   Η μέθοδος `reaction()`, ανάλογα με την τιμή του `pathing`:
        *   Αν ο παίκτης **δεν** είναι κοντά, το φίδι κινείται πίσω-μπρος (αλλάζει την τιμή του `speedX` μετά από συγκεκριμένο αριθμό βημάτων).
        *   Αν ο παίκτης **είναι** κοντά, το φίδι κυνηγά τον πεζοπόρο, θέτοντας τα `speedX`, `speedY` προς την κατεύθυνση του παίκτη (χρησιμοποιώντας τερματικό τελεστή ? : ).

*   **Έξυπνη εύρεση μονοπατιού: Mouse (Slides 12-14)**
    *   Υποκλάση της `ScrollingEnemy`.
    *   Χρησιμοποιεί τον **αλγόριθμο Α\*** για να βρει ένα μονοπάτι ανάμεσα σε 2 σημεία (από την τρέχουσα θέση του ποντικιού στη θέση του παίκτη) αποφεύγοντας τα εμπόδια.
    *   **Αναπαράσταση Περιοχής:** Χρησιμοποιείται ένα στιγμιότυπο της κλάσης **`Tile`** για κάθε περιοχή (πλακίδιο) του χάρτη.
    *   **Θέση Tile:** Η θέση κάθε `Tile` προσδιορίζεται με ένα στιγμιότυπο της κλάσης **`Point`** (καθορίζει γραμμή και στήλη) μέσα στο νοητό πλέγμα του χάρτη.
    *   **Πληροφορία Χάρτη:** Η πληροφορία για όλα τα `Tiles` αποθηκεύεται σε έναν δισδιάστατο πίνακα **`tileWorld`**.
    *   **Πώς Λειτουργεί ο Α\* (Slide 13):** Ο αλγόριθμος εξερευνά περιοχές στον χάρτη σε επαναλήψεις. Σε κάθε επανάληψη, συγκρίνει τις "υποψήφιες" περιοχές (τους κόμβους στην Open List) και επιλέγει εκείνη με την μικρότερη τιμή **F**.
    *   **Υπολογισμός Τιμής F (Slide 14):** Για κάθε περιοχή (κόμβο), ο Α\* υπολογίζει μια τιμή F βασιζόμενος σε δύο παράγοντες:
        *   **H (Heuristic):** Προσεγγίζει την **απόσταση που απομένει** μέχρι τη θέση-στόχο. Στο MazeWorld, χρησιμοποιείται η **Manhattan distance** (άθροισμα των απόλυτων διαφορών συντεταγμένων x και y).
        *   **G (Cost):** Η **απόσταση που έχει ήδη διανυθεί** από την αρχική θέση μέχρι τον τρέχοντα κόμβο.
        *   Η τιμή F είναι το **άθροισμα G + H**. Ο αλγόριθμος Α\* αναζητά το μονοπάτι με την μικρότερη συνολική τιμή F.
    *   **Υλοποίηση Α\* (Slide 14-15):** Ο αλγόριθμος υλοποιείται στην κλάση **`TiledWorldPathfinding`**. Τα βήματα του αλγορίθμου είναι:
        1.  Πρόσθεσε την αρχική θέση στην Open List.
        2.  Διάλεξε τον κόμβο στην Open List με την ελάχιστη τιμή F.
        3.  Αφαίρεσε τον επιλεγμένο κόμβο από την Open List και πρόσθεσέ τον στην Closed List.
        4.  Για κάθε γείτονα του επιλεγμένου κόμβου που δεν είναι ήδη στην Closed List και δεν περιέχει εμπόδιο:
            α. Υπολόγισε την τιμή F και όρισε τον τρέχοντα κόμβο ως γονέα του γείτονα.
            β. Αν ο γείτονας δεν είναι ήδη στην Open List, πρόσθεσέ τον.
            γ. Αν ο γείτονας είναι ήδη στην Open List, ενημέρωσε την τιμή F και τον γονέα του αν βρεθεί καλύτερο μονοπάτι.
        5.  Αν ο στόχος δεν έχει επιτευχθεί, πήγαινε στο βήμα 2.
        6.  Αν ο στόχος επιτευχθεί, κατασκεύασε το μονοπάτι από την αρχική θέση μέχρι την τελική ανατρέχοντας στους γονείς (backtracking).

