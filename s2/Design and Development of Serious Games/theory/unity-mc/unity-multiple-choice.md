# **Ερωτήσεις Πολλαπλής Επιλογής - Unity Brief Tutorial**

1.  Τι είναι μια "Scene" στη Unity;
    Α. Ένα μεμονωμένο GameObject.
    Β. Μια ενότητα του παιχνιδιού, όπως ένα επίπεδο ή μια οθόνη τίτλου.
    Γ. Ένα Script που καθορίζει τη συμπεριφορά.
    Δ. Ένα αρχείο ήχου ή εικόνας.

2.  Ποιο είναι το αντικείμενο που αντιπροσωπεύει την οπτική περιοχή που βλέπει ο παίκτης στην οθόνη;
    Α. GameObject
    Β. Component
    Γ. Camera
    Δ. Scene

3.  Ποιο είναι το βασικό "δομικό στοιχείο" σε μια σκηνή της Unity;
    Α. Component
    Β. Script
    Γ. GameObject
    Δ. Asset

4.  Τι προσδίδουν τα "Components" σε ένα GameObject;
    Α. Το όνομά του.
    Β. Την ικανότητα να λειτουργεί και να αλληλεπιδρά.
    Γ. Τη σύνδεσή του με άλλα GameObjects.
    Δ. Την εμφάνισή του στην ιεραρχία.

5.  Ποιο component υπάρχει αναγκαστικά σε κάθε GameObject;
    Α. Renderer
    Β. Collider
    Γ. Rigidbody
    Δ. Transform

6.  Το component Transform ελέγχει:
    Α. Τη θέση, την περιστροφή και την κλίμακα του GameObject.
    Β. Τη φυσική συμπεριφορά του GameObject.
    Γ. Τα όρια σύγκρουσης του GameObject.
    Δ. Την οπτική εμφάνιση του GameObject.

7.  Τι ονομάζονται τα 2D αντικείμενα με γραφικές εικόνες (textures) στη Unity, όταν βρίσκονται σε λειτουργία 2D;
    Α. Meshes
    Β. Models
    Γ. Sprites
    Δ. Particles

8.  Όταν σύρουμε ένα αρχείο εικόνας (PNG, JPG) από μια εξωτερική πηγή στην περιοχή Assets της Unity, αυτό γίνεται:
    Α. Ένα Script.
    Β. Ένα Scene.
    Γ. Ένα Prefab.
    Δ. Ένα Asset/Texture.

9.  Ποιο component προσαρτάται αυτόματα σε ένα νέο GameObject που δημιουργείται από ένα Sprite;
    Α. Mesh Renderer
    Β. Sprite Renderer
    Γ. Animator
    Δ. Audio Source

10. Ποιο εργαλείο επεξεργασίας χρησιμοποιείται για τη μετακίνηση αντικειμένων στον κόσμο του παιχνιδιού;
    Α. Hand Tool
    Β. Move Tool
    Γ. Rotate Tool
    Δ. Scale Tool

11. Ποιο εργαλείο επεξεργασίας χρησιμοποιείται για την αλλαγή του μεγέθους των αντικειμένων;
    Α. Move Tool
    Β. Rotate Tool
    Γ. Scaling Tool
    Δ. Rect Tool

12. Τι είναι το Object Parenting στη Unity;
    Α. Η δημιουργία ενός αντιγράφου ενός GameObject.
    Β. Η σύνδεση GameObjects σε μια ιεραρχική σχέση γονέα-παιδιού.
    Γ. Η προσθήκη ενός Component σε ένα GameObject.
    Δ. Η φόρτωση ενός Scene.

13. Όταν ένα GameObject έχει έναν γονέα, οι αλλαγές μετασχηματισμού του γίνονται σε σχέση με:
    Α. Τον κόσμο του παιχνιδιού (την αρχή (0,0,0)).
    Β. Τη θέση της Κάμερας.
    Γ. Τον γονέα του.
    Δ. Άλλα GameObjects στην ιεραρχία.

14. Ποια από τις παρακάτω επιλογές ΔΕΝ είναι παράδειγμα Internal Asset στη Unity;
    Α. Scene
    Β. Animation
    Γ. Script
    Δ. .blend file (Blender model)

15. Τι είναι τα "Prefabs";
    Α. Scripts για τη δυναμική συμπερι behavior.
    Β. Ολοκληρωμένα "προσχέδια" για GameObjects που μπορούν να δημιουργηθούν δυναμικά.
    Γ. Εσωτερικά αρχεία ήχου και εικόνας.
    Δ. Ειδικά Components για UI στοιχεία.

16. Ποια είναι η επέκταση αρχείου για τις Scenes στη Unity;
    Α. .asset
    Β. .prefab
    Γ. .scene
    Δ. .unity

17. Πώς αποθηκεύουμε την τρέχουσα εργασία μας ως μια Scene;
    Α. File > Save Project
    Β. File > New Scene
    Γ. File > Save Scene As
    Δ. Assets > Create > Scene

18. Ποια είναι η γλώσσα προγραμματισμού που χρησιμοποιείται συνήθως για Scripting στη Unity;
    Α. Java
    Β. Python
    Γ. C++
    Δ. C#

19. Από ποια βασική κλάση πρέπει να κληρονομεί ένα Script για να λειτουργεί ως component σε GameObject;
    Α. Component
    Β. GameObject
    Γ. ScriptableObject
    Δ. MonoBehaviour

20. Ποια Callback function καλείται ΜΙΑ ΦΟΡΑ όταν ξεκινάει το παιχνίδι, πριν από κάθε Update;
    Α. Awake()
    Β. Start()
    Γ. Update()
    Δ. FixedUpdate()

21. Ποια Callback function καλείται σε ΚΑΘΕ frame;
    Α. Start()
    Β. FixedUpdate()
    Γ. Update()
    Δ. LateUpdate()

22. Ποια Callback function καλείται πριν από την Start() και χρησιμοποιείται για αρχικοποίηση ανεξάρτητα από την ενεργοποίηση του script;
    Α. Start()
    Β. Awake()
    Γ. FixedUpdate()
    Δ. LateUpdate()

23. Ποια Callback function είναι κατάλληλη για την ενημέρωση του κώδικα Φυσικής (Physics code);
    Α. Update()
    Β. FixedUpdate()
    Γ. LateUpdate()
    Δ. Start()

24. Ποια Callback function καλείται σε κάθε frame ΜΕΤΑ από την Update();
    Α. FixedUpdate()
    Β. Start()
    Γ. LateUpdate()
    Δ. Awake()

25. Πώς εμφανίζεται ένα `public` πεδίο ενός Script στη διεπαφή της Unity;
    Α. Στο παράθυρο Console.
    Β. Στον Inspector του GameObject στο οποίο είναι συνδεδεμένο το script.
    Γ. Ως error στο παράθυρο Project.
    Δ. Στο παράθυρο Hierarchy.

26. Ποια κλάση χρησιμοποιείται για τον έλεγχο της εισόδου από τον χρήστη (πληκτρολόγιο, ποντίκι);
    Α. Transform
    Β. Rigidbody
    Γ. Input
    Δ. Physics

27. Ποια μέθοδος της κλάσης Input επιστρέφει έναν πραγματικό αριθμό μεταξύ -1 και 1, ανάλογα με την είσοδο ενός άξονα (π.χ., Horizontal, Vertical);
    Α. GetKey()
    Β. GetButton()
    Γ. GetAxis()
    Δ. GetMouseButton()

28. Ποια μέθοδος της κλάσης Input επιστρέφει -1, 0, ή 1 (χωρίς ενδιάμεσες τιμές) για την είσοδο ενός άξονα;
    Α. GetAxis()
    Β. GetAxisRaw()
    Γ. GetKeyDown()
    Δ. GetKeyUp()

29. Ποιο component χρησιμοποιείται για τον ορισμό των φυσικών ορίων σύγκρουσης ενός αντικειμένου;
    Α. Rigidbody
    Β. Collider
    Γ. Transform
    Δ. Animator

30. Ποια ιδιότητα (property) ενός Collider καθορίζει αν αυτός λειτουργεί ως εμπόδιο (blocking) ή πυροδοτητής (trigger) για ειδοποιήσεις;
    Α. Size
    Β. Offset
    Γ. Radius
    Δ. Is Trigger

31. Ποιο component πρέπει να υπάρχει σε τουλάχιστον ένα από τα εμπλεκόμενα GameObjects για να λειτουργήσουν οι συναρτήσεις OnCollisionEnter/Exit/Stay ή OnTriggerEnter/Exit/Stay;
    Α. Animator
    Β. Audio Source
    Γ. Rigidbody
    Δ. Transform

32. Ποια Callback function εκτελείται όταν ένα αντικείμενο ΕΙΣΕΡΧΕΤΑΙ σε ένα trigger;
    Α. OnCollisionEnter()
    Β. OnTriggerEnter()
    Γ. OnCollisionStay()
    Δ. OnTriggerStay()

33. Ποια Callback function εκτελείται όσο ένα αντικείμενο ΠΑΡΑΜΕΝΕΙ σε επαφή με ένα collider;
    Α. OnCollisionStay()
    Β. OnCollisionEnter()
    Γ. OnTriggerStay()
    Δ. OnTriggerEnter()

34. Ποιο component επιτρέπει σε ένα GameObject να αντιδρά σε αρχές φυσικής (βάρος, βαρύτητα, μάζα);
    Α. Collider
    Β. Trigger
    Γ. Rigidbody
    Δ. Physics Material

35. Ποιο πεδίο ενός Rigidbody/Rigidbody2D ορίζει την επίδραση της βαρύτητας σε αυτό;
    Α. Mass
    Β. Drag
    Γ. Angular Drag
    Δ. Gravity Scale

36. Τι ορίζει το πεδίο "Drag" σε ένα Rigidbody;
    Α. Την περιστροφική αδράνεια.
    Β. Την αντίσταση στην κίνηση (επιβράδυνση).
    Γ. Τη μάζα του αντικειμένου.
    Δ. Την επίδραση της βαρύτητας.

37. Τι επιτυγχάνεται συνήθως ορίζοντας την ιδιότητα "Gravity Scale" ενός Rigidbody2D στην τιμή 0 σε ένα 2D παιχνίδι πλατφόρμας;
    Α. Το αντικείμενο δεν μπορεί να κινείται.
    Β. Το αντικείμενο δεν επηρεάζεται από τη βαρύτητα του κόσμου.
    Γ. Το αντικείμενο περιστρέφεται ελεύθερα.
    Δ. Το αντικείμενο δεν συγκρούεται με άλλα.

38. Ποια μέθοδος ενός Rigidbody2D χρησιμοποιείται συνήθως για να μετακινήσετε το αντικείμενο με βάση την ταχύτητά του στο FixedUpdate;
    Α. AddForce()
    Β. transform.Translate()
    Γ. MovePosition()
    Δ. transform.position =

39. Ποιος τύπος Collider 2D είναι κατάλληλος για ένα όρθιο, όρθιο 2D χαρακτήρα;
    Α. Box Collider 2D
    Β. Circle Collider 2D
    Γ. Capsule Collider 2D
    Δ. Edge Collider 2D

40. Πώς δημιουργούμε ένα Prefab από ένα υπάρχον GameObject στην ιεραρχία;
    Α. File > Save Scene As
    Β. GameObject > Create Prefab
    Γ. Σύροντας το GameObject από την Hierarchy στην περιοχή Assets.
    Δ. Σύροντας το GameObject από την Hierarchy στην περιοχή Project Settings.

41. Ποια μέθοδος χρησιμοποιείται για τη δυναμική δημιουργία ενός αντιγράφου ενός Prefab (Instantiation) κατά τον χρόνο εκτέλεσης;
    Α. Create()
    Β. Instantiate()
    Γ. NewPrefab()
    Δ. Clone()

42. Ποια μέθοδος χρησιμοποιείται για την καταστροφή ενός GameObject;
    Α. Delete()
    Β. Remove()
    Γ. Destroy()
    Δ. Hide()

43. Τι συμβαίνει σε ένα GameObject όταν καλείται η μέθοδος Destroy() σε αυτό;
    Α. Σταματάει μόνο η οπτική του αναπαράσταση.
    Β. Σταματάει η ύπαρξή του όσον αφορά το παιχνίδι και τον κώδικά του, απελευθερώνονται πόροι.
    Γ. Σταματάει μόνο η φυσική του συμπεριφορά.
    Δ. Απενεργοποιούνται όλα τα Components του.

44. Ποιο component χρειάζεται ένας εχθρός (Zombunny) για να μπορεί να κινείται αυτόνομα ακολουθώντας ένα προ-ψημένο μονοπάτι;
    Α. Rigidbody
    Β. Collider
    Γ. Animator
    Δ. Nav Mesh Agent

45. Σε ποια ενέργεια αντιστοιχεί το "Bake" στο παράθυρο Navigation;
    Α. Δημιουργία ενός Prefab.
    Β. Ψήσιμο του Navigation Mesh στην επιφάνεια της σκηνής.
    Γ. Δημιουργία ενός νέου Animator Controller.
    Δ. Φόρτωση ενός Scene.

46. Σε ποιο Layer ορίστηκε το GameObject Zombunny στην φάση 4;
    Α. Default
    Β. Floor
    Γ. Shootable
    Δ. Player

47. Ποιος τύπος παράμετρος στον Animator Controller είναι κατάλληλος για να ενεργοποιήσει μια μετάβαση από μια κατάσταση animation σε μια άλλη μόνο ΜΙΑ ΦΟΡΑ (π.χ., για animation "Death");
    Α. Bool
    Β. Int
    Γ. Float
    Δ. Trigger

48. Στη φάση 2, ποια παράμετρος χρησιμοποιήθηκε στον Player Animator Controller για να ελέγξει την μετάβαση από την κατάσταση Idle σε Move;
    Α. Speed
    Β. Direction
    Γ. IsWalking
    Δ. Move

49. Στη φάση 2, ποιο prefab προστέθηκε ως παιδί του Player για οπτικό εφέ χτυπήματος;
    Α. HitParticles
    Β. GunParticles
    Γ. DamageImage
    Δ. ScreenFader

50. Στη φάση 2, ποιο audio clip συνδέθηκε στον Audio Source του Player για ήχο χτυπήματος;
    Α. Background Music
    Β. Player Gunshot
    Γ. Player Hurt
    Δ. Zombunny Hurt

51. Ποιο script χειρίζεται την κίνηση του παίκτη στο tutorial;
    Α. PlayerHealth
    Β. PlayerShooting
    Γ. PlayerMovement
    Δ. EnemyMovement

52. Στη φάση 3, ποιο script προστέθηκε στην Main Camera για να ακολουθεί τον παίκτη;
    Α. CameraFollow
    Β. PlayerMovement
    Γ. EnemyMovement
    Δ. FollowTarget

53. Σε ποια μέθοδο του CameraFollow script υπολογίζεται η αρχική διαφορά θέσης (offset) μεταξύ κάμερας και target;
    Α. Awake()
    Β. Start()
    Γ. Update()
    Δ. FixedUpdate()

54. Ποιο component container χρησιμοποιείται για όλα τα στοιχεία User Interface (UI);
    Α. UI Manager
    Β. Rect Transform
    Γ. Canvas
    Δ. HUD

55. Ποιο Component Transform χρησιμοποιείται από τα στοιχεία UI;
    Α. Transform
    Β. Rect Transform
    Γ. UI Transform
    Δ. Canvas Transform

56. Ποιο UI element χρησιμοποιήθηκε για να αναπαραστήσει την μπάρα υγείας (Health Bar);
    Α. Image
    Β. Text
    Γ. Slider
    Δ. Button

57. Ποιο UI element χρησιμοποιήθηκε για να εμφανίσει το σκορ (Score)?
    Α. Image
    Β. Text
    Γ. Slider
    Δ. Button

58. Στη φάση 5, τι τιμή δόθηκε στην ιδιότητα Alpha (A) του ScreenFader Image component αρχικά;
    Α. 0
    Β. 1
    Γ. 0.5
    Δ. Άπειρο

59. Ποιο script διαχειρίζεται την υγεία του παίκτη στο tutorial;
    Α. PlayerMovement
    Β. PlayerHealth
    Γ. ScoreManager
    Δ. GameOverManager

60. Ποιο script καλεί τη μέθοδο AddPoints του ScoreManager όταν ο εχθρός πεθαίνει;
    Α. EnemyMovement
    Β. EnemyAttack
    Γ. EnemyHealth
    Δ. PlayerShooting

61. Ποιο script καλεί τη μέθοδο TakeDamage του PlayerHealth όταν ο εχθρός χτυπά τον παίκτη;
    Α. EnemyMovement
    Β. EnemyAttack
    Γ. EnemyHealth
    Δ. PlayerShooting

62. Ποιος τύπος asset χρησιμοποιείται στον Animator Controller για να αναπαράγει animation clips από ένα prefab μοντέλο, αλλά με δυνατότητα παράκαμψης (override) με άλλα clips;
    Α. Animator Controller
    Β. Animator Override Controller
    Γ. Animation Clip
    Δ. Animation State

63. Ποιο script διαχειρίζεται την αναπαραγωγή (spawning) των εχθρών;
    Α. EnemyMovement
    Β. EnemyAttack
    Γ. EnemyManager
    Δ. SpawnManager

64. Στη φάση 10, ποιο GameObject δημιουργήθηκε ως παιδί του HUDCanvas για το background της οθόνης Game Over;
    Α. GameOverText
    Β. ScoreText
    Γ. ScreenFader
    Δ. DamageImage

65. Ποια component property τροποποιήθηκε για να γίνει αόρατο αρχικά το Game Over Text;
    Α. Font Size
    Β. Text property
    Γ. Color's alpha property
    Δ. Alignment

66. Ποιο παράθυρο (window) χρησιμοποιήθηκε για τη δημιουργία Animation clips και την επεξεργασία keyframes;
    Α. Animator
    Β. Animation
    Γ. Timeline
    Δ. Scene

67. Σε ποιο GameObject συνδέθηκε το component Script GameOverManager;
    Α. Player
    Β. Main Camera
    Γ. HUDCanvas
    Δ. EnemyManager

68. Ποιο script καλεί τον trigger "GameOver" στον Animator Controller του HUDCanvas;
    Α. PlayerHealth
    Β. GameOverManager
    Γ. ScoreManager
    Δ. EnemyManager

69. Στο player movement script, γιατί γίνεται normalize το διάνυσμα movement πριν πολλαπλασιαστεί με speed και Time.deltaTime;
    Α. Για να μειωθεί η ταχύτητα.
    Β. Για να εξασφαλιστεί σταθερή ταχύτητα κίνησης ανεξαρτήτως κατεύθυνσης.
    Γ. Για να κάνει τον παίκτη να περπατάει διαγώνια.
    Δ. Δεν επηρεάζει την κίνηση.

70. Τι αντιπροσωπεύει το Time.deltaTime;
    Α. Τον συνολικό χρόνο που έχει περάσει από την αρχή του παιχνιδιού.
    Β. Τον αριθμό των frames που έχουν περάσει.
    Γ. Το χρονικό διάστημα σε δευτερόλεπτα από το προηγούμενο frame.
    Δ. Την ταχύτητα του επεξεργαστή.

71. Στο turning script του παίκτη, γιατί χρησιμοποιείται Camera.main.ScreenPointToRay;
    Α. Για να βρει την θέση του ποντικιού σε 2D.
    Β. Για να δημιουργήσει μια ακτίνα από την κάμερα προς τη θέση του ποντικιού στην οθόνη.
    Γ. Για να υπολογίσει την απόσταση από την κάμερα στον παίκτη.
    Δ. Για να αλλάξει τη θέση της κάμερας.

72. Στο turning script του παίκτη, γιατί χρησιμοποιείται Physics.Raycast;
    Α. Για να εντοπίσει αν υπάρχει εμπόδιο στο μονοπάτι του παίκτη.
    Β. Για να δει αν η ακτίνα από την κάμερα χτυπάει σε κάποιο collider στη σκηνή.
    Γ. Για να βρει την απόσταση από την κάμερα σε ένα αντικείμενο.
    Δ. Για να δημιουργήσει οπτικά εφέ.

73. Ποιος τύπος δεδομένων χρησιμοποιείται στη Unity για να αναπαραστήσει περιστροφές;
    Α. Vector3
    Β. Quaternion
    Γ. Euler
    Δ. Matrix4x4

74. Στο player health script, γιατί συνδέουμε το health slider και το damage image ως public variables στον Inspector;
    Α. Για να αποθηκεύσουμε την υγεία του παίκτη.
    Β. Για να μπορέσουμε να ελέγξουμε αυτά τα UI στοιχεία από το script.
    Γ. Για να αλλάξουμε το χρώμα τους.
    Δ. Δεν χρειάζεται να είναι public.

75. Πώς ελέγχεται συνήθως αν ένα trigger active collider "αγγίζει" έναν παίκτη (που έχει Rigidbody);
    Α. Μέσα στην Update() μέθοδο του collider.
    Β. Μέσα στην OnCollisionEnter() μέθοδο του trigger.
    Γ. Μέσα στην OnTriggerEnter() μέθοδο του trigger.
    Δ. Μέσα στην Start() μέθοδο του collider.

76. Στο enemy health script, ποια μέθοδος καλείται για να μειωθεί η υγεία του εχθρού;
    Α. ApplyDamage()
    Β. TakeDamage()
    Γ. LoseHealth()
    Δ. Hit()

77. Στο enemy health script, τι συμβαίνει όταν η υγεία του εχθρού πέσει στο μηδέν ή κάτω από το μηδέν;
    Α. Καταστρέφεται αμέσως.
    Β. Εκτελεί animation θανάτου.
    Γ. Καταστρέφεται, εκτελείται animation θανάτου και ενεργοποιείται trigger για σκορ.
    Δ. Εκτελεί animation θανάτου και ενεργοποιείται trigger για σκορ, μετά καταστρέφεται.

78. Στο enemy health script, γιατί καλείται ScoreManager.AddPoints(scoreValue);
    Α. Για να μειωθεί το σκορ του παίκτη.
    Β. Για να αυξηθεί το σκορ του παίκτη όταν ο εχθρός πεθάνει.
    Γ. Για να ενημερωθεί η υγεία του εχθρού.
    Δ. Για να εμφανιστεί το μήνυμα Game Over.

79. Ποια είναι η κύρια λειτουργία του Nav Mesh Agent component σε ένα GameObject;
    Α. Του επιτρέπει να αντιδράει σε φυσικές δυνάμεις.
    Β. Του επιτρέπει να αναπαράγει animations.
    Γ. Του επιτρέπει να κινείται αυτόνομα αποφεύγοντας εμπόδια στο Nav Mesh.
    Δ. Του επιτρέπει να συγκρούεται με άλλα αντικείμενα.

80. Πώς καθορίζεται η περιοχή στην οποία μπορούν να κινούνται οι Nav Mesh Agents;
    Α. Με την ιδιότητα Radius του Nav Mesh Agent.
    Β. Με την ιδιότητα Speed του Nav Mesh Agent.
    Γ. Με τη διαδικασία Nav Mesh Bake.
    Δ. Με την ιδιότητα Obstacle avoidance type.

81. Τι είναι ένα Spawn Point στο πλαίσιο του spawning εχθρών;
    Α. Ένα component που ελέγχει πότε εμφανίζεται ένας εχθρός.
    Β. Ένα prefab που αντιπροσωπεύει έναν εχθρό.
    Γ. Ένα GameObject στην ιεραρχία που ορίζει μια πιθανή θέση εμφάνισης εχθρού.
    Δ. Ένα script που διαχειρίζεται τη λίστα των εχθρών.

82. Ποιο script διαχειρίζεται πότε και πού θα εμφανιστούν οι εχθροί στο tutorial;
    Α. EnemyMovement
    Β. EnemyAttack
    Γ. EnemyHealth
    Δ. EnemyManager

83. Πώς συνδέονται τα Prefabs εχθρών με το script EnemyManager για αναπαραγωγή;
    Α. Δημιουργώντας Components για κάθε εχθρό.
    Β. Μέσω public variables τύπου GameObject ή του βασικού prefab στον Inspector.
    Γ. Μέσω Nav Mesh Agents.
    Δ. Μέσω Collider components.

84. Ποιο component προστέθηκε στο HUDCanvas για να "σκιάσει" την οθόνη κατά το Game Over;
    Α. Image (ScreenFader)
    Β. Text (GameOverText)
    Γ. Slider (HealthSlider)
    Δ. Canvas Group

85. Ποιος τύπος Animation parameter χρησιμοποιήθηκε για να ενεργοποιηθεί το Game Over animation;
    Α. Bool
    Β. Int
    Γ. Float
    Δ. Trigger

86. Σε ποιο GameObject συνδέθηκε το component GameOverManager script;
    Α. Player
    Β. Main Camera
    Γ. HUDCanvas
    Δ. EnemyManager

87. Τι component είναι ο ScreenFader στο GameOver setup;
    Α. Text
    Β. Image
    Γ. Slider
    Δ. Button

88. Ποια ιδιότητα του UI Image component ρυθμίστηκε για να γίνει το ScreenFader αόρατο αρχικά;
    Α. Width
    Β. Height
    Γ. Color's alpha
    Δ. Anchor

89. Ποιο component component ρυθμίστηκε για να κλιμακωθεί (scale) το Game Over text κατά τη διάρκεια του animation;
    Α. Text
    Β. RectTransform
    Γ. Image
    Δ. Canvas

90. Ποια ιδιότητα του UI Text component ρυθμίστηκε για να γίνει το Game Over text ορατό κατά τη διάρκεια του animation;
    Α. Font Size
    Β. Color's alpha
    Γ. Text property
    Δ. Alignment

91. Τι αντιπροσωπεύει ο "Controller" στην ιδιότητα Animator Controller ενός Animator component;
    Α. Το script που ελέγχει τα animations.
    Β. Το asset που ορίζει τις καταστάσεις και μεταβάσεις των animations.
    Γ. Το GameObject που περιέχει τα animation clips.
    Δ. Την κάμερα που παρακολουθεί τα animations.

92. Ποιος είναι ο σκοπός του component Canvas Group;
    Α. Για να ομαδοποιήσει UI στοιχεία.
    Β. Για να κάνει τα στοιχεία Interactable.
    Γ. Για να ελέγξει την Alpha και την Interactivity των παιδιών του.
    Δ. Για να αλλάξει τη σειρά σχεδίασης των παιδιών του.

93. Στη Φάση 5, τι επιλογή Anchor Preset χρησιμοποιήθηκε για να ρυθμιστεί το HealthUI στην κάτω αριστερή γωνία, ενώ επίσης καθορίστηκε η Position και ο Pivot εκεί;
    Α. Top Left
    Β. Bottom Left
    Γ. Alt-Shift-click Bottom Left
    Δ. Shift-click Bottom Left

94. Πώς μετακινήσαμε όλα τα keyframes του GameOver animation ώστε να ξεκινάνε αργότερα στη χρονική γραμμή;
    Α. Επιλέγοντας τα όλα και μετακινώντας τα στη χρονική γραμμή.
    Β. Αλλάζοντας την ιδιότητα Start Time του Animation Clip.
    Γ. Αλλάζοντας την ιδιότητα Speed του Animator Controller.
    Δ. Κάνοντας κλικ στο κουμπί "Record" ξανά.

95. Στην Animator, ποιο state αντιπροσωπεύει την αρχική κατάσταση animation ενός αντικειμένου;
    Α. Entry
    Β. Exit
    Γ. Any State
    Δ. Η κατάσταση με πορτοκαλί highlight.

96. Ποιο asset χρησιμοποιείται για να αντικαταστήσει animation clips σε έναν Animator Controller χωρίς να αλλάξει τον αρχικό Controller asset;
    Α. Animation Clip
    Β. Animator Controller
    Γ. Animator Override Controller
    Δ. Animation State

97. Στο Player Shooting script, ποιο component απαιτείται στο στόχο για να καλέσει τη μέθοδο TakeDamage();
    Α. Collider
    Β. Rigidbody
    Γ. PlayerHealth (ή EnemyHealth)
    Δ. Animator

98. Τι component προσθέσαμε στο GunBarrelEnd για οπτικό εφέ βολής;
    Α. Line Renderer
    Β. Trail Renderer
    Γ. Projector
    Δ. Particle System και Line Renderer

99. Στο player health script, ποιο UI element χρησιμοποιήθηκε για την οπτική αναπαράσταση της υγείας;
    Α. Text
    Β. Image και Slider
    Γ. Canvas Group
    Δ. ScreenFader

100. Στο Player Shooting script, πώς ελέγχουμε αν πατήθηκε το κουμπί του ποντικιού για πυροβολισμό;
    Α. Input.GetMouseButton(0)
    Β. Input.GetMouseButtonDown(0)
    Γ. Input.GetKey(KeyCode.Mouse0)
    Δ. Input.GetAxis("Fire")

101. Στο EnemyAttack script, πώς εντοπίζουμε το GameObject του παίκτη;
    Α. Βρίσκοντάς το με Find("Player").
    Β. Έχοντας μια public reference σε αυτό.
    Γ. Ελέγχοντας το Tag του αντικειμένου που τέμνει το trigger.
    Δ. Μέσω του PlayerManager.

102. Ποια ιδιότητα ενός collider μπορεί να επεξεργαστεί οπτικά με "λαβές" στον Editor;
    Α. Size και Offset
    Β. Is Trigger
    Γ. Material
    Δ. Edge Radius

103. Στο PlayerMovement script, πώς αποκτάται μια αναφορά στο Animator component που είναι συνδεδεμένο στο ίδιο GameObject;
    Α. Νέο Animator().
    Β. GameObject.FindObjectOfType<Animator>().
    Γ. GetComponent<Animator>().
    Δ. transform.animator.

104. Στο PlayerMovement script, ποιο layer mask χρησιμοποιείται για το Raycast;
    Α. Default
    Β. Ignore Raycast
    Γ. Floor
    Δ. Player

105. Ποια μέθοδος χρησιμοποιείται συνήθως για ομαλή παρεμβολή (interpolation) μεταξύ δύο Vector3 θέσεων;
    Α. Vector3.MoveTowards()
    Β. Vector3.Lerp()
    Γ. Vector3.Slerp()
    Δ. Vector3.Distance()

106. Τι σημαίνει η "Normalisation" ενός Vector κίνησης;
    Α. Να γίνει το μήκος του 1, διατηρώντας την κατεύθυνση.
    Β. Να γίνει το μήκος του 0, διατηρώντας την κατεύθυνση.
    Γ. Να αντιστραφεί η κατεύθυνσή του.
    Δ. Να κλιμακωθεί το μήκος του.

107. Ποια μέθοδος ενός Rigidbody2D είναι κατάλληλη για την προσομοίωση της αντίστασης στον αέρα ή στο νερό;
    Α. Mass
    Β. Gravity Scale
    Γ. Drag
    Δ. Velocity

108. Στο player health script, πώς παίζεται ο ήχος "Player Hurt";
    Α. Καλώντας ScoreManager.PlaySound().
    Β. Καλώντας την Play() μέθοδο του AudioSource component που συνδέσατε.
    Γ. Καλώντας AudioSource.Play().
    Δ. Είναι ενσωματωμένος ήχος συστήματος.

109. Ποιο component component προστέθηκε στο Zombunny για να πυροδοτήσει εφέ σωματιδίων όταν χτυπηθεί;
    Α. Particle System
    Β. Line Renderer
    Γ. Audio Source
    Δ. Animator

110. Στο GameOverManager script, πώς παίρνουμε αναφορά στον PlayerHealth component του παίκτη;
    Α. Με FindObjectOfType<PlayerHealth>().
    Β. Με GameObject.Find("Player").GetComponent<PlayerHealth>().
    Γ. Μέσω public variable.
    Δ. Και τα B και C είναι σωστά, ανάλογα πώς είναι δομημένο το script. (Στο tutorial, είναι public variable).

111. Ποιος είναι ο σκοπός της ιδιότητας KeyToDestroy στο HexagonDestroyer script;
    Α. Καθορίζει ποιο αντικείμενο θα καταστραφεί.
    Β. Καθορίζει ποιο πλήκτρο πρέπει να πατηθεί για να καταστραφεί το αντικείμενο.
    Γ. Είναι ο αριθμός των εξαγώνων προς καταστροφή.
    Δ. Είναι η ταχύτητα καταστροφής.

112. Πώς μπορούμε να ελέγξουμε την ιδιότητα KeyToDestroy από τον Editor;
    Α. Μεταγλωττίζοντας το script.
    Β. Είναι private, δεν μπορούμε.
    Γ. Είναι public, εμφανίζεται ως πεδίο στον Inspector.
    Δ. Χρησιμοποιώντας τον Animator Controller.

113. Σε τι θέση (layer) ορίστηκε το Player game object;
    Α. Default
    Β. Floor
    Γ. Shootable
    Δ. Player

114. Στη φάση 3, τι είδους Camera Projection επιλέχθηκε για την Main Camera;
    Α. Perspective
    Β. Orthographic
    Γ. Frustum
    Δ. Isometric

115. Ποιο Animation state είναι default στην κατάσταση idle animation του παίκτη (Phase 2)?
    Α. Idle
    Β. Move
    Γ. Entry
    Δ. Any State

116. Στο PlayerMovement script, γιατί προσθέτουμε 'f' μετά τις αριθμητικές τιμές των float μεταβλητών (π.χ. 6f);
    Α. Είναι τυχαίο.
    Β. Για να τις αναγνωρίζει ο compiler ως float literals.
    Γ. Για να δηλώσει ότι η τιμή είναι ταχύτητα.
    Δ. Για να υποδείξει ότι η τιμή είναι αρνητική.

117. Σε τι Component ρυθμίστηκαν τα Drag & Angular Drag σε Infinity για τον παίκτη;
    Α. Transform
    Β. Capsule Collider
    Γ. Rigidbody
    Δ. PlayerMovement Script

118. Ποιο Audio Clip συνδέθηκε στην Audio Source του BackgroundMusic;
    Α. Player Hurt
    Β. Player Gunshot
    Γ. Zombunny Hurt
    Δ. Background Music

119. Σε ποιο GameObject συνδέθηκε το component ScoreManager script;
    Α. Player
    Β. HUDCanvas
    Γ. ScoreText
    Δ. EnemyManager

120. Στην φάση 10, ποια Component property ρυθμίστηκε για να κλιμακωθεί (scale) το ScoreText κατά τη διάρκεια του animation;
    Α. Text size
    Β. RectTransform Scale
    Γ. Font Size
    Δ. Text alpha

**Απαντήσεις:**

1.  Β
2.  Γ
3.  Γ
4.  Β
5.  Δ
6.  Α
7.  Γ
8.  Δ
9.  Β
10. Β
11. Γ
12. Β
13. Γ
14. Δ
15. Β
16. Δ
17. Γ
18. Δ
19. Δ
20. Β
21. Γ
22. Β
23. Β
24. Γ
25. Β
26. Γ
27. Γ
28. Β
29. Β
30. Δ
31. Γ
32. Β
33. Α
34. Γ
35. Δ
36. Β
37. Β
38. Γ
39. Γ
40. Γ
41. Β
42. Γ
43. Β
44. Δ
45. Β
46. Γ
47. Δ
48. Γ
49. Α
50. Γ
51. Γ
52. Α
53. Α
54. Γ
55. Β
56. Γ
57. Β
58. Α
59. Β
60. Γ
61. Β
62. Β
63. Γ
64. Γ
65. Γ
66. Β
67. Γ
68. Β
69. Β
70. Γ
71. Β
72. Β
73. Β
74. Β
75. Γ
76. Β
77. Δ
78. Β
79. Γ
80. Γ
81. Γ
82. Δ
83. Β
84. Α
85. Δ
86. Γ
87. Α
88. Γ
89. Β
90. Β
91. Β
92. Γ
93. Γ
94. Α
95. Δ
96. Γ
97. Γ
98. Δ
99. Β
100. Β
101. Γ
102. Α
103. Γ
104. Γ
105. Β
106. Α
107. Γ
108. Β
109. Α
110. Δ
111. Β
112. Γ
113. Δ
114. Β
115. Α
116. Β
117. Γ
118. Δ
119. Γ
120. Β
