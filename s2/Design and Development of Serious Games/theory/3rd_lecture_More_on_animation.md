# More on animation

## Αλλαγή Εικόνας (frame) Χαρακτήρα (Slide 2)

*   Όπως είδαμε στο προηγούμενο μάθημα με τον κάβουρα, η πιο απλή μορφή animation είναι η **εναλλαγή μεταξύ δύο εικόνων (frames)**.
*   Στην κλάση `Crab`, προσθέσαμε δύο ιδιότητες τύπου `GreenfootImage` (`image1`, `image2`) για να αποθηκεύσουμε τις δύο εικόνες.
*   Στον **κατασκευαστή** της κλάσης (`public Crab()`), φορτώσαμε τις εικόνες από αρχεία (`"crab.png"`, `"crab2.png"`) σε αυτές τις ιδιότητες και αρχικοποιήσαμε την εικόνα του αντικειμένου (`setImage(image1)`).
*   Δημιουργήσαμε μια μέθοδο `switchImage()` που εναλλάσσει την εικόνα του αντικειμένου (`setImage()`) ανάλογα με την τρέχουσα εικόνα (`getImage()`).
*   Τέλος, καλέσαμε τη μέθοδο `switchImage()` μέσα στην `act()` μέθοδο, ώστε η εικόνα να αλλάζει σε κάθε βήμα εκτέλεσης του παιχνιδιού.

---

## Χρήση Περισσότερων Frames (Slides 3-4)

*   Για ένα καλύτερο **αισθητικό αποτέλεσμα** και μεγαλύτερη **πιστότητα στην κίνηση**, συνήθως χρησιμοποιούμε **περισσότερα από 2 frames** για κάθε κατάσταση του χαρακτήρα (π.χ., περπάτημα, τρέξιμο).
*   Η λύση με ξεχωριστή ιδιότητα `GreenfootImage` για κάθε frame **δεν είναι πρακτική ή σχεδιαστικά αποτελεσματική** όταν τα frames είναι πολλά.
*   **Προτεινόμενη Προσέγγιση:**
    *   Δώστε στα αρχεία εικόνων των frames το **ίδιο όνομα** με έναν **αύξοντα αριθμό** αμέσως μετά (π.χ., `crab0.png`, `crab1.png`, `crab2.png`, ...).
    *   Φορτώστε όλες αυτές τις εικόνες σε έναν **πίνακα (array)** τύπου `GreenfootImage[]`.
    *   Κρατήστε σε ένα πεδίο (`private int currentImage;`) τον **δείκτη** του τρέχοντος frame μέσα στον πίνακα.
    *   Υπολογίστε και επιλέξτε το **επόμενο frame** με βάση τον τρέχοντα δείκτη και το μέγεθος του πίνακα.
*   **Υλοποίηση (Slide 4):**
    *   Ορίστε μια σταθερά για τον **αριθμό των frames** (`private static final int NUM_OF_IMAGES = 2;`).
    *   Δηλώστε ένα πεδίο πίνακα `GreenfootImage[] images;`.
    *   Δηλώστε ένα πεδίο `private int currentImage;` για τον δείκτη.
    *   Στον **κατασκευαστή** (`public Crab()`), δημιουργήστε τον πίνακα (`images = new GreenfootImage[NUM_OF_IMAGES];`).
    *   Χρησιμοποιήστε έναν **βρόχο `for`** για να φορτώσετε τις εικόνες στα στοιχεία του πίνακα, δημιουργώντας δυναμικά τα ονόματα των αρχείων (π.χ., `"crab"+i+".png"`).
    *   Αρχικοποιήστε τον δείκτη `currentImage = 0;`.
    *   Ορίστε την εικόνα του αντικειμένου στο **πρώτο frame** του πίνακα (`setImage(images[currentImage]);`).
    *   Στη μέθοδο `switchImage()`, υπολογίστε τον δείκτη του **επόμενου frame** χρησιμοποιώντας την **modulo** (υπόλοιπο) πράξη: `currentImage = (currentImage + 1) % NUM_OF_IMAGES;`. Αυτό εξασφαλίζει ότι ο δείκτης θα παραμείνει εντός των ορίων του πίνακα και θα επιστρέψει στο 0 μετά το τελευταίο frame.
    *   Ορίστε την εικόνα του αντικειμένου στο **νέο τρέχον frame** (`setImage(images[currentImage]);`).

---

## Χρήση της κλάσης GifImage και αρχείων gif (Slides 5-6)

*   Μια εναλλακτική προσέγγιση για την υλοποίηση animation είναι η χρήση της **βοηθητικής κλάσης `GifImage`** του Greenfoot και αρχείων εικόνας τύπου **.gif**.
*   Μπορούμε να βρούμε αρχεία gif με animation ελεύθερα στο διαδίκτυο.
*   **Πώς Λειτουργεί:**
    *   Εισάγετε την κλάση `GifImage` στο project σας (`Edit -> Import Class...` και επιλέξτε `GifImage`).
    *   Στην κλάση του χαρακτήρα (π.χ., `Bear`), δηλώστε ένα πεδίο τύπου `GifImage` (`private GifImage gif;`).
    *   Στον **κατασκευαστή**, δημιουργήστε ένα νέο στιγμιότυπο της `GifImage`, περνώντας ως όρισμα το όνομα του αρχείου gif (π.χ., `gif = new GifImage("bear.gif");`).
    *   Στη μέθοδο `act()`, καλέστε τη μέθοδο `setImage(gif.getCurrentImage());`. Η μέθοδος `getCurrentImage()` της κλάσης `GifImage` επιστρέφει **αυτόματα** το επόμενο frame του animation του gif σε κάθε κλήση, κάνοντας την εναλλαγή εικόνων πολύ εύκολη.

---

## Χρήση Διαφορετικών Frames ανά Κατεύθυνση (Slides 7-10)

*   Για ακόμα καλύτερα αποτελέσματα, ειδικά σε παιχνίδια όπου οι χαρακτήρες κινούνται προς πολλές κατευθύνσεις (π.χ., πάνω, κάτω, αριστερά, δεξιά), είναι σύνηθες να χρησιμοποιούμε **διαφορετικό σύνολο frames** για κάθε κατεύθυνση.
*   **Παράδειγμα:** Έχουμε 3 frames για την κίνηση "δεξιά" (`hero0.png`, `hero1.png`, `hero2.png`) και 3 frames για την κίνηση "αριστερά" (`hero3.png`, `hero4.png`, `hero5.png`).
*   **Πώς το υλοποιούμε:**
    *   Όπως και πριν, αποθηκεύουμε **όλα τα frames** σε έναν πίνακα `GreenfootImage[] images;`. Ο συνολικός αριθμός frames (`NUM_OF_IMAGES`) είναι το άθροισμα των frames για όλες τις κατευθύνσεις.
    *   Ορίστε μια σταθερά για τον **αριθμό των frames ανά κατεύθυνση** (`private static final int IMAGES_PER_DIRECTION = 3;`).
    *   Διατηρήστε τον δείκτη του τρέχοντος frame `currentImage;`.
    *   Δημιουργήστε μια μέθοδο animation (π.χ., `animate(int first, int last)`) που θα αναλαμβάνει την εναλλαγή των frames **εντός ενός συγκεκριμένου εύρους** του πίνακα. Τα ορίσματα `first` και `last` θα καθορίζουν το **εύρος των δεικτών** του πίνακα που αντιστοιχούν στα frames για μια συγκεκριμένη κατεύθυνση.
    *   Στη μέθοδο `animate()`, ελέγξτε αν ο τρέχων δείκτης (`currentImage`) βρίσκεται εντός του συγκεκριμένου εύρους (`first` έως `last`). Αν δεν είναι, επαναφέρετε τον δείκτη στην αρχή του εύρους (`currentImage = first;`). Αν είναι εντός, αυξήστε τον δείκτη (`currentImage++`).
    *   Ορίστε την εικόνα του αντικειμένου στο `images[currentImage]`.
    *   Στη μέθοδο ελέγχου πλήκτρων (π.χ., `checkKeys()`), αν πατηθεί ένα πλήκτρο για μια συγκεκριμένη κατεύθυνση (π.χ., "right"):
        *   Καλέστε την μέθοδο `animate()`, περνώντας της τους **δείκτες του εύρους** που αντιστοιχούν στα frames αυτής της κατεύθυνσης. Για παράδειγμα, αν τα frames για δεξιά είναι από 0 έως 2, καλέστε `animate(0, 2);`.
        *   Αν πατηθεί το πλήκτρο για την αντίθετη κατεύθυνση (π.χ., "left"), καλέστε την `animate()` με το αντίστοιχο εύρος δεικτών (π.χ., `animate(3, 5);`).
    *   Στην `act()` μέθοδο, καλέστε την `checkKeys()`. (Αν έχουμε και αυτόματη κίνηση, θα πρέπει να χειριστούμε και πότε γίνεται η αλλαγή εικόνας όταν δεν πατιέται πλήκτρο).
*   **Επεκτάσεις:** Φυσικά, μπορείτε να χρησιμοποιήσετε:
    *   Περισσότερα frames για κάθε κατεύθυνση.
    *   Διαφορετικά σύνολα frames για τις υπόλοιπες κατευθύνσεις (πάνω, κάτω, διαγώνιες).
