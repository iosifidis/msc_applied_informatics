# Drawing Graphics

## Σχεδίαση Γραφικών: Εισαγωγή (Slide 1)

Στον προγραμματισμό παιχνιδιών, η σχεδίαση γραφικών στην οθόνη (rendering) αποτελεί θεμελιώδη λειτουργία. Θα εξετάσουμε πώς γίνεται η σχεδίαση:

*   **Σχημάτων:** Χρησιμοποιώντας διανυσματικά σχήματα (rendering vector shapes).
*   **Κειμένου:** Σχεδίαση συμβολοσειρών (rendering text).
*   **Εικόνων:** Φόρτωση και σχεδίαση bitmaps (rendering images).

---

## Σχεδίαση Σχημάτων με την κλάση Graphics (Slides 2 & 10-11)

*   **ShapesDrawingDemo (Slide 2):** Το παράδειγμα αυτό δείχνει τη σχεδίαση τυχαίων γραμμών και ορθογωνίων.
*   **Κλάση `Graphics` (Slide 10):** Στην C# (χρησιμοποιώντας System.Drawing), η κλάση `Graphics` παρέχει τις μεθόδους για τη σχεδίαση διαφόρων σχημάτων:
    *   `DrawRectangle`
    *   `DrawArc`
    *   `DrawBezier`
    *   `DrawCurve`
    *   `DrawEllipse`
    *   `DrawPie`
    *   `DrawPolygon`
    *   `DrawLine` (χρησιμοποιήθηκε στο ShapesDrawingDemo)
*   **Παράδειγμα Σχεδίασης Ορθογωνίων (Slide 11):** Για να σχεδιάσουμε ορθογώνια, αντικαθιστούμε τον κώδικα σχεδίασης γραμμών (`device.DrawLine(...)`) στη μέθοδο `drawShape()` (βλ. Slide 7) με κώδικα που υπολογίζει τις συντεταγμένες της πάνω αριστερής γωνίας του ορθογωνίου και στη συνέχεια καλεί τη μέθοδο `DrawRectangle()`.

---

## Global Variables (Slides 3 & 5)

Για τη σχεδίαση γραφικών σε μια φόρμα Windows Forms, χρειάζονται ορισμένα αντικείμενα που είναι προσβάσιμα σε όλη την εφαρμογή (global variables).

*   **`PictureBox` (pb):** Ένα control (πλαίσιο) στη φόρμα, στο οποίο προστίθεται μια εικόνα για τη σχεδίαση.
*   **`Timer` (timer):** Ένα χρονόμετρο που πυροδοτεί ένα συμβάν (`tick`) σε συγκεκριμένα διαστήματα. Αυτό το συμβάν χρησιμοποιείται για την ανανέωση της οθόνης (όπως ο βρόχος του παιχνιδιού).
*   **`Random` (rand):** Μια γεννήτρια ψευδοτυχαίων αριθμών, χρήσιμη για τη δημιουργία τυχαίων θέσεων, χρωμάτων κ.λπ. (όπως είδαμε στο ShapesDrawingDemo).
*   **`Bitmap` (surface):** Αναπαριστά μια επιφάνεια σχεδίασης στη μνήμη. Είναι ουσιαστικά ένας δείκτης (pointer) στα δεδομένα της εικόνας στη μνήμη.
*   **`Graphics` (device):** Χρησιμοποιείται για τη σχεδίαση. Παρέχει τον μηχανισμό για την εκτέλεση των σχεδιαστικών εντολών.

*   **Σχέση Bitmap και Graphics (Slide 5):** Το αντικείμενο `Graphics` χρησιμοποιείται για τη σχεδίαση στην επιφάνεια `Bitmap` (`surface`). Η εικόνα που σχεδιάζεται σε αυτή την επιφάνεια στη συνέχεια ανατίθεται στην ιδιότητα `Image` του `PictureBox` (`pb.Image = surface;`) για να εμφανιστεί στο παράθυρο της φόρμας.

*   **Αρχικοποίηση (Slides 3-4 & 6):** Τα τρία αντικείμενα (`pb`, `timer`, `rand`) δημιουργούνται και αρχικοποιούνται στη μέθοδο **`Form1_Load`**, η οποία εκτελείται κατά την εκκίνηση της εφαρμογής. Στην ίδια μέθοδο, αρχικοποιούνται και τα `Bitmap` (`surface`) και `Graphics` (`device`).
    *   Το `Bitmap` (`surface`) δημιουργείται με τις ίδιες διαστάσεις με το παράθυρο (`this.Size.Width, this.Size.Height`) και το `PictureBox.Image`.
    *   Το αντικείμενο `Graphics` (`device`) δημιουργείται χρησιμοποιώντας το `Bitmap` (`Graphics.FromImage(surface)`), ορίζοντας στο οποίο `Bitmap` θα γίνει η σχεδίαση.
    *   Το `Bitmap` που σχεδιάζεται ενημερώνει την ιδιότητα `Image` του `PictureBox`, η οποία υπάρχει στο παράθυρο.

---

## Χρονόμετρο – Δημιουργία και Χειρισμός Συμβάντων (Slides 8-9)

*   **Δημιουργία Χρονομέτρου (Slide 8):** Το `Timer` δημιουργείται και ρυθμίζεται στη μέθοδο `Form1_Load`. Ορίζεται το διάστημα εκτέλεσης (`Interval = 20;`) (20 milliseconds = 50 frames per second) και ενεργοποιείται (`Enabled = true;`).
*   **Χειρισμός Συμβάντος `Tick`:** Δημιουργείται ένας **event handler** για το συμβάν `Timer.tick`. Αυτός είναι μια μέθοδος (π.χ., `TimerTick`) που καλείται κάθε φορά που "χτυπά" το χρονόμετρο.
    *   Ο event handler συνδέεται με το συμβάν με τον κώδικα `timer.Tick += new System.EventHandler(TimerTick);`.
    *   Μέσα στη μέθοδο `TimerTick`, καλείται η μέθοδος σχεδίασης (π.χ., `drawShape();`), η οποία ανανεώνει την επιφάνεια `Bitmap`.
*   **Άλλα Συμβάντα (Slide 9):** Μια φόρμα Windows Forms διαθέτει πολλά συμβάντα (π.χ., KeyDown, KeyUp, MouseClick, FormClosed).
    *   Το συμβάν **`FormClosed`** (όταν ο χρήστης κλείνει τη φόρμα) είναι σημαντικό για την απελευθέρωση πόρων.
    *   Στον event handler για το `FormClosed`, πρέπει να καλούνται οι μέθοδοι `Dispose()` για τα αντικείμενα `Graphics` (`device`), `Bitmap` (`surface`) και `Timer` (`timer`).

---

## Σχεδίαση Κειμένου (Slides 12-14)

*   **TextDrawingDemo (Slide 12):** Το παράδειγμα δείχνει την εμφάνιση κειμένου σε μια φόρμα.
*   **Υλοποίηση (Slides 13-14):**
    *   Χρησιμοποιούμε τις ίδιες μεταβλητές `PictureBox`, `Bitmap`, `Graphics` που αρχικοποιούνται με τον ίδιο τρόπο.
    *   Το κείμενο που θέλουμε να εμφανιστεί στην οθόνη αποθηκεύεται σε έναν **πίνακα αλφαριθμητικών** (`string[] text`). Κάθε στοιχείο του πίνακα θα σχεδιαστεί σε διαφορετική γραμμή.
    *   Δημιουργούμε τη **γραμματοσειρά** που επιθυμούμε (`Font font = new Font(...)`).
    *   Σχεδιάζουμε το κείμενο χρησιμοποιώντας τη μέθοδο **`DrawString()`** της κλάσης `Graphics`.
    *   Στη μέθοδο `Form1_Load`, μετά την αρχικοποίηση των `Bitmap` και `Graphics`, καλούμε ένα βρόχο `for` που διατρέχει τον πίνακα `text`. Για κάθε συμβολοσειρά, καλούμε `device.DrawString(text[n], font, Brushes.Yellow, 10, 10 + n*28);`. Τα ορίσματα είναι: η συμβολοσειρά, η γραμματοσειρά, το χρώμα (χρησιμοποιώντας έτοιμες κλάσεις Brushes), και οι συντεταγμένες x, y. Η συντεταγμένη y αυξάνεται για κάθε γραμμή.

---

## Σχεδίαση Εικόνας (Slides 15-20)

*   **BitmapDrawingDemo (Slide 15):** Το παράδειγμα δείχνει φόρτωση εικόνας και διάφορους χειρισμούς (περιστροφή, καθρέφτισμα, αλλαγή χρώματος pixel).
*   **Υλοποίηση (Slides 16-17):**
    *   Χρησιμοποιούμε τις ίδιες μεταβλητές `PictureBox`, `Bitmap`, `Graphics` όπως πριν. Προσθέτουμε μια επιπλέον μεταβλητή `Bitmap image;` για να αποθηκεύσουμε την εικόνα που θα φορτώσουμε.
    *   **Φόρτωση Εικόνας:** Η κλάση `Bitmap` δεν διαθέτει μια απλή μέθοδο φόρτωσης αρχείου. Χρειάζεται να δημιουργήσουμε ένα **νέο αντικείμενο `Bitmap`** καλώντας έναν από τους κατασκευαστές της κλάσης και περνώντας ως όρισμα το όνομα του αρχείου εικόνας (π.χ., `"skellyarcher.png"`). Για να αποφύγουμε σφάλματα αν το αρχείο δεν βρεθεί, είναι καλό να χρησιμοποιήσουμε ένα μπλοκ `try...catch` (Slide 18).
    *   Ορίζουμε μια μέθοδο `LoadBitmap(string filename)` (Slide 18) που αναλαμβάνει τη φόρτωση του αρχείου σε ένα αντικείμενο `Bitmap` με χειρισμό λαθών.
    *   Στη μέθοδο `Form1_Load`, μετά την αρχικοποίηση των `Bitmap` και `Graphics`, καλούμε την `LoadBitmap` για να φορτώσουμε την εικόνα στο πεδίο `image`: `image = LoadBitmap("skellyarcher.png");`.
    *   **Σχεδίαση Εικόνας:** Στη μέθοδο `Form1_Load`, καλούμε τη μέθοδο **`DrawImage()`** της κλάσης `Graphics` για να σχεδιάσουμε την εικόνα στην επιφάνεια `Bitmap`: `device.DrawImage(image, 0, 0);`. Τα ορίσματα είναι το αντικείμενο `Bitmap` που θα σχεδιαστεί και οι συντεταγμένες x, y στην επιφάνεια σχεδίασης.

*   **Χειρισμοί Εικόνας: Περιστροφή, Καθρέφτισμα/Αναστροφή (Slides 19-20):**
    *   Η κλάση `Bitmap` παρέχει μεθόδους για χειρισμούς όπως περιστροφή, αναστροφή, καθρέφτισμα, ή πρόσβαση σε pixel.
    *   **Σημαντικό:** Μετά την κλήση της σχετικής μεθόδου (π.χ., `RotateFlip()`), απαιτείται να **σχεδιαστεί ξανά** η εικόνα στην επιφάνεια `Bitmap` (`device.DrawImage()`) και να **ανανεωθεί** η ιδιότητα `Image` του `PictureBox` (`pictureBox1.Image = surface;`) για να εμφανιστεί η αλλαγή στο παράθυρο.
    *   **Πρόσβαση/Ενημέρωση Pixel (Slide 20):**
        *   `Bitmap.GetPixel(int x, int y)`: Προσπελαύνει το pixel στις συντεταγμένες (x, y) και επιστρέφει το χρώμα του.
        *   `Bitmap.SetPixel(int x, int y, Color color)`: Αλλάζει το χρώμα του pixel στις συντεταγμένες (x, y).
    *   **Παράδειγμα Αλλαγής Χρώματος Pixel (Slide 20):** Ένας διπλός βρόχος `for` διατρέχει όλα τα pixel της εικόνας. Για κάθε pixel, ανακτά το χρώμα του (`image.GetPixel(x, y)`), υπολογίζει ένα νέο χρώμα (π.χ., μόνο πράσινο) και το ορίζει (`image.SetPixel(x, y, newColor)`). Μετά τον βρόχο, η αλλαγμένη εικόνα σχεδιάζεται ξανά.

---

## Δημιουργία Ενός Game Framework (Slides 21-26)

Ο κώδικας που χρησιμοποιήσαμε για τη σχεδίαση σχημάτων, κειμένου και εικόνων χρειάζεται συχνά στον προγραμματισμό παιχνιδιών. Για να είναι επαναχρησιμοποιήσιμος, μπορούμε να τον οργανώσουμε σε ένα δικό μας **Game Framework** (π.χ., μια κλάση `Game`).

*   **Κλάση `Game` (Slide 21):** Αυτή η κλάση θα περιλαμβάνει τις μεταβλητές και τις συναρτήσεις που χρειάζονται συχνά.
*   **Πεδία της κλάσης `Game` (Slide 22):**
    *   `p_device` (τύπου `Graphics`), `p_surface` (τύπου `Bitmap`), `p_pb` (τύπου `PictureBox`): Τα απαραίτητα πεδία για τη σχεδίαση (rendering).
    *   `p_form` (τύπου `Form`): Μια αναφορά στο βασικό παράθυρο (φόρμα) της εφαρμογής, η οποία ενημερώνεται όταν δημιουργείται το αντικείμενο της κλάσης `Game`.
*   **Κατασκευαστής της κλάσης `Game` (Slide 23):**
    *   Ο κατασκευαστής (`public Game(Form1 form, int width, int height)`) δέχεται ως ορίσματα την φόρμα στην οποία θα γίνει η σχεδίαση, και τις διαστάσεις του παραθύρου.
    *   Στον κατασκευαστή αρχικοποιούνται τα πεδία `p_form`, `p_pb`, `p_surface`, `p_device` με βάση τα ορίσματα και τις διαστάσεις.
*   **Μέθοδοι για Φόρτωση Εικόνας & Ενημέρωση Επιφάνειας Σχεδίασης (Slide 24):**
    *   Προσθέτουμε τη μέθοδο `LoadBitmap(string filename)` στην κλάση `Game`.
    *   Προσθέτουμε μια μέθοδο `Update()` που ανανεώνει την επιφάνεια σχεδίασης (μεταφέρει το περιεχόμενο του `p_surface` στο `p_pb.Image`).
*   **C# Properties (Slide 25):** Στην C#, μπορούμε να ορίσουμε ιδιότητες (properties) που μοιάζουν με πεδία αλλά στην πραγματικότητα αντιστοιχούν σε κλήσεις μεθόδων `get` (για ανάκτηση τιμής) και `set` (για ανάθεση τιμής).
    *   Μπορούμε να ορίσουμε μια ιδιότητα `Device` στην κλάση `Game` που επιστρέφει το αντικείμενο `Graphics`: `public Graphics Device { get { return p_device; } }`.
    *   Παράδειγμα χρήσης: `Graphics G = game.Device;`.
*   **Παράδειγμα Αξιοποίησης της κλάσης `Game` (Slide 26):**
    *   Στη μέθοδο `Form1_Load` της φόρμας, δημιουργούμε ένα αντικείμενο `Game` περνώντας της την φόρμα, πλάτος και ύψος: `game = new Game(this, 600, 600);`.
    *   Φορτώνουμε μια εικόνα χρησιμοποιώντας τη μέθοδο `LoadBitmap` του αντικειμένου `game`: `planet = game.LoadBitmap("planet.bmp");`.
    *   Σχεδιάζουμε την εικόνα χρησιμοποιώντας την ιδιότητα `Device` του αντικειμένου `game`: `game.Device.DrawImage(planet, 10, 10);`.
    *   Ενημερώνουμε την οθόνη καλώντας τη μέθοδο `Update()` του αντικειμένου `game`: `game.Update();`.
    *   Στον event handler `Form1_FormClosed`, απελευθερώνουμε τους πόρους του αντικειμένου `game`: `game.Dispose();`.

