# Unity-Scripting

Η δομή αυτής της ενότητας είναι: **Μηχανές παιχνιδιών -> Unity 3D -> Scripting**. Θα δούμε γιατί χρησιμοποιούμε μηχανές παιχνιδιών, θα γνωρίσουμε τα βασικά αντικείμενα/κλάσεις της Unity και θα δούμε πώς γράφουμε scripts για να ελέγχουμε τη συμπεριφορά των αντικειμένων.

---

## Μηχανές Παιχνιδιών (Game Engines) (Slide 2)

*   **Υπάρχουν πολλές μηχανές παιχνιδιών:** Οι διαθέσιμες μηχανές παιχνιδιών βασίζονται σε διαφορετική φιλοσοφία και καλύπτουν διαφορετικές ανάγκες των χρηστών.
*   **Κοινά Χαρακτηριστικά:** Παρά τις διαφορές, όλες οι μηχανές παιχνιδιών παρέχουν κοινά χαρακτηριστικά και λειτουργίες που διευκολύνουν την ανάπτυξη:
    *   **Audiovisual Fidelity:** Rendering (γραφικά), Animation, Sound (ήχος), 3D Graphics for mobile devices, Scene Editor (οπτικός επεξεργαστής σκηνής).
    *   **Functional Fidelity:** Scripting, Artificial Intelligence (AI), Physics (φυσική).
    *   **Composability:** Import Content (εισαγωγή περιεχομένου), Export Content (εξαγωγή περιεχομένου), Υποστήριξη SDKs (Software Development Kits) για διάφορες πλατφόρμες (Windows Phone, iOS, Android).
    *   **Developer Toolkits:** Εργαλεία για τους developers.
    *   **Accessibility:** Usability (χρηστικότητα), Price (κόστος).
    *   **Networking:** Peer-to-Peer, Client-Server, Multiple Players (πολλοί παίκτες).
    *   **Development Features:** Operating Systems (λειτουργικά συστήματα), Graphic APIs.
    *   **Deployment Platforms:** Mobile Phones, Desktop, Consoles (πλατφόρμες διάθεσης).
*   **Κατηγορίες ανά Φιλοσοφία (Slide 2):**
    *   Μηχανές που **δεν απαιτούν γνώσεις προγραμματισμού** (π.χ., GameMaker - αν και έχει και scripting).
    *   Μηχανές που βασίζονται σε **δημοφιλείς τεχνολογίες Ιστού** (π.χ., HTML5 frameworks).
    *   Μηχανές **ανοικτού κώδικα** που μπορούν να προσαρμοστούν και να επεκταθούν από έμπειρους χρήστες (π.χ., JMonkeyEngine, Godot).
    *   **Επαγγελματικές μηχανές παιχνιδιών** (π.χ., Unity 3D, Unreal Engine).

---

## Unity 3D (Slides 3-20)

*   Η **Unity 3D** είναι μια από τις **πιο δημοφιλείς μηχανές παιχνιδιών στη βιομηχανία** (όπως αναφέρθηκε και σε προηγούμενο μάθημα).
*   Παρέχει ένα **ολοκληρωμένο περιβάλλον ανάπτυξης** (Scene Editor, Inspector, κ.λπ.) και **έτοιμες λειτουργίες** (Physics, Animation, Rendering, AI, Networking, κ.λπ.).
*   Στη συνέχεια, περιγράφονται σύντομα κάποια **βασικά αντικείμενα/κλάσεις** και στοιχεία που πρέπει να γνωρίζετε για τη συγγραφή των πρώτων σας **scripts**.

*   **Κλάση `GameObject` (Slide 4):**
    *   Κάθε **αντικείμενο** που υπάρχει στη σκηνή της Unity είναι ένα **`GameObject`**.
    *   Σε κάθε script που δημιουργούμε, υπάρχει ένα πεδίο `gameObject`, το οποίο διατηρεί μια **αναφορά** στο αντικείμενο `GameObject` στο οποίο ανήκει το συγκεκριμένο script.

*   **Κλάση `Transform` (Slide 5):**
    *   Αυτή η κλάση καθορίζει τις **ιδιότητες ενός αντικειμένου στον χώρο**, όπως:
        *   **θέση (position)**
        *   **περιστροφή (rotation)**
        *   **κλίμακα (scale)**
    *   Διαθέτει μεθόδους για τη μετακίνηση, την περιστροφή του κτλ.
    *   Είναι από τις πιο κοινές κλάσεις αφού τα περισσότερα αντικείμενα έχουν ένα component `Transform`.

*   **Κλάση `Rigidbody` & `Rigidbody2D` (Slide 6):**
    *   Αυτές οι κλάσεις περιλαμβάνουν πεδία που αναφέρονται στις **φυσικές ιδιότητες** των αντικειμένων (**physics**) και μεθόδους για σχετικές λειτουργίες (π.χ., εφαρμογή δυνάμεων, βαρύτητα).
    *   Το `Rigidbody` (για 3D) και το `Rigidbody2D` (για 2D) είναι ένα πολύ συνηθισμένο **component** για τα αντικείμενα στη σκηνή ενός παιχνιδιού που πρόκειται να επηρεαστούν από τη φυσική.

*   **Vectors (Slides 7-8):**
    *   Ένα διάνυσμα έχει κατεύθυνση και μέτρο και χρησιμοποιείται, για παράδειγμα, για την αποθήκευση των δεδομένων κίνησης.
    *   Στη Unity, ένα vector μπορεί επιπλέον να χρησιμοποιηθεί για να αναπαραστήσει (εκτός από ένα διάνυσμα) ένα **σημείο** ή απλά μια **δομή με πραγματικούς αριθμούς**.
    *   **Κλάσεις `Vector2`, `Vector3` & `Vector4` (Slide 8):** Χρησιμοποιούνται για την αναπαράσταση διανυσμάτων/σημείων 2, 3 και 4 διαστάσεων αντίστοιχα.
    *   Τα αντικείμενα των κλάσεων αυτών **δεν χρησιμοποιούνται για την αναπαράσταση αποκλειστικά και μόνο διανυσμάτων κίνησης**.
    *   Για παράδειγμα, σε ένα component τύπου `Transform` χρησιμοποιούνται τρία `Vector3` που καθορίζουν την θέση (απόσταση από το (0,0,0) σε κάθε άξονα), την περιστροφή και την κλίμακα του αντικειμένου.

*   **Κλάση `Input` (Slides 9-11):**
    *   Αυτή η κλάση περιλαμβάνει **στατικές μεθόδους** για τον έλεγχο της **εισόδου από τον χρήστη** μέσω του πληκτρολογίου, ποντικιού κτλ.
    *   **Ενδεικτικές στατικές μέθοδοι (Slide 9):** `GetButton(..)`, `GetMouseButton(..)`, `GetKey(..)`, `GetAxis(..)`.
    *   **Παραδείγματα συναρτήσεων (Slide 10):** Λεπτομερέστερες εκδόσεις των μεθόδων (`GetButtonDown`, `GetButtonUp`, `GetKeyDown`, `GetKeyUp`, `GetMouseButtonDown`, `GetMouseButtonUp`, `GetAxisRaw`).
    *   **Κλάση `Input.GetAxis` (Slide 11):**
        *   `Input.GetAxis(string axisName)`: Δέχεται ως όρισμα το όνομα του άξονα ("Horizontal", "Vertical" κ.λπ., όπως ορίζονται στις Input Settings του Project) και επιστρέφει έναν πραγματικό αριθμό από το -1 μέχρι το 1. Ο αριθμός αυτός αντιστοιχεί στην είσοδο που δόθηκε (π.χ., -1 αν πατάει αριστερά, 1 αν πατάει δεξιά). Παίρνει ενδιάμεσες τιμές κατά τη γρήγορη μετάβαση.
        *   `Input.GetAxisRaw(string axisName)`: Επιστρέφει μόνο τις τιμές -1, 0 και 1 (χωρίς ενδιάμεσες τιμές).

*   **Colliders & Triggers (Slides 12-14):**
    *   Τα **components τύπου `Collider`** χρησιμοποιούνται για να ελέγξουμε αν ο παίκτης βρίσκεται σε κάποια συγκεκριμένη περιοχή της σκηνής που θέλουμε να λειτουργεί ως εμπόδιο ή να πυροδοτεί μια ενέργεια, καθώς και όταν θέλουμε να ελέγξουμε αν υπήρξε σύγκρουση με κάποιο άλλο αντικείμενο.
    *   Αν η περιοχή δεν αποτελεί εμπόδιο αλλά θέλουμε να πυροδοτεί μια ή περισσότερες ενέργειες, τότε ορίζουμε τον **collider** ως **trigger** μέσα από τον Inspector.
    *   **Συναρτήσεις για Colliders (Slide 13):** Είτε το component λειτουργεί ως collider είτε ως trigger, υπάρχει η δυνατότητα μέσα από τον κώδικα (script) να αναγνωρίζεται πότε κάποιο αντικείμενο **εισέρχεται** σε ένα trigger ή **συγκρούεται** με ένα collider, **παραμένει** σε επαφή ή **εξέρχεται** από την επαφή.
        *   `void OnCollisionEnter(Collision collision)`: Εκτελείται όταν το αντικείμενο συγκρουστεί με ένα άλλο.
        *   `void OnCollisionStay(Collision collision)`: Εκτελείται όσο παραμένει σε επαφή.
        *   `void OnCollisionExit(Collision collision)`: Εκτελείται όταν σταματήσει να είναι σε επαφή.
    *   **Συναρτήσεις για Triggers (Slide 14):**
        *   `void OnTriggerEnter(Collider other)`: Εκτελείται όταν ένα αντικείμενο εισέρχεται σε ένα trigger.
        *   `void OnTriggerStay(Collider other)`: Εκτελείται όσο παραμένει εντός trigger.
        *   `void OnTriggerExit(Collider other)`: Εκτελείται όταν εξέρχεται από trigger.
    *   Στην περίπτωση **2D παιχνιδιών**, υπάρχουν αντίστοιχες συναρτήσεις με την ίδια λειτουργικότητα (π.χ., `OnCollisionEnter2D(Collision2D collision)`).
    *   **Σημαντικό:** Για να λειτουργήσουν αυτές οι συναρτήσεις, τουλάχιστον ένα από τα αντικείμενα που εμπλέκονται στην επαφή/σύγκρουση πρέπει να έχει component **`Rigidbody`** (ή `Rigidbody2D` για 2D).

---

## Scripting (Slides 15-20)

*   **Τι είναι ένα script (Slide 15):** Κάθε script είναι μια **`public class`** (στο C#) που περιλαμβάνει πεδία, προκαθορισμένες μεθόδους και μεθόδους που ορίζονται από τον χρήστη.
*   Το όνομα του script (κλάσης) πρέπει να είναι **ακριβώς ίδιο** με το όνομα του αρχείου στο οποίο αποθηκεύεται το script.
*   Τα πεδία μπορεί να έχουν διαφορετικό επίπεδο ορατότητας (`public`, `private`, κ.λπ.). Ένα **`public` πεδίο** εμφανίζεται στο αντίστοιχο component του **Inspector** της Unity, έτσι ώστε να μπορούμε να αναθέτουμε σε αυτό συγκεκριμένα αντικείμενα του ίδιου τύπου που υπάρχουν ή θέλουμε να εμφανίζονται στη σκηνή.

*   **Βασικές Συναρτήσεις Script (Callbacks) (Slides 16-20):** Κάθε script που δημιουργούμε (αν κληρονομεί από `MonoBehaviour`) περιλαμβάνει προκαθορισμένες συναρτήσεις (callbacks) που καλούνται αυτόματα από τη Unity σε συγκεκριμένες στιγμές του game loop.
    *   `void Start()` (Slide 16 & 18): Καλείται **μία φορά** όταν **ξεκινάει το παιχνίδι**, πριν από κάθε άλλη Update μέθοδο.
    *   `void Update()` (Slide 16 & 19): Καλείται σε **κάθε frame**. Είναι αρμόδια για την πραγματοποίηση αλλαγών στην θέση, την κατάσταση και την συμπεριφορά των αντικειμένων στο παιχνίδι **πριν ακριβώς σχεδιαστεί** ένα frame και **πριν υπολογιστούν οι κινήσεις** (animations). Καθώς η συνάρτηση εκτελείται σε κάθε frame, πρέπει να αποφεύγονται οι χρονοβόρες και κοστοβόρες διαδικασίες σε αυτή.
    *   `void Awake()` (Slide 17): Χρησιμοποιείται για να αρχικοποιεί μεταβλητές και καταστάσεις του παιχνιδιού, πριν ξεκινήσει το παιχνίδι. Καλείται **μόνο μία φορά** όταν το αντικείμενο-script αρχικοποιείται, ανεξάρτητα από το εάν το script έχει ενεργοποιηθεί. Καλείται σε όλα τα αντικείμενα της σκηνής πριν από την `Start()`. Χρήσιμο αν υπάρχουν αντικείμενα που η αρχικοποίηση του κώδικά τους εξαρτάται από ήδη αρχικοποιημένα αντικείμενα.
    *   `void FixedUpdate()` (Slide 20): Κατάλληλη για να ενημερώνει τον **κώδικα φυσικής**. Αυτός ο κώδικας απαιτεί ενημέρωση ανά **τακτά χρονικά διαστήματα** (που ορίζονται στις Physics Settings) όπως και η σχεδίαση των frames. Επειδή οι ενημερώσεις των frames και φυσικής δεν εμφανίζονται με την ίδια συχνότητα, είναι πιο αποδοτικό να χρησιμοποιείται αυτή η μέθοδος για τον κώδικα φυσικής παρά η `Update()`.
    *   `void LateUpdate()` (Slide 20): Καλείται σε **κάθε frame μετά από την `Update()`**. Χρήσιμο αν θέλουμε κάποιες ενέργειες να γίνουν αφού έχουν ολοκληρωθεί όλες οι `Update()` κλήσεις για όλα τα αντικείμενα.

