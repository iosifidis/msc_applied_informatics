# Εισαγωγή στη MiniZinc

## Εισαγωγή
Η MiniZinc είναι μια γλώσσα μοντελοποίησης περιορισμών (Constraint Programming - CP) υψηλού επιπέδου, που επιτρέπει τη δημιουργία μοντέλων τα οποία μπορούν να εκτελούνται σε πολλούς διαφορετικούς επιλυτές (solvers). Η MiniZinc μεταφράζεται σε FlatZinc, μια γλώσσα χαμηλότερου επιπέδου που χρησιμοποιείται από τους επιλυτές για την επίλυση του προβλήματος.

---

## **Ενότητα 1: Γλώσσες Μοντελοποίησης & MiniZinc**

### 1.  **Γιατί Γλώσσες Μοντελοποίησης;**
*   **Σκοπός:** Παρέχουν έναν υψηλού επιπέδου, **δηλωτικό** τρόπο για να *περιγράψουμε* ένα πρόβλημα ικανοποίησης ή βελτιστοποίησης περιορισμών (CSP/COP).
*   **Πλεονεκτήματα:**
     *   **Ανεξαρτησία από Solver:** Το ίδιο μοντέλο μπορεί συχνά να λυθεί χρησιμοποιώντας διαφορετικούς υποκείμενους αλγορίθμους επίλυσης (solvers) χωρίς αλλαγή στον κώδικα του μοντέλου. Αυτό επιτρέπει εύκολη σύγκριση απόδοσης των solvers.
     *   **Standard Μορφή:** Παρέχουν μια κοινή γλώσσα για την έκφραση προβλημάτων CP.
     *   **Γρήγορη Ανάπτυξη:** Εστιάζουν στην περιγραφή του *τι* πρέπει να λυθεί, όχι στο *πώς* θα λυθεί, κάνοντας τη μοντελοποίηση ταχύτερη.
     *   **Καθαρότητα & Συντήρηση:** Ο διαχωρισμός μοντέλου και δεδομένων (που συχνά υποστηρίζεται) κάνει τον κώδικα πιο κατανοητό και ευκολότερο στη διαχείριση.
*   **Γνωστές Γλώσσες:** OPL (IBM), AMPL, **MiniZinc**.

### 2.  **MiniZinc & FlatZinc:**
*   **MiniZinc:** Μια γλώσσα μοντελοποίησης **μεσαίου επιπέδου** για προβλήματα περιορισμών. Αποτελεί απλοποιημένη έκδοση της (πιο πολύπλοκης) γλώσσας Zinc.
*   **FlatZinc:** Μια γλώσσα **χαμηλού επιπέδου**. Ένα μοντέλο MiniZinc μεταγλωττίζεται/μεταφράζεται (flattened) σε FlatZinc.
*   **Ρόλος FlatZinc:** Αποτελεί τη γλώσσα-στόχο που καταλαβαίνουν οι περισσότεροι solvers. Είναι απλή και σχεδιασμένη ώστε οι δημιουργοί solvers να μπορούν εύκολα να γράψουν ένα interface (API) για να την διαβάζουν. Η διαδικασία "flattening" περιλαμβάνει μετασχηματισμούς όπως η εξάλειψη σύνθετων εκφράσεων, η αντικατάσταση global constraints με τα βασικά τους συστατικά (αν χρειάζεται), η εισαγωγή βοηθητικών μεταβλητών κ.λπ.

### 3.  **Η Αλυσίδα Εργαλείων MiniZinc (Tool Chain):**
*   `model.mzn`: Το αρχείο που περιέχει το μοντέλο MiniZinc.
*   `dataFile.dzn` (Προαιρετικό): Αρχείο δεδομένων που περιέχει τιμές για τις παραμέτρους του μοντέλου.
*   `globals.mzn` (Προαιρετικό): Αρχεία βιβλιοθήκης που ορίζουν global constraints.
*   `mzn2fzn`: Ο μεταγλωττιστής/μεταφραστής που παίρνει τα `.mzn` και `.dzn` αρχεία και παράγει το `.fzn` (FlatZinc) και το `.ozn` (output specification).
*   `solver`: Ο επιλυτής (π.χ., Gecode, Chuffed, CPLEX, Gurobi) που διαβάζει το `.fzn` αρχείο και προσπαθεί να βρει μια λύση.
*   `solution`: Η έξοδος του solver (αν βρεθεί λύση).
*   `solns2out`: Εργαλείο που μορφοποιεί τη λύση σύμφωνα με τις οδηγίες στο `.ozn` αρχείο (ή τις προεπιλογές).
*   `stdout`: Η τελική, μορφοποιημένη έξοδος προς τον χρήστη.

### 4.  **Βασικά Χαρακτηριστικά MiniZinc:**
*   **Διαχωρισμός Μοντέλου-Δεδομένων:** Επιτρέπει την επαναχρησιμοποίηση του ίδιου μοντέλου με διαφορετικά datasets. Ένα μοντέλο (`.mzn`) + δεδομένα (`.dzn`) = ένα **στιγμιότυπο (instance)** του προβλήματος.
*   **Εκφραστικό Σύστημα Τύπων:** Υποστηρίζει βασικούς τύπους (int, float, bool), σύνολα (set of), πίνακες (arrays), απαριθμητούς τύπους (enums).
*   **Κατηγορήματα (Predicates):** Επιτρέπουν τον ορισμό πολύπλοκων (συχνά global) περιορισμών ως επαναχρησιμοποιήσιμες μονάδες.
*   **Συναρτήσεις (Functions):** Ορισμός συναρτήσεων από τον χρήστη.
*   **Έλεγχος Τύπων (Type Checking):** Βοηθά στην ανίχνευση λαθών κατά τη μεταγλώττιση.

---

## **Ενότητα 2: Σύνταξη της MiniZinc**

### 1.  **Γενική Δομή:**
*   Ένα μοντέλο MiniZinc αποτελείται από μια σειρά **δηλώσεων (items)**.
*   **Δηλωτική Φύση:** Η σειρά των περισσότερων δηλώσεων (μεταβλητές, περιορισμοί) *δεν* έχει σημασία (εκτός αν μια δήλωση εξαρτάται από μια προηγούμενη, π.χ., χρήση μιας παραμέτρου πριν την ανάθεσή της).
*   Το μοντέλο *περιγράφει* το πρόβλημα, όχι τη διαδικασία επίλυσής του.
*   **Βασικές Κατηγορίες Δηλώσεων:**
    *   Δηλώσεις Τύπων (π.χ., enum).
    *   Δηλώσεις Μεταβλητών (παράμετροι και μεταβλητές απόφασης).
    *   Δηλώσεις Περιορισμών.
    *   Δήλωση Στόχου Επίλυσης (solve item).
    *   Δήλωση Μορφής Εξόδου (output item).
    *   Ορισμοί κατηγορημάτων (predicate) και συναρτήσεων (function).
    *   Σχόλια (`%` για μια γραμμή, `/* ... */` για πολλαπλές).

### 2.  **Τύποι Δεδομένων (Types):**
*   **Βασικοί Τύποι:**
    *   `int`: Ακέραιοι.
    *   `float`: Πραγματικοί (αριθμοί κινητής υποδιαστολής).
    *   `bool`: Λογικές τιμές (`true`, `false`).
    *   `string`: Αλφαριθμητικά (κυρίως για χρήση στην έξοδο).
*   **Πεδία/Σύνολα για int:**
    *   Εύρος: `lower..upper` (π.χ., `1..10` σημαίνει {1, 2, ..., 10}).
    *   Απαρίθμηση: `{val1, val2, ..., valn}` (π.χ., `{2, 5, 15, 42}`).
*   **Σύνθετοι Τύποι:**
    *   `array[IndexSet] of VarType`: Πίνακες (βλ. παρακάτω).
    *   `set of VarType`: Σύνολα (βλ. παρακάτω).
*   **Απαριθμητοί Τύποι (enum):**
    *   Ορισμός ενός νέου τύπου με ένα πεπερασμένο σύνολο από **συμβολικά ονόματα (items)**.
    *   Σύνταξη: `enum <ΌνομαΤύπου> = {item1, item2, ..., itemn};`
    *   **Πλεονεκτήματα:** Αυξάνουν την αναγνωσιμότητα, επιτρέπουν έλεγχο τύπων, διαχωρίζουν λογικά διαφορετικά σύνολα.
    *   **Χρήση:** Μπορούν να χρησιμοποιηθούν ως πεδία μεταβλητών ή ως δείκτες σε πίνακες.
    *   **Συναρτήσεις:** `enum_next`, `enum_prev`, `to_enum`, `enum2int` (η αυτόματη μετατροπή σε int είναι πλέον *obsolete*).
    *   **Προσοχή:** Δεν μπορούν να υπάρχουν items με το ίδιο όνομα (ακόμα και σε διαφορετικά enums), και υπάρχει αυστηρός έλεγχος τύπων (π.χ., δεν μπορείς να συγκρίνεις απευθείας τιμές από διαφορετικά enums).

### 3.  **Μεταβλητές:**
*   **Είδη:**
    *   **Παράμετροι (`par` ή προεπιλογή χωρίς `var`):** Σταθερές τιμές, είσοδος του μοντέλου. *Πρέπει* να έχουν τιμή πριν την επίλυση (είτε στο `.mzn`, είτε στο `.dzn`, είτε μέσω περιβάλλοντος).
    *   **Μεταβλητές Απόφασης (`var`):** Οι άγνωστες τιμές που ψάχνει ο solver. Η τιμή τους καθορίζεται *από* τον solver.
*   **Δήλωση:** `<Είδος> <Τύπος>: <Όνομα> [= <Αρχική τιμή/Έκφραση>];`
    *   `<Είδος>`: `par` (ή τίποτα) ή `var`.
    *   `<Τύπος>`: Ένας από τους τύπους δεδομένων (π.χ., `int`, `1..10`, `set of int`, `array[1..5] of bool`).
    *   `[= ...]` : Η ανάθεση αρχικής τιμής είναι υποχρεωτική για παραμέτρους, προαιρετική (και σπάνια) για μεταβλητές απόφασης.
*   **type-inst:** Ο συνδυασμός `Είδος + Τύπος` (π.χ., `par int`, `var bool`). Εμφανίζεται συχνά σε μηνύματα σφαλμάτων.

### 4.  **Εκφράσεις:**
*   **Αριθμητικές:** Οι συνήθεις τελεστές (`+`, `-`, `*`, `/`, `div`, `mod`) και συναρτήσεις (`abs`, `min`, `max`, `pow`, `log`, `sin`, `cos`, κ.λπ.). Διαθέσιμες συναρτήσεις μετατροπής τύπων (`int2float`, `bool2int`, `round`, `floor`, `ceil`, κ.λπ.).
*   **Λογικές (Boolean):**
    *   Συγκρίσεις: `=`, `!=` (ή `<>`), `>`, `<`, `>=`, `<=`.
    *   Λογικοί Τελεστές: `/\` (σύζευξη-AND), `\/` (διάζευξη-OR), `->` (συνεπαγωγή), `<->` (διπλή συνεπαγωγή/ισοδυναμία), `not` (άρνηση), `xor` (αποκλειστική διάζευξη).

### 5.  **Περιορισμοί (Constraints):**
*   Δηλώνονται με τη λέξη-κλειδί `constraint`.
*   Ακολουθεί μια **λογική έκφραση** που πρέπει να είναι `true` σε κάθε έγκυρη λύση.
*   `constraint <Boolean Expression>;`
*   Όλοι οι περιορισμοί που δηλώνονται θεωρούνται συνδεδεμένοι με λογικό **AND (σύζευξη)**.

### 6.  **Επίλυση (Solve Item):**
*   Καθορίζει τον στόχο του προβλήματος.
*   `solve satisfy;`: Βρες *οποιαδήποτε* λύση που ικανοποιεί όλους τους περιορισμούς (CSP).
*   `solve minimize <Arithmetic Expression>;`: Βρες μια λύση που ικανοποιεί τους περιορισμούς και ελαχιστοποιεί την τιμή της έκφρασης (COP).
*   `solve maximize <Arithmetic Expression>;`: Βρες μια λύση που ικανοποιεί τους περιορισμούς και μεγιστοποιεί την τιμή της έκφρασης (COP).

### 7.  **Έξοδος (Output Item):**
*   Προαιρετική δήλωση που καθορίζει πώς θα μορφοποιηθεί η λύση όταν βρεθεί.
*   `output [<list of strings>];`
*   Χρησιμοποιεί 文字 (strings) μέσα σε `"` `"` και τον τελεστή `++` για συνένωση.
*   Ειδικές ακολουθίες: `\n` (νέα γραμμή), `\t` (tab).
*   Εμφάνιση τιμής μεταβλητής: `\(<όνομα μεταβλητής>)`.
*   Αν παραλειφθεί, τυπώνονται οι τιμές όλων των μεταβλητών απόφασης σε απλή μορφή.

---

## **Ενότητα 3: Σύνθετοι Τύποι & Comprehensions**

### 1.  **Σύνολα (Sets):**
*   `set of <Type>`: Ορίζει έναν τύπο συνόλου.
*   Μπορούν να είναι παράμετροι (`set of int: NUMS = {10,20,30};`) ή μεταβλητές απόφασης (`var set of 1..5: s1;`).
*   **Περιορισμοί/Συναρτήσεις:** `card(S)` (πληθάριθμος), `x in S` (inclusion), `union`, `intersect`, `diff` (διαφορά), `symdiff` (συμμετρική διαφορά), `subset`, `superset`.

### 2.  **Πίνακες (Arrays):**
*   `array[IndexSet] of <Type>`: Δήλωση πίνακα.
*   `IndexSet`: Μπορεί να είναι εύρος ακεραίων (`1..N`), σύνολο (`INTSET`), ή απαριθμητός τύπος (`enum COLOR`).
*   `<Type>`: Ο τύπος των στοιχείων του πίνακα (οτιδήποτε εκτός από array).
*   Μπορούν να είναι παράμετροι ή πίνακες μεταβλητών (`array[...] of var <Type>`).
*   **Πολυδιάστατοι:** `array[IS1, IS2, ...] of <Type>`.
*   **Αρχικοποίηση:** Με λίστες `[...]` για 1D, ή με `[|...|...|]` ή `arrayNd(...)` για πολυδιάστατους.
*   **Πράξεις:** `++` (συνένωση 1D), `length(arr)` (μήκος 1D), `has_element(el, arr)`, `row(arr, r)`, `col(arr, c)`, `index_set(arr)`, `index_set_1of2(arr)`, κ.λπ.

### 3.  **Comprehensions (List/Set/Array):**
*   Ένας ισχυρός και συνοπτικός τρόπος για τη δημιουργία λιστών (για αρχικοποίηση πινάκων), συνόλων, ή για την έκφραση περιορισμών πάνω σε σύνολα στοιχείων.
*   **Σύνταξη (Βασική):**
    *   `[ <Expr> | <Generator1>, <Generator2>, ... <OptWhere> ]` (για λίστες/πίνακες)
    *   `{ <Expr> | <Generator1>, <Generator2>, ... <OptWhere> }` (για σύνολα)
*   **`<Generator>`:** ` <var> in <SetOrArray>` (π.χ., `i in 1..10`, `j in MYSET`). Ορίζει τις μεταβλητές που διατρέχουν τις τιμές.
*   **`<Expr>`:** Η έκφραση που υπολογίζεται για κάθε συνδυασμό τιμών από τους generators.
*   **`<OptWhere>`:** `where <BooleanExpr>` (προαιρετικό). Φιλτράρει τους συνδυασμούς των generators που θα χρησιμοποιηθούν.
*   **Παραδείγματα:**
    *   `{2*x | x in {10,20,30}}` -> `{20, 40, 60}`
    *   `[ i*j | i in 1..2, j in 1..3 where i != j ]` -> `[1*2, 1*3, 2*1, 2*3]` -> `[2, 3, 2, 6]`
    *   `constraint forall(i in 1..N) (a[i] > 0);` - Χρήση comprehension σε καθολικό περιορισμό.

### 4.  **Global Constraints με Comprehensions:**
*   Πολύ συχνή η χρήση comprehensions μέσα σε `forall`, `exists`, `sum`, `min`, `max`, `product`.
*   **`forall`**: Όλοι οι περιορισμοί που παράγονται από το comprehension πρέπει να ισχύουν (AND).
    *   `constraint forall(i in 1..N where i mod 2 = 0) (a[i] = 0);`
    *   Εναλλακτική μορφή: `constraint forall(i in 1..N where i mod 2 = 0) ( a[i] = 0 );`
*   **`exists`**: Τουλάχιστον ένας από τους περιορισμούς που παράγονται πρέπει να ισχύει (OR).
    *   `constraint exists(i in 1..N) (a[i] < 0);`
    *   Εναλλακτική μορφή: `constraint exists(i in 1..N) ( a[i] < 0 );`
*   `sum`, `product`, `min`, `max` σε αριθμητικές εκφράσεις.

---

## **Ενότητα 4: Έλεγχος Αναζήτησης (Search Annotations)**

1.  **Κίνητρο:** Η προεπιλεγμένη στρατηγική αναζήτησης του solver μπορεί να μην είναι η καλύτερη για ένα συγκεκριμένο πρόβλημα. Η MiniZinc επιτρέπει στον χρήστη να καθοδηγήσει την αναζήτηση.
2.  **Annotations (Σχολιασμοί Αναζήτησης):** Ειδικές "κλήσεις" που επισυνάπτονται στη δήλωση `solve`. Δεν αλλάζουν *τι* είναι λύση, αλλά *πώς* την ψάχνει ο solver.
3.  **Βασική Σύνταξη:** `solve :: <SearchAnnotation> satisfy;` (ή minimize/maximize)
4.  **Κύριες Συναρτήσεις Annotation:**
    *   `int_search(variables, var_select, val_select, complete)`
    *   `bool_search(...)`
    *   `set_search(...)`
5.  **Παράμετροι:**
    *   `variables`: Πίνακας με τις μεταβλητές απόφασης των οποίων η αναζήτηση θα ελεγχθεί.
    *   `var_select`: **Επιλογή Μεταβλητής**. Καθορίζει ποια μεταβλητή από τη λίστα θα επιλεγεί σε κάθε βήμα για να της ανατεθεί τιμή.
        *   `input_order`: Με τη σειρά που δίνονται στον πίνακα.
        *   `first_fail` (ή `smallest_domain`): Αυτή με το μικρότερο τρέχον μέγεθος πεδίου.
        *   `anti_first_fail` (ή `largest_domain`): Αυτή με το μεγαλύτερο τρέχον μέγεθος πεδίου.
        *   `smallest`: Αυτή που η μικρότερη τιμή στο πεδίο της είναι η ελάχιστη μεταξύ όλων.
        *   `largest`: Αυτή που η μεγαλύτερη τιμή στο πεδίο της είναι η μέγιστη μεταξύ όλων.
        *   `most_constrained`: Συνδυάζει `first_fail` και `degree` (πόσοι περιορισμοί την αφορούν).
        *   `dom_w_deg`: Σταθμισμένη εκδοχή.
        *   `occurrence`: Αυτή που εμφανίζεται στους περισσότερους περιορισμούς.
    *   `val_select`: **Επιλογή Τιμής**. Καθορίζει ποια τιμή από το πεδίο της επιλεγμένης μεταβλητής θα δοκιμαστεί πρώτα.
        *   `indomain`: Με τη σειρά (συνήθως αύξουσα).
        *   `indomain_min`: Δοκίμασε την ελάχιστη τιμή.
        *   `indomain_max`: Δοκίμασε τη μέγιστη τιμή.
        *   `indomain_median`: Δοκίμασε την τιμή κοντά στη μέση τιμή του πεδίου.
        *   `indomain_split`: Χώρισε το πεδίο στα δύο (προσθέτει `X <= m`).
        *   `indomain_reverse_split`: Χώρισε το πεδίο στα δύο (προσθέτει `X > m`).
        *   `outdomain_min`, `outdomain_max`: Αποκλείουν τιμές αντί να τις επιλέγουν.
    *   `complete`: (Για B&B) Στρατηγική αναζήτησης (π.χ., `dfs`, `lds`).
6.  **Συνδυασμός Στρατηγικών (`seq_search`):** Επιτρέπει την εφαρμογή διαφορετικών στρατηγικών σε διαφορετικά σύνολα μεταβλητών, διαδοχικά. `seq_search([search1, search2, ...])`.

---

## **Ενότητα 5: Άλλα Στοιχεία Σύνταξης**

1.  **`if then else endif` σε Περιορισμούς:**
    *   Χρησιμοποιείται για να ορίσει την **τιμή μιας έκφρασης υπό συνθήκη**, *όχι* για να ενεργοποιήσει/απενεργοποιήσει έναν ολόκληρο περιορισμό (αυτό γίνεται συνήθως με συνεπαγωγή `->` ή ισοδυναμία `<->`).
    *   `constraint x = (if cond then val1 else val2 endif);`
    *   Ισοδύναμο με: `constraint (cond /\ x=val1) \/ (not cond /\ x=val2);` (το οποίο ο solver μπορεί να χειριστεί).

## **Συμπεράσματα:**

*   Η MiniZinc είναι μια ισχυρή δηλωτική γλώσσα για μοντελοποίηση CSP/COP.
*   Παρέχει πλούσιο σύστημα τύπων (int, bool, float, sets, enums, arrays).
*   Ο διαχωρισμός παραμέτρων (`par`) και μεταβλητών απόφασης (`var`) είναι θεμελιώδης.
*   Τα comprehensions προσφέρουν έναν συνοπτικό τρόπο για δημιουργία δομών και έκφραση περιορισμών.
*   Οι annotations αναζήτησης (`_search`) επιτρέπουν τον λεπτομερή έλεγχο της στρατηγικής επίλυσης, ο οποίος μπορεί να είναι κρίσιμος για την απόδοση.
*   Η κατανόηση της σύνταξης και των διαθέσιμων συναρτήσεων/περιορισμών είναι το κλειδί για την αποτελεσματική χρήση της MiniZinc.
