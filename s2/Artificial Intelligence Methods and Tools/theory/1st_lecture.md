# **Ικανοποίηση Περιορισμών**

---

## **Ενότητα 1: Εισαγωγή στην Ικανοποίηση Περιορισμών (Constraint Satisfaction)**

### 1.  **Τι είναι η Ικανοποίηση Περιορισμών (Constraint Satisfaction - CS);**
*   Αφορά προβλήματα όπου η τελική λύση (κατάσταση) δεν είναι γνωστή εκ των προτέρων, αλλά γνωρίζουμε τις **ιδιότητες** ή **περιορισμούς** που πρέπει να ικανοποιεί.
*   Συχνά πρόκειται για **συνδυαστικά προβλήματα (combinatorial problems)**, όπου πρέπει να βρούμε ένα συνδυασμό τιμών ή επιλογών που ικανοποιεί όλες τις συνθήκες.
*   Παραδείγματα: Χρονοπρογραμματισμός (scheduling), Ανάθεση Πόρων (resource allocation), Σχεδιασμός Παραγωγής (production planning), Προβλήματα Δρομολόγησης, Γρίφοι (Sudoku, N-Queens).

### 2.  **Γιατί CS; Πλεονεκτήματα:**
*   **Απλή Αναπαράσταση:** Τα προβλήματα περιγράφονται με έναν ομοιόμορφο τρόπο χρησιμοποιώντας:
    *   **Μεταβλητές (Variables):** Άγνωστες τιμές που ψάχνουμε.
    *   **Πεδία Τιμών (Domains):** Το σύνολο των πιθανών τιμών για κάθε μεταβλητή.
    *   **Περιορισμούς (Constraints):** Σχέσεις μεταξύ των μεταβλητών που πρέπει να ισχύουν.
*   **Αποδοτική Επίλυση:** Συνδυάζει τεχνικές:
    *   **Αναζήτησης (Search):** Εξερεύνηση του χώρου των πιθανών λύσεων.
    *   **Διάδοσης Περιορισμών (Constraint Propagation):** Αξιοποίηση των περιορισμών για να μειωθεί ο χώρος αναζήτησης *πριν* ή *κατά τη διάρκεια* της αναζήτησης.
    *   **Ευρετικές (Heuristics):** Έξυπνες στρατηγικές για την καθοδήγηση της αναζήτησης.
*   **Δηλωτική Προσέγγιση (Constraint Programming - CP):** Ο χρήστης *περιγράφει* το πρόβλημα (μεταβλητές, πεδία, περιορισμούς) και το σύστημα CP αναλαμβάνει να βρει τη λύση. Δεν χρειάζεται να προγραμματιστεί ο αλγόριθμος επίλυσης βήμα-προς-βήμα.

### 3.  **Πρόβλημα Ικανοποίησης Περιορισμών (Constraint Satisfaction Problem - CSP) – Ορισμός:**
*   Ένα CSP ορίζεται από μια τριάδα (V, D, C):
    *   **V:** Ένα σύνολο n **μεταβλητών** {V₁, V₂, ..., Vₙ}.
    *   **D:** Ένα σύνολο n **πεδίων τιμών** {D₁, D₂, ..., Dₙ}, όπου κάθε Dᵢ είναι το σύνολο των πιθανών τιμών για τη μεταβλητή Vᵢ.
    *   **C:** Ένα σύνολο m **περιορισμών** {C₁, C₂, ..., Cₕ}. Κάθε περιορισμός Cₖ:
        *   Έχει ένα **scope** (πεδίο εφαρμογής): το υποσύνολο των μεταβλητών στις οποίες αναφέρεται.
        *   Καθορίζει μια **σχέση (relation)**: το σύνολο των συνδυασμών τιμών (ν-άδων) για τις μεταβλητές του scope που ικανοποιούν τον περιορισμό.
*   **Αναπαράσταση Περιορισμών:**
    *   **Extensional:** Απαρίθμηση όλων των επιτρεπτών συνδυασμών (π.χ., c(x₁,x₂) = {(1,2), (2,1)}).
    *   **Intensional:** Χρήση μαθηματικού τύπου ή λογικής έκφρασης (π.χ., c: x₁ ≠ x₂).

### 4.  **Τύποι Περιορισμών:**
*   **Μοναδιαίος (Unary):** Αφορά μία μόνο μεταβλητή (π.χ., V₁ > 5). Περιορίζει το πεδίο τιμών της.
*   **Δυαδικός (Binary):** Αφορά δύο μεταβλητές (π.χ., V₁ ≠ V₂). Ο πιο συνηθισμένος τύπος.
*   **Ανώτερης Τάξης (Higher-order / Global):** Αφορά τρεις ή περισσότερες μεταβλητές (π.χ., alldifferent(V₁, V₂, V₃)).

### 5.  **Λύση ενός CSP:**
*   Μια **ανάθεση (assignment)** τιμών σε *όλες* τις μεταβλητές (V₁=d₁, V₂=d₂, ..., Vₙ=dₙ) τέτοια ώστε:
    *   Κάθε τιμή dᵢ να ανήκει στο πεδίο Dᵢ της μεταβλητής Vᵢ.
    *   Να ικανοποιούνται **όλοι** οι περιορισμοί C.
*   **Πρόκληση:** Ο χώρος των πιθανών αναθέσεων μπορεί να είναι τεράστιος (combinatorial explosion), καθιστώντας την απλή δοκιμή όλων των συνδυασμών ανέφικτη. Χρειάζονται πιο έξυπνες μέθοδοι.

---

## **Ενότητα 2: Αλγόριθμοι Επίλυσης CSP**

### 1.  **Παραγωγή και Δοκιμή (Generate and Test):**
*   Η πιο απλή προσέγγιση.
*   Μια "γεννήτρια" παράγει συστηματικά *όλες* τις πιθανές πλήρεις αναθέσεις.
*   Ένας "ελεγκτής" ελέγχει αν κάθε παραγόμενη ανάθεση ικανοποιεί όλους τους περιορισμούς.
*   **Μειονέκτημα:** Εξαιρετικά αναποτελεσματικό. Δεν αξιοποιεί τους περιορισμούς για να περιορίσει την παραγωγή λύσεων.

### 2.  **Αλγόριθμοι Επιδιόρθωσης (Repair Algorithms):**
*   Ξεκινούν με μια *πλήρη* ανάθεση (πιθανόν τυχαία και μη έγκυρη).
*   Προσπαθούν *σταδιακά* να την "επιδιορθώσουν", αλλάζοντας τιμές μεταβλητών ώστε να μειωθεί ο αριθμός των παραβιάσεων περιορισμών.
*   **Παραδείγματα:**
    *   **Αναρρίχηση Λόφου (Hill-Climbing):** Σε κάθε βήμα, αλλάζει την τιμή μιας μεταβλητής έτσι ώστε να ελαχιστοποιείται ο αριθμός των παραβιάσεων. Μπορεί να "κολλήσει" σε τοπικά βέλτιστα (local optima).
    *   **Ελαχίστων Συγκρούσεων (Min-Conflicts):** Επιλέγει τυχαία μια μεταβλητή που παραβιάζει κάποιον περιορισμό. Αλλάζει την τιμή της στην τιμή που προκαλεί τις λιγότερες νέες παραβιάσεις. Συχνά πιο αποτελεσματικό από το απλό Hill-Climbing.
*   **Πλεονεκτήματα:** Σχετικά εύκολοι στην υλοποίηση, μπορούν να χειριστούν μεγάλα προβλήματα.
*   **Μειονεκτήματα:** **Μη-πλήρεις** (δεν εγγυώνται εύρεση λύσης αν υπάρχει), **όχι βέλτιστοι** (δεν εγγυώνται την καλύτερη λύση σε προβλήματα βελτιστοποίησης).

### 3.  **Κλασικοί Αλγόριθμοι Αναζήτησης (Backtracking Search):**
*   Η πιο θεμελιώδης και ευρέως χρησιμοποιούμενη *πλήρης* μέθοδος (εγγυάται εύρεση λύσης αν υπάρχει).
*   Χτίζει τη λύση βήμα-βήμα, αναθέτοντας τιμές σε μεταβλητές μία-μία.
*   **Διαδικασία:**
    1.  Επίλεξε μια μεταβλητή χωρίς τιμή.
    2.  Επίλεξε μια τιμή από το πεδίο της.
    3.  Έλεγξε αν η τιμή αυτή είναι **συνεπής (consistent)** με τις τιμές που έχουν ήδη ανατεθεί (δηλαδή, δεν παραβιάζει κανέναν περιορισμό που αφορά μόνο τις ήδη ανατεθειμένες μεταβλητές).
    4.  Αν είναι συνεπής:
        *   Αν όλες οι μεταβλητές έχουν τιμή -> Βρέθηκε λύση. Τέλος.
        *   Αλλιώς -> Προχώρα αναδρομικά στο βήμα 1 για την επόμενη μεταβλητή.
    5.  Αν ΔΕΝ είναι συνεπής (ή αν η αναδρομική κλήση απέτυχε να βρει λύση):
        *   Δοκίμασε την επόμενη διαθέσιμη τιμή για την τρέχουσα μεταβλητή (πήγαινε στο βήμα 2).
        *   Αν δεν υπάρχουν άλλες τιμές -> Η τρέχουσα μερική ανάθεση οδηγεί σε αδιέξοδο. **Οπισθοδρόμησε (Backtrack):** Ακύρωσε την τρέχουσα ανάθεση και γύρνα στην προηγούμενη μεταβλητή για να δοκιμάσει άλλη τιμή.
*   Η σειρά επιλογής μεταβλητών και τιμών επηρεάζει δραματικά την απόδοση.

### 4.  **Ευρετικοί Μηχανισμοί (Heuristics) για Backtracking:**
*   Βελτιώνουν την απόδοση της οπισθοδρόμησης καθοδηγώντας τις επιλογές.
*   **Variable Ordering (Σειρά Επιλογής Μεταβλητών):** Ποια μεταβλητή να επιλέξουμε για ανάθεση;
    *   **First Fail Principle:** Επίλεξε τη μεταβλητή που είναι πιο πιθανό να αποτύχει (να οδηγήσει γρήγορα σε αδιέξοδο), ώστε να κλαδευτεί νωρίς το δέντρο αναζήτησης.
    *   Κοινές ευρετικές:
        *   **Minimum Remaining Values (MRV) / dom:** Επίλεξε τη μεταβλητή με το μικρότερο *τρέχον* πεδίο τιμών.
        *   **Highest Degree (deg):** Επίλεξε τη μεταβλητή που συμμετέχει στους περισσότερους περιορισμούς με *μη ανατεθειμένες* ακόμα μεταβλητές.
        *   Συνδυασμοί (π.χ., dom/deg).
*   **Value Ordering (Σειρά Επιλογής Τιμών):** Ποια τιμή να δοκιμάσουμε πρώτα για την επιλεγμένη μεταβλητή;
    *   **Least Constraining Value:** Προτίμησε την τιμή που αποκλείει τις λιγότερες επιλογές για τις γειτονικές (μέσω περιορισμών) μη ανατεθειμένες μεταβλητές. Αυξάνει την πιθανότητα να βρεθεί λύση χωρίς οπισθοδρόμηση.

---

## **Ενότητα 3: Διάδοση Περιορισμών (Constraint Propagation / Consistency Techniques)**

1.  **Ιδέα:** Χρησιμοποίησε τους περιορισμούς *ενεργά* για να μειώσεις τα πεδία τιμών των μεταβλητών, αφαιρώντας τιμές που *σίγουρα* δεν μπορούν να συμμετέχουν σε καμία λύση. Αυτό γίνεται *πριν* ή *κατά τη διάρκεια* της αναζήτησης.
2.  **Στόχος:** Να επιτευχθεί ένα ορισμένο επίπεδο **συνέπειας (consistency)**.
3.  **Συνέπεια Κόμβου (Node Consistency - NC):**
    *   Η απλούστερη μορφή.
    *   Μια μεταβλητή είναι συνεπής ως προς τον κόμβο αν όλες οι τιμές στο πεδίο της ικανοποιούν τους *μοναδιαίους* περιορισμούς που την αφορούν.
    *   Εύκολο να επιτευχθεί: Απλά αφαίρεσε τις ασυνεπείς τιμές από το αρχικό πεδίο.
4.  **Συνέπεια Τόξου (Arc Consistency - AC):**
    *   Η πιο συνηθισμένη και σημαντική μορφή συνέπειας. Αφορά *δυαδικούς* περιορισμούς.
    *   Ένα **τόξο (arc)** (Vᵢ, Vⱼ) είναι συνεπές αν για *κάθε* τιμή x στο πεδίο Dᵢ της Vᵢ, υπάρχει *τουλάχιστον μία* τιμή y στο πεδίο Dⱼ της Vⱼ τέτοια ώστε η ανάθεση (Vᵢ=x, Vⱼ=y) να ικανοποιεί τον δυαδικό περιορισμό μεταξύ τους.
    *   Αν μια τιμή x της Vᵢ δεν έχει "υποστήριξη" (support) στην Vᵢ , τότε η x μπορεί να αφαιρεθεί με ασφάλεια από το Dᵢ.
    *   Ένα CSP είναι **τόξο-συνεπές (arc-consistent)** αν *όλα* τα τόξα του είναι συνεπή.
    *   **Αλγόριθμος AC-3:** Ο κλασικός αλγόριθμος για την επίτευξη AC. Διατηρεί μια λίστα με τα τόξα προς έλεγχο. Όταν αφαιρεί μια τιμή από ένα πεδίο Dᵢ λόγω του τόξου (Vᵢ, Vⱼ), πρέπει να ξαναελέγξει όλα τα άλλα τόξα (Vₖ, Vᵢ) που καταλήγουν στην Vᵢ. Συνεχίζει μέχρι να μην αφαιρούνται άλλες τιμές.
    *   **Βελτιώσεις:** AC-2001, AC-4 κ.λπ., βελτιώνουν την απόδοση αποφεύγοντας περιττούς ελέγχους.
    *   **Μειονέκτημα:** Η AC **δεν είναι πλήρης**. Μπορεί ένα πρόβλημα να είναι AC αλλά να μην έχει λύση (βλ. παράδειγμα με 3 μεταβλητές [1,2] και all-different).
5.  **Άλλες Μορφές Συνέπειας:**
    *   **Συνέπεια Μονοπατιού (Path Consistency):** Επεκτείνει την ιδέα σε τριάδες μεταβλητών. Πιο ισχυρή από AC, αλλά σημαντικά πιο ακριβή υπολογιστικά.
    *   **K-Consistency:** Γενίκευση. Ένα CSP είναι k-συνεπές αν οποιαδήποτε συνεπής ανάθεση σε k-1 μεταβλητές μπορεί να επεκταθεί σε μια συνεπή ανάθεση για οποιαδήποτε k-οστή μεταβλητή. (AC είναι 2-consistency).
    *   **Bounds Consistency:** Για πεδία ακεραίων, ελέγχει τη συνέπεια μόνο για τις *οριακές* (min/max) τιμές του πεδίου. Πιο γρήγορη αλλά λιγότερο ισχυρή από την AC.
6.  **Καθολικοί Περιορισμοί (Global Constraints):**
    *   Ειδικοί περιορισμοί που αφορούν πολλές μεταβλητές και εκφράζουν συνηθισμένες δομές προβλημάτων (π.χ., `alldifferent`, `cumulative`, `element`, `regular`).
    *   Διαθέτουν *εξειδικευμένους και αποδοτικούς αλγορίθμους διάδοσης (propagators)* που συχνά επιτυγχάνουν ισχυρότερη συνέπεια από την απλή AC στα επιμέρους δυαδικά ισοδύναμα.
    *   Η χρήση τους είναι κρίσιμη για την αποτελεσματική επίλυση πολλών πραγματικών προβλημάτων. Υπάρχει ένας "Κατάλογος Καθολικών Περιορισμών" (Global Constraint Catalog) με εκατοντάδες τέτοιους περιορισμούς.

---

## **Ενότητα 4: Συνδυασμός Αναζήτησης και Διάδοσης**

1.  **Κίνητρο:** Η αναζήτηση είναι πλήρης αλλά αργή. Η διάδοση είναι γρήγορη αλλά μη-πλήρης. Ο συνδυασμός τους είναι ο πιο αποτελεσματικός τρόπος.
2.  **Ιδέα:** Ενσωμάτωσε τη διάδοση περιορισμών *μέσα* στον αλγόριθμο αναζήτησης (Backtracking).
3.  **Στρατηγικές:**
    *   **Forward Checking (FC):** Μετά την ανάθεση μιας τιμής Vᵢ=x, έλεγξε *μόνο* τους περιορισμούς που συνδέουν την Vᵢ με *μελλοντικές* (μη ανατεθειμένες) μεταβλητές Vⱼ. Αφαίρεσε τιμές από τα πεδία των Vⱼ που γίνονται ασυνεπείς λόγω της Vᵢ=x. Δεν ελέγχει συνέπεια *μεταξύ* των μελλοντικών μεταβλητών.
    *   **Maintaining Arc Consistency (MAC) / Full Look Ahead:** Η πιο ισχυρή προσέγγιση. Μετά από *κάθε* ανάθεση Vᵢ=x, εκτέλεσε έναν αλγόριθμο AC (π.χ., AC-3) σε *ολόκληρο* το (τροποποιημένο) πρόβλημα για να επαναφέρεις την τόξο-συνέπεια. Κλαδεύει πολύ περισσότερο το δέντρο αναζήτησης, αλλά έχει μεγαλύτερο κόστος ανά κόμβο.
    *   **Partial Look Ahead:** Ενδιάμεσες στρατηγικές που εφαρμόζουν περιορισμένη διάδοση (π.χ., κατευθυντική συνέπεια).
4.  **Αποτέλεσμα:** Δραματική μείωση του μεγέθους του δέντρου αναζήτησης που χρειάζεται να εξερευνηθεί.

---

## **Ενότητα 5: Βελτιστοποίηση Περιορισμών (Constraint Optimization)**

1.  **Πρόβλημα:** Πολλές φορές δεν θέλουμε απλά *μια* λύση, αλλά την *καλύτερη* λύση σύμφωνα με κάποιο κριτήριο (objective function). Π.χ., το χρονοδιάγραμμα με τη μικρότερη διάρκεια, η ανάθεση πόρων με το ελάχιστο κόστος.
2.  **Constraint Optimization Problem (COP):** Ένα CSP συν μια συνάρτηση βελτιστοποίησης προς ελαχιστοποίηση ή μεγιστοποίηση.
3.  **Αλγόριθμος Διακλάδωσης και Οριοθέτησης (Branch and Bound - B&B):**
    *   Προσαρμογή της αναζήτησης για βελτιστοποίηση.
    *   Διατηρεί την τιμή της *καλύτερης λύσης που έχει βρεθεί μέχρι στιγμής* (incumbent solution), έστω `Cost`.
    *   Κατά την αναζήτηση, αν ένας μερικός κλάδος (κόμβος) αποδειχθεί ότι *δεν μπορεί* να οδηγήσει σε λύση καλύτερη από `Cost` (π.χ., το τρέχον κόστος συν μια αισιόδοξη εκτίμηση για το υπόλοιπο ξεπερνά το `Cost`), τότε αυτός ο κλάδος **κλαδεύεται (pruned)**.
    *   Όταν βρίσκεται μια νέα λύση με κόστος `NewCost < Cost`, η `Cost` ενημερώνεται (`Cost = NewCost`).
    *   Στο CP, αυτό συχνά υλοποιείται:
        1.  Βρες μια πρώτη λύση (κόστος `Cost`).
        2.  Πρόσθεσε έναν νέο περιορισμό: `Objective < Cost`.
        3.  Ξεκίνα νέα αναζήτηση.
        4.  Επανάλαβε μέχρι η αναζήτηση να αποτύχει (η τελευταία λύση που βρέθηκε ήταν η βέλτιστη).

---

## **Ενότητα 6: Υλοποιήσεις και Προγραμματισμός με Περιορισμούς**

1.  **Παράδειγμα Constraint Programming (CP):** Ένα αυτόνομο πεδίο προγραμματισμού.
2.  **Είδη Συστημάτων CP:**
    *   **Βιβλιοθήκες (Libraries):** Ενσωματώνονται σε κλασικές γλώσσες (C++, Java, Python). Παρέχουν δομές δεδομένων για μεταβλητές, πεδία, και υλοποιήσεις για περιορισμούς και αλγορίθμους αναζήτησης/διάδοσης.
        *   Παραδείγματα: Gecode (C++), Google OR-Tools (multi-language), Choco (Java), JaCoP (Java), IBM CPLEX CP Optimizer, Gurobi Optimizer.
    *   **Επεκτάσεις Γλωσσών (Language Extensions):** Επεκτείνουν υπάρχουσες γλώσσες, κυρίως τη Logic Programming (Prolog), για να υποστηρίζουν περιορισμούς. Αυτό είναι το **Constraint Logic Programming (CLP)**.
        *   Παραδείγματα: SICStus Prolog, ECLiPSe CLP.
    *   **Γλώσσες Μοντελοποίησης (Modeling Languages):** Γλώσσες υψηλού επιπέδου, καθαρά δηλωτικές, σχεδιασμένες για την *περιγραφή* του CSP/COP. Το μοντέλο μεταφράζεται (συχνά σε ενδιάμεση μορφή "FlatZinc") και δίνεται σε έναν ανεξάρτητο **solver** για επίλυση.
        *   Παραδείγματα: **MiniZinc** (δημοφιλές, open-source), OPL (IBM), AMPL.
3.  **CP vs Integer/Linear Programming (ILP/LP):**
    *   **Ομοιότητες:** Και τα δύο αφορούν μεταβλητές, περιορισμούς, βελτιστοποίηση.
    *   **Διαφορές CP:**
        *   Υποστηρίζει ευρύτερη γκάμα περιορισμών (λογικούς, αριθμητικούς μη-γραμμικούς, global constraints).
        *   Εστίαση κυρίως σε διακριτές (ακέραιες) μεταβλητές.
        *   Η επίλυση βασίζεται σε συνδυασμό αναζήτησης (backtracking) και διάδοσης (propagation/filtering).
    *   **Διαφορές ILP/LP:**
        *   Εστίαση σε γραμμικούς περιορισμούς και συναρτήσεις.
        *   Μπορεί να χειριστεί συνεχείς μεταβλητές εύκολα (LP).
        *   Η επίλυση βασίζεται σε τεχνικές όπως Simplex, Interior Point, Branch and Cut.
    *   Συχνά είναι συμπληρωματικές τεχνολογίες.

4.  **MiniZinc (Παράδειγμα Γλώσσας Μοντελοποίησης):**
    *   **Δομή Μοντέλου:**
        *   Δήλωση παραμέτρων (αν υπάρχουν).
        *   Δήλωση μεταβλητών και των πεδίων τους (`var <domain>: <name>;`).
        *   Δήλωση περιορισμών (`constraint <expression>;`). Χρήση `include` για global constraints.
        *   Δήλωση στόχου επίλυσης (`solve satisfy;` για CSP, `solve minimize/maximize <objective_var>;` για COP).
    *   Επιτρέπει γρήγορη και καθαρή περιγραφή του προβλήματος.

---

## **Συμπεράσματα:**

*   Η Ικανοποίηση Περιορισμών παρέχει ένα ισχυρό πλαίσιο για τη μοντελοποίηση και επίλυση συνδυαστικών προβλημάτων.
*   Η αποδοτική επίλυση βασίζεται στον έξυπνο συνδυασμό τεχνικών Αναζήτησης (Backtracking) και Διάδοσης Περιορισμών (Consistency).
*   Οι Ευρετικές και οι Καθολικοί Περιορισμοί παίζουν κρίσιμο ρόλο στην πρακτική απόδοση.
*   Το Constraint Programming προσφέρει δηλωτικά εργαλεία (βιβλιοθήκες, γλώσσες) που διευκολύνουν την εφαρμογή αυτών των τεχνικών.

---

# **Βίντεο:**  

## Constraint Satisfaction Problems

[Constraint Satisfaction Problems (CSPs) 1 - Overview | Stanford CS221: AI (Autumn 2021)](https://youtu.be/-IO4fPO0rxk?si=5zDCdeyP3Be2w8Sf)    
[Constraint Satisfaction Problems (CSPs) 2 - Definitions | Stanford CS221: AI (Autumn 2021)](https://youtu.be/uj5wCcHsSlA?si=Q8RegQn_4bwqKsZ7)   
[Constraint Satisfaction Problems (CSPs) 3 - Examples | Stanford CS221: AI (Autumn 2021)](https://youtu.be/Tu6BiZhMDCc?si=SbWPYCUwQ35JC0FD)   
[Constraint Satisfaction Problems (CSPs) 4 - Dynamic Ordering | Stanford CS221: AI (Autumn 2021)](https://youtu.be/Lyu8VzbIe_A?si=0CHVDFw9ufvcs_hp)   
[Constraint Satisfaction Problems (CSPs) 5 - Arc Consistency | Stanford CS221: AI (Autumn 2021)](https://youtu.be/5rlIYGJdPy4?si=z6W8KPZrQzxbaeee)   
[Constraint Satisfaction Problems (CSPs) 6 - Beam Search | Stanford CS221: AI (Autumn 2021)](https://youtu.be/XuWMeIHGkus?si=TBfDbJLlggGCA9Y3)   
[Constraint Satisfaction Problems (CSPs) 7 - Local Search | Stanford CS221: AI (Autumn 2021)](https://youtu.be/VwZKPlK6jUg?si=egX0blcyHzv0YC09)   
[An Introduction To Constraint Programming - Jacob Allen](https://www.youtube.com/watch?v=1FJy-ubE7UE)    
[Combinatorial Explosion](https://youtu.be/T0KYF-hvr0A?si=cgAXq4wdGgyG7XOq)   
[Hill Climbing Search](https://youtu.be/VoUotaCmDk4?si=iakOKoK6NdkWAR0E)   
[Min-Conflicts Algorithm for AI Class 2011](https://youtu.be/n0si9JVZMQ0?si=9fIKB3XX3UX97zf9)   
