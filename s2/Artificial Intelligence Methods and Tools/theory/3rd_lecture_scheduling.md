# Σημειώσεις για τον Χρονοπρογραμματισμό στη Μοντελοποίηση Προβλημάτων

---

## **Ενότητα 1: Εισαγωγή στον Χρονοπρογραμματισμό**

1.  **Τι είναι ο Χρονοπρογραμματισμός;**
    *   Είναι η διαδικασία της **ανάθεσης πόρων (resources)** σε **εργασίες (tasks ή jobs)** μέσα σε ένα συγκεκριμένο **χρονικό διάστημα (time horizon)**.
    *   Η ανάθεση αυτή γίνεται με βάση ένα σύνολο **περιορισμών (constraints)** που πρέπει να ικανοποιούνται.
    *   Συνήθως υπάρχει και ένα **κριτήριο βελτιστοποίησης (objective function)** που θέλουμε να ελαχιστοποιήσουμε ή να μεγιστοποιήσουμε (π.χ., ελαχιστοποίηση συνολικής διάρκειας, ελαχιστοποίηση καθυστερήσεων).
    *   Αποτελεί κλασικό πεδίο εφαρμογής του Constraint Programming (CP) και της Επιχειρησιακής Έρευνας.

2.  **Βασικά Συστατικά:**
    *   **Εργασίες (Tasks/Jobs):** Δραστηριότητες που πρέπει να εκτελεστούν.
    *   **Πόροι (Resources):** Οτιδήποτε απαιτείται για την εκτέλεση των εργασιών και έχει περιορισμένη διαθεσιμότητα (π.χ., μηχανές, άνθρωποι, ενέργεια).
    *   **Χρόνος:** Η διάσταση κατά μήκος της οποίας προγραμματίζονται οι εργασίες.
    *   **Περιορισμοί:** Κανόνες που διέπουν πώς και πότε μπορούν να εκτελεστούν οι εργασίες και να χρησιμοποιηθούν οι πόροι.
    *   **Στόχος/Κριτήριο:** Μια συνάρτηση που μετρά την "ποιότητα" του χρονοπρογράμματος.

---

## **Ενότητα 2: Χαρακτηριστικά Εργασιών και Πόρων**

1.  **Χαρακτηριστικά Εργασιών:**
    *   **Απαιτήσεις σε Πόρους (`rᵢ`):** Ποιον πόρο(ους) και σε τι ποσότητα χρειάζεται η εργασία `i`.
    *   **Χρόνος Έναρξης (`sᵢ` - start time):** Η χρονική στιγμή που ξεκινά η εργασία `i`. Συνήθως μια μεταβλητή απόφασης. Το πεδίο της μπορεί να περιορίζεται από τον νωρίτερο δυνατό χρόνο έναρξης (`estᵢ` - earliest start time).
    *   **Χρόνος Ολοκλήρωσης (`cᵢ` ή `endᵢ` - completion/end time):** Η χρονική στιγμή που τελειώνει η εργασία `i`. Συνήθως μια μεταβλητή απόφασης. Το πεδίο της μπορεί να περιορίζεται από τον αργότερο επιτρεπτό χρόνο ολοκλήρωσης (`lctᵢ` ή `letᵢ` - latest completion/end time).
    *   **Διάρκεια (`dᵢ` - duration):** Το χρονικό διάστημα που απαιτείται για την εκτέλεση της εργασίας `i`. Μπορεί να είναι:
        *   Σταθερή (`dᵢ = cᵢ - sᵢ`).
        *   Εξαρτώμενη από τον πόρο (χρόνος επεξεργασίας - `pᵢⱼ`: processing time της εργασίας `i` στον πόρο `j`).
        *   Μεταβλητή (σε elastic scheduling).
    *   **Βάρος (`wᵢ` - weight):** Δηλώνει τη σχετική σημασία ή προτεραιότητα της εργασίας `i`, συχνά χρησιμοποιείται σε συναρτήσεις βελτιστοποίησης.

2.  **Είδη Εργασιών (ως προς τη Διακοπή):**
    *   **Μη Προεκτοπιστικές (Non-preemptive):** Μόλις μια εργασία ξεκινήσει, πρέπει να ολοκληρωθεί χωρίς διακοπή (`dᵢ = cᵢ - sᵢ`). Η πιο συνηθισμένη περίπτωση.
    *   **Προεκτοπιστικές (Preemptive):** Η εκτέλεση μιας εργασίας μπορεί να διακοπεί και να συνεχιστεί αργότερα. Η συνολική διάρκεια `dᵢ` είναι το άθροισμα των διαστημάτων εκτέλεσης (`dᵢ = Σ(d<0xE2><0x82><0x96>ᵢ)`). Μπορεί να υπάρχουν περιορισμοί στα διαστήματα διακοπής.

3.  **Είδη Εργασιών (ως προς τη Διάρκεια):**
    *   **Σταθερής Διάρκειας:** Το `dᵢ` είναι δεδομένο.
    *   **Ελαστικές (Elastic):** Η διάρκεια `dᵢ` είναι μεταβλητή απόφασης, αλλά συνδέεται με την ποσότητα πόρου `rᵢ` που χρησιμοποιεί, συχνά μέσω μιας σταθερής "ενέργειας" (`Eᵢ = dᵢ * rᵢ = σταθερό`). Όσο περισσότερο πόρο χρησιμοποιεί, τόσο μικρότερη η διάρκεια.

4.  **Τύποι Πόρων:**
    *   **Επαναχρησιμοποιήσιμοι (Reusable):** Δεσμεύονται από μια εργασία για τη διάρκειά της και απελευθερώνονται μετά την ολοκλήρωσή της (π.χ., μηχανές, εργατικό δυναμικό). Έχουν **συνολική χωρητικότητα (capacity `Qk`)** η οποία μπορεί να είναι 1 (unary resource) ή >1. Η συνολική χρήση του πόρου σε κάθε χρονική στιγμή `t` δεν πρέπει να υπερβαίνει το `Qk`.
    *   **Καταναλισκόμενοι (Consumable):** Παράγονται ή καταναλώνονται από τις εργασίες και δεν επανέρχονται στην αρχική τους κατάσταση (π.χ., πρώτες ύλες, ενέργεια, χρήματα). Η μοντελοποίηση αφορά συνήθως τη διατήρηση του "αποθέματος" πάνω από κάποιο όριο.

---

## **Ενότητα 3: Τύποι Scheduling και Περιορισμοί**

1.  **Disjunctive vs Cumulative Scheduling:**
    *   **Disjunctive Scheduling:** Όταν όλοι οι πόροι έχουν **χωρητικότητα 1 (unary resources)**. Αν δύο εργασίες `E₁`, `E₂` απαιτούν τον ίδιο πόρο, τότε *δεν* μπορούν να εκτελούνται ταυτόχρονα. Πρέπει είτε η `E₁` να τελειώσει πριν ξεκινήσει η `E₂` (`c₁ ≤ s₂`), είτε η `E₂` να τελειώσει πριν ξεκινήσει η `E₁` (`c₂ ≤ s₁`). Άρα ισχύει η διάζευξη: `c₁ ≤ s₂ \/ c₂ ≤ s₁`.
    *   **Cumulative Scheduling:** Όταν τουλάχιστον ένας πόρος έχει **χωρητικότητα > 1**. Πολλές εργασίες μπορούν να εκτελούνται ταυτόχρονα στον ίδιο πόρο, αρκεί το **άθροισμα** των απαιτήσεών τους σε πόρο σε **κάθε χρονική στιγμή `t`** να μην ξεπερνά τη συνολική χωρητικότητα του πόρου.

2.  **Συνήθεις Περιορισμοί:**
    *   **Χρονικά Όρια (Time Bounds):**
        *   **Χρόνος Ανακοίνωσης / Απελευθέρωσης (Release Date `rᵢ`):** Η εργασία `i` δεν μπορεί να ξεκινήσει *πριν* από τη στιγμή `rᵢ` (`sᵢ ≥ rᵢ`). Συνήθως μοντελοποιείται θέτοντας `estᵢ = rᵢ`.
        *   **Χρόνος Παράδοσης / Προθεσμία (Due Date `δᵢ` ή Deadline):** Η εργασία `i` *πρέπει* (ή είναι επιθυμητό) να ολοκληρωθεί *μέχρι* τη στιγμή `δᵢ`. Αν ολοκληρωθεί μετά (`cᵢ > δᵢ`), μπορεί να υπάρξει ποινή (lateness/tardiness). Συχνά μοντελοποιείται θέτοντας `lctᵢ = δᵢ`.
    *   **Περιορισμοί Διάταξης (Precedence Constraints):** Μια εργασία `i` πρέπει να ολοκληρωθεί πριν μπορέσει να ξεκινήσει μια άλλη εργασία `j` (`cᵢ ≤ sⱼ` ή `end[i] <= start[j]` στην ορολογία του παραδείγματος). Μπορεί να υπάρχουν και πιο σύνθετοι περιορισμοί (π.χ., `start-to-start`, `start-to-end`).
    *   **Περιορισμοί Πόρων (Resource Constraints):**
        *   Μια εργασία `i` *πρέπει* να εκτελεστεί σε συγκεκριμένο πόρο `j`.
        *   Η συνολική χρήση ενός πόρου δεν πρέπει να ξεπερνά τη χωρητικότητά του (Disjunctive/Cumulative).
    *   **Περιορισμοί Καταλληλότητας Πόρων:**
        *   **Χρόνοι Αρχικοποίησης (Setup Times):** Αν μια εργασία `j` ακολουθεί αμέσως μετά την `i` στον ίδιο πόρο, μπορεί να απαιτείται ένας χρόνος `setupᵢⱼ` μεταξύ τους (`sⱼ ≥ cᵢ + setupᵢⱼ`).
        *   **Εναλλακτικοί Πόροι:** Μια εργασία μπορεί να εκτελεστεί σε έναν από πολλούς διαθέσιμους πόρους, πιθανόν με διαφορετικές διάρκειες/κόστη.

---

## **Ενότητα 4: Συναρτήσεις Βελτιστοποίησης (Κριτήρια)**

*   Στόχος είναι συνήθως η ελαχιστοποίηση ενός μεγέθους. Κοινά κριτήρια περιλαμβάνουν:
    *   **Χρόνος Ολοκλήρωσης Χρονοπρογράμματος (Makespan):** Ο χρόνος ολοκλήρωσης της *τελευταίας* εργασίας. `minimize max(c₁, ..., cₙ)`.
    *   **Συνολικός (Σταθμισμένος) Χρόνος Ολοκλήρωσης (Total Weighted Completion Time):** Το (σταθμισμένο) άθροισμα των χρόνων ολοκλήρωσης όλων των εργασιών. `minimize Σ(wᵢ * cᵢ)`.
    *   **Μέγιστη Αργοπορία (Maximum Lateness):** Η μέγιστη διαφορά μεταξύ χρόνου ολοκλήρωσης και προθεσμίας. `minimize max(l₁, ..., lₙ)` όπου `lᵢ = cᵢ - δᵢ`. (Η αργοπορία μπορεί να είναι αρνητική αν η εργασία τελειώσει νωρίς).
    *   **Μέγιστη Καθυστέρηση (Maximum Tardiness):** Παρόμοια με την αργοπορία, αλλά λαμβάνει υπόψη μόνο τις θετικές τιμές (πραγματικές καθυστερήσεις). `minimize max(τ₁, ..., τₙ)` όπου `τᵢ = max(0, cᵢ - δᵢ)`.
    *   **Συνολική Σταθμισμένη Καθυστέρηση (Total Weighted Tardiness):** `minimize Σ(wᵢ * τᵢ)`.
    *   **Συνολικός Αριθμός Καθυστερημένων Εργασιών:** `minimize |{ i | cᵢ > δᵢ }|`.
    *   **Συνολικό Κόστος Πόρων:** Ελαχιστοποίηση του κόστους που σχετίζεται με τη χρήση των πόρων.

---

## **Ενότητα 5: Μοντελοποίηση σε Constraint Programming (με MiniZinc)**

1.  **Αναπαράσταση Χρόνου:** Συνήθως χρησιμοποιούνται διακριτές χρονικές στιγμές (ακέραιοι αριθμοί), ξεκινώντας από το 0.
2.  **Βασικές Μεταβλητές:** Για κάθε εργασία `i`:
    *   `var int: start[i];` (με κατάλληλο αρχικό πεδίο, π.χ., `0..max_horizon`)
    *   `var int: end[i];` (με κατάλληλο αρχικό πεδίο)
3.  **Σύνδεση Start, End, Duration:**
    *   `par int: duration[i];` (Αν η διάρκεια είναι σταθερή)
    *   `constraint forall(i in JOBS) (end[i] = start[i] + duration[i]);`
4.  **Μοντελοποίηση Περιορισμών Διάταξης:**
    *   Αν (i, j) σημαίνει "η i προηγείται της j":
    *   `constraint end[i] <= start[j];`
    *   Για πολλαπλούς περιορισμούς, συχνά δίνονται ως δεδομένα σε έναν πίνακα `order`:
        ```minizinc
        array[1..num_orders, 1..2] of int: order;
        constraint forall(o in 1..num_orders) (
            end[order[o,1]] <= start[order[o,2]]
        );
        ```
5.  **Μοντελοποίηση Περιορισμών Πόρων (Unary Resources - Disjunctive):**
    *   **Πρόβλημα:** Ο απλός περιορισμός διάζευξης `end[i] <= start[j] \/ end[j] <= start[i]` είναι αδύναμος στη διάδοση.
    *   **Λύση:** Χρήση του **καθολικού περιορισμού `disjunctive`**:
        ```minizinc
        include "globals.mzn"; // (ή "disjunctive.mzn")

        // Για εργασίες task_set που τρέχουν στη Μηχανή Μ
        constraint disjunctive(
            [start[i] | i in task_set], // Πίνακας χρόνων έναρξης
            [duration[i] | i in task_set] // Πίνακας διαρκειών
        );
        ```
    *   Ο `disjunctive` εφαρμόζει πολύ πιο ισχυρές τεχνικές διάδοσης (όπως Edge Finding, Not-first/Not-last rules) για να μειώσει τα πεδία των `start` χρόνων.

6.  **Μοντελοποίηση Περιορισμών Πόρων (Capacity > 1 - Cumulative):**
    *   Χρήση του **καθολικού περιορισμού `cumulative`**:
        ```minizinc
        include "globals.mzn"; // (ή "cumulative.mzn")

        constraint cumulative(
             start,   // Πίνακας χρόνων έναρξης όλων των εργασιών
             duration, // Πίνακας διαρκειών όλων των εργασιών
             resource, // Πίνακας απαιτήσεων σε πόρο για κάθε εργασία
             limit     // Η συνολική χωρητικότητα του πόρου (σταθερά int)
        );
        ```
    *   Ο `cumulative` διασφαλίζει ότι σε κάθε χρονική στιγμή `t`, το άθροισμα των `resource[i]` για όλες τις ενεργές εργασίες `i` (δηλ. `start[i] <= t < end[i]`) δεν ξεπερνά το `limit`. Εφαρμόζει επίσης ισχυρές τεχνικές διάδοσης (Timetables, Edge Finding for cumulative).

7.  **Μοντελοποίηση Στόχου (π.χ., Makespan):**
    *   `var int: makespan;`
    *   `constraint makespan = max(end);` // `max` σε πίνακα μεταβλητών
    *   `solve minimize makespan;`

---

## **Ενότητα 6: Προχωρημένες Τεχνικές Διάδοσης για Scheduling**

*   (Εννοιολογική αναφορά - όχι λεπτομερής ανάλυση αλγορίθμων)
*   **Reified Disjunction:** Αν μια συνθήκη σε μια διάζευξη αποδειχθεί ψευδής, επιβάλλεται η άλλη.
*   **Constructive Disjunction:** Εξετάζει κάθε όρο της διάζευξης ξεχωριστά, κάνει τη διάδοση που συνεπάγεται, και το τελικό πεδίο είναι η *ένωση* των πεδίων που προκύπτουν από κάθε όρο. Πιο ισχυρό από reified.
*   **Edge Finding:** Κλασική και ισχυρή τεχνική για `disjunctive` και `cumulative`. Προσπαθεί να ανιχνεύσει αν ένα σύνολο εργασιών `Ω` *πρέπει* να εκτελεστεί πριν (ή μετά) από μια συγκεκριμένη εργασία `Aᵢ`. Αν `est(Ω) + duration(Ω) + duration(Aᵢ) > let(Ω U {Aᵢ})`, τότε η `Aᵢ` πρέπει να είναι *μετά* το `Ω`. Αυτό επιτρέπει την ενημέρωση του `est(Aᵢ)`. (Αντίστοιχος κανόνας για `Aᵢ` πριν το `Ω`).
*   **Timetables:** (Κυρίως για `cumulative`). Διατηρεί ένα "προφίλ" της χρήσης του πόρου στον χρόνο, βασισμένο στα *υποχρεωτικά τμήματα (compulsory parts)* των εργασιών. Ένα compulsory part μιας εργασίας `Aᵢ` είναι το χρονικό διάστημα `[let(Aᵢ) - dᵢ, est(Aᵢ) + dᵢ]` στο οποίο η εργασία *σίγουρα* πρέπει να εκτελείται, αν `let(Aᵢ) < est(Aᵢ) + dᵢ`. Το προφίλ δείχνει πόσος πόρος είναι *σίγουρα* δεσμευμένος σε κάθε χρονική στιγμή. Αν μια νέα εργασία `Aⱼ` δεν "χωράει" στο υπόλοιπο του πόρου κατά τη διάρκεια του δικού της compulsory part, το πεδίο της μπορεί να μειωθεί.
*   **Sweep Algorithm:** Διατρέχει τα "σημαντικά" χρονικά σημεία (events) και ενημερώνει δυναμικά τα `est` και `let` των εργασιών.

---

## **Συμπεράσματα:**

*   Ο χρονοπρογραμματισμός είναι ένα σημαντικό και πολύπλοκο πεδίο με πολλές εφαρμογές.
*   Το Constraint Programming παρέχει ένα φυσικό και εκφραστικό πλαίσιο για τη μοντελοποίηση προβλημάτων χρονοπρογραμματισμού.
*   Η αναπαράσταση χρόνου, εργασιών, πόρων και περιορισμών (ειδικά προτεραιότητας και πόρων) είναι κρίσιμη.
*   Οι καθολικοί περιορισμοί `disjunctive` και `cumulative` είναι απαραίτητοι για την αποτελεσματική επίλυση, καθώς ενσωματώνουν ισχυρές τεχνικές διάδοσης που εκμεταλλεύονται τη δομή του προβλήματος.
*   Η επιλογή της σωστής συνάρτησης βελτιστοποίησης εξαρτάται από τους στόχους του συγκεκριμένου προβλήματος.
