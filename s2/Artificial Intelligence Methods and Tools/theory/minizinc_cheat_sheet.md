# **MiniZinc Cheat Sheet: Μέθοδοι & Εργαλεία Τεχνητής Νοημοσύνης**

**1. Τι Είναι το MiniZinc;**
*   **Δηλωτική γλώσσα μοντελοποίησης:** Περιγράφουμε το *τι* θέλουμε να επιλυθεί (το πρόβλημα) όχι το *πώς* (η διαδικασία επίλυσης).
*   Χρησιμοποιείται για Constraint Programming (CP), αλλά και για SAT/MIP.
*   Ένα μοντέλο αποτελείται από **δηλώσεις (items)**: μεταβλητές, παράμετροι, περιορισμοί, στόχος επίλυσης, έξοδος. Η σειρά των δηλώσεων *δεν* έχει σημασία.

**2. Βασική Σύνταξη & Δομή**
*   Κάθε δήλωση τελειώνει με **`;`**.
*   **Σχόλια:** `%` για μονή γραμμή, `/* ... */` για πολλαπλές γραμμές.

**3. Τύποι Δεδομένων (Types)**
*   **Βασικοί:**
    *   `int`: Ακέραιοι. Μπορεί να οριστεί εύρος `l..u`.
    *   `float`: Πραγματικοί αριθμοί.
    *   `bool`: Λογικές τιμές (`true`, `false`).
    *   `string`: Αλφαριθμητικά (κυρίως για έξοδο).
*   **Σύνολα:** `set of <Type>`. Π.χ. `set of int: numbers = {1, 3, 5};` ή `set of int: range_numbers = 1..10;`.
*   **Απαριθμητοί (Enum):** `enum <Name> = {item1, item2, ...};`. Συμβολικά ονόματα για διακριτές τιμές. Π.χ. `enum DAY = {mon, tue, wed, thu, fri, sat, sun};`.
    *   Συναρτήσεις σε Enum: `enum_next`, `enum_prev`, `to_enum`.
*   **Πίνακες (Arrays):** `array[<IndexSet>] of <Type>`. <IndexSet> μπορεί να είναι εύρος (`1..n`), σύνολο ακεραίων, ή όνομα Enum. <Type> μπορεί να είναι οποιοσδήποτε τύπος *εκτός* από array.
    *   Πολλαπλές διαστάσεις: `array[<Set1>, <Set2>, ...] of <Type>`.
    *   Αρχικοποίηση: Λίστες `[...]` (1D), `[|...|...|]` (2D).

**4. Μεταβλητές (Variables)**
*   **Παράμετροι (Parameters):** Δηλώνονται με `par`. Είναι τιμές εισόδου, σταθερές.
    *   `par <Type>: <Name>;`
    *   `par <Type>: <Name> = <Value>;` (Ανάθεση τιμής κατά τη δήλωση ή σε αρχείο δεδομένων `.dzn`). **Πρέπει να έχουν τιμή.**
*   **Μεταβλητές Απόφασης (Decision Variables):** Δηλώνονται με `var`. Είναι οι μεταβλητές που βρίσκει ο επιλύτης.
    *   `var <Type>: <Name>;`
    *   Ο τύπος ορίζει το πεδίο τιμών (domain). Π.χ., `var 1..10: x;`, `var bool: solved;`.

**5. Εκφράσεις (Expressions)**
*   **Αριθμητικές:** Πράξεις (`+`, `-`, `*`, `/`, `div`, `mod`), συναρτήσεις (`abs`, `min`, `max`, `pow`, `sin`, `cos`, κλπ.). Μετατροπές τύπων (`int2float`, `bool2int`, κλπ.).
*   **Λογικές (Boolean):**
    *   Συγκρίσεις: `=`, `!=`, `<`, `>`, `<=`, `>=`.
    *   Λογικοί Τελεστές: `/\` (AND), `\/` (OR), `->` (συνεπαγωγή), `<->` (ισοδυναμία), `not`, `xor`.

**6. Περιορισμοί (Constraints)**
*   `constraint <boolean_expression>;`
*   Όλοι οι περιορισμοί σε ένα μοντέλο θεωρούνται σε **σύζευξη (conjunction)**, δηλ. πρέπει να ικανοποιούνται *όλοι* ταυτόχρονα.

**7. Επίλυση (Solve)**
*   Ορίζει το στόχο του επιλύτη.
*   `solve satisfy;`: Βρες μια λύση που ικανοποιεί τους περιορισμούς.
*   `solve maximize <expression>;`: Βρες τη λύση που μεγιστοποιεί την έκφραση.
*   `solve minimize <expression>;`: Βρες τη λύση που ελαχιστοποιεί την έκφραση.
*   Μπορούν να προστεθούν ευρετικές (search annotations) μετά το `::`.

**8. Έξοδος (Output)**
*   `output [<list of strings>];`
*   Χρησιμοποιείται για να μορφοποιήσει την έξοδο. Αν παραλειφθεί, τυπώνονται όλες οι μεταβλητές απόφασης.
*   Ενσωμάτωση τιμών: ` "\( <expression> )" ` μέσα σε αλφαριθμητικό.
*   Συνένωση αλφαριθμητικών: `++`.
*   Ειδικοί χαρακτήρες: `\n` (νέα γραμμή), `\t` (tab).

**9. Comprehensions (Συνόλων & Πινάκων)**
*   Συμπαγής τρόπος δημιουργίας συνόλων ή πινάκων.
*   Βασική Μορφή: `{ <Expr> | <Generator> }` (Set Comp), `[ <Expr> | <Generator> ]` (Array Comp).
*   **Generator:** `<var> in <Set_or_Array>`. Π.χ. `i in 1..10`, `item in EnumName`, `x in MySet`.
*   Πολλαπλοί Generators: `[ <Expr> | <Gen1>, <Gen2>, ... ]` (λειτουργούν σαν εμφωλευμένα loops).
*   **Φιλτράρισμα:** `[ <Expr> | <Generator> where <Boolean_Expression> ]`.
*   **Συναθροιστικές Συναρτήσεις (Lists/Sets):** `sum`, `product`, `min`, `max`.
*   **Ποσοτικοδείκτες (Lists/Sets of Booleans):**
    *   `forall( [ <Boolean_Expression> | <Generator> ] )`: Ισχύει αν όλες οι εκφράσεις είναι true (σύζευξη).
    *   `exists( [ <Boolean_Expression> | <Generator> ] )`: Ισχύει αν τουλάχιστον μία έκφραση είναι true (διάζευξη).

**10. Καθολικοί Περιορισμοί (Global Constraints)**
*   Προκαθορισμένοι, σύνθετοι περιορισμοί για κοινά πρότυπα (π.χ. alldifferent, scheduling). Συχνά οδηγούν σε πιο αποτελεσματική επίλυση.
*   `include "globals.mzn";` για πρόσβαση.
*   **`element(Index, List, Value)`:** Επιβάλλει `Value = List[Index]`. Χρήσιμο για μοντελοποίηση επιλογών από πίνακες.
*   **`disjunctive(StartTimes, Durations)`:** Για χρονοπρογραμματισμό σε μοναδικό πόρο. Επιβάλλει καμία επικάλυψη εργασιών.
*   **`cumulative(StartTimes, Durations, Resources, Capacity)`:** Για χρονοπρογραμματισμό σε πόρο με χωρητικότητα. Επιβάλλει το άθροισμα των απαιτούμενων `Resources` ανά χρονική στιγμή να μην ξεπερνά την `Capacity`.
*   **`regular(sequence, transitions, start_state, final_states)`:** Επιβάλλει μια ακολουθία μεταβλητών να είναι αποδεκτή από έναν πεπερασμένο αυτόματο (DFA).
    *   `transitions`: `array[State, Val] of opt State` (opt για μη έγκυρες μεταβάσεις -> trap state).
*   **`global_cardinality(list, values, counts)`:** Κάθε τιμή `values[i]` εμφανίζεται ακριβώς `counts[i]` φορές στη `list`.

**11. Ευρετικές Αναζήτησης (Search Annotations)**
*   Ελέγχουν τη διαδικασία αναζήτησης λύσης. Συνήθως ορίζονται μετά το `solve ::`.
*   Σύνταξη: `<type>_search(<variables>, <variable_choice>, <value_choice>)`.
*   **`<type>_search`:** `int_search`, `bool_search`, `set_search`.
*   **`<variable_choice>` (Ποια μεταβλητή να επιλέξω για branching):**
    *   `input_order`: Σειρά δήλωσης.
    *   `first_fail`: Μεταβλητή με το μικρότερο πεδίο (domain).
    *   `anti_first_fail`: Μεταβλητή με το μεγαλύτερο πεδίο.
    *   `largest`/`smallest`: Μεταβλητή με τη μεγαλύτερη/μικρότερη τρέχουσα τιμή.
    *   `most_constrained`: Μεταβλητή με τους περισσότερους περιορισμούς.
    *   `dom_w_deg`: Συνδυάζει μέγεθος πεδίου και βαθμό (πόσες φορές εμφανίζεται σε περιορισμούς που οδήγησαν σε αποτυχία).
    *   `occurrence`: Μεταβλητή που εμφανίζεται συχνότερα σε περιορισμούς.
*   **`<value_choice>` (Ποια τιμή να δοκιμάσω πρώτα για τη μεταβλητή):**
    *   `indomain`: Δοκιμάζει τις τιμές του πεδίου με τη σειρά.
    *   `indomain_min`/`max`/`median`/`middle`/`random`: Επιλέγει τη μικρότερη/μεγαλύτερη/διάμεσο/μεσαία/τυχαία τιμή.
    *   `indomain_interval`/`split`/`reverse_split`/`split_random`: Διαιρεί το πεδίο και εξερευνά τη μία πλευρά.
    *   `outdomain_min`/`max`/`random`/`median`: Αποκλείει τη μικρότερη/μεγαλύτερη/τυχαία/μεσαία τιμή.

---

**Συμβουλή για Εξετάσεις:**
*   Μην αποστηθίσετε, **κατανοήστε** τις βασικές έννοιες (δηλωτικός προγραμματισμός, var/par, περιορισμοί ως λογικές εκφράσεις).
*   Εξασκηθείτε στη γραφή απλών μοντέλων και στην ερμηνεία υπαρχόντων.
*   Δώστε προσοχή στις λεπτομέρειες σύνταξης (`;`, `:`, `::`, `..`, `{}` vs `[]`, `/\` vs `\/`).
*   Να ξέρετε πότε να χρησιμοποιήσετε τους βασικούς Global Constraints.

