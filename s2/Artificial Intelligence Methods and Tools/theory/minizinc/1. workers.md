# **Κατανομή Εργασιών σε Εργάτες (Task Assignment)**

**Σενάριο:**
Έχετε μια ομάδα από διαθέσιμους εργάτες και ένα σύνολο εργασιών που πρέπει να ολοκληρωθούν. Κάθε εργάτης έχει μια συγκεκριμένη μέγιστη ικανότητα (χωρητικότητα) σε μονάδες προσπάθειας ανά χρονική περίοδο. Κάθε εργασία απαιτεί μια συγκεκριμένη ποσότητα προσπάθειας για να ολοκληρωθεί. Μπορείτε να αναθέσετε πολλές εργασίες στον ίδιο εργάτη, αρκεί η συνολική προσπάθεια των εργασιών που του έχουν ανατεθεί να μην υπερβαίνει την ικανότητά του.
Η ανάθεση εργασιών έχει δύο είδη κόστους:
1.  **Κόστος Ενεργοποίησης Εργάτη:** Κάθε εργάτης που αναλαμβάνει τουλάχιστον μία εργασία έχει ένα σταθερό κόστος ενεργοποίησης (π.χ., κόστος προετοιμασίας, εφοδιασμός). Εργάτες στους οποίους δεν ανατίθεται καμία εργασία δεν έχουν αυτό το κόστος.
2.  **Κόστος Εκτέλεσης Εργασίας:** Η εκτέλεση κάθε εργασίας έχει ένα κόστος που εξαρτάται από τον συγκεκριμένο εργάτη στον οποίο ανατίθεται. Αυτό μπορεί να οφείλεται σε διαφορετικούς μισθούς, αποδοτικότητα, ή άλλους παράγοντες.

Στόχος σας είναι να αναθέσετε όλες τις εργασίες στους διαθέσιμους εργάτες έτσι ώστε να ικανοποιούνται όλοι οι περιορισμοί και το **συνολικό κόστος** (άθροισμα κόστους ενεργοποίησης ενεργών εργατών και κόστους εκτέλεσης όλων των εργασιών) να είναι **ελάχιστο**.

**Δεδομένα Εισόδου:**

*   Ο αριθμός των διαθέσιμων εργατών: `num_workers`.
*   Ο αριθμός των εργασιών προς ολοκλήρωση: `num_tasks`.
*   Η ικανότητα του κάθε εργάτη (μονάδες προσπάθειας): Ένας πίνακας `worker_capacity`, δεικτοδοτημένος από τους εργάτες.
*   Το κόστος ενεργοποίησης του κάθε εργάτη: Ένας πίνακας `worker_activation_cost`, δεικτοδοτημένος από τους εργάτες.
*   Η απαιτούμενη προσπάθεια για κάθε εργασία: Ένας πίνακας `task_requirement`, δεικτοδοτημένος από τις εργασίες.
*   Το κόστος εκτέλεσης κάθε εργασίας από κάθε εργάτη: Ένας πίνακας δύο διαστάσεων `task_execution_cost`, όπου `task_execution_cost[i, j]` είναι το κόστος εκτέλεσης της εργασίας `i` από τον εργάτη `j`.

**Περιορισμοί:**

1.  **Πλήρης Ανάθεση:** Κάθε εργασία πρέπει να ανατεθεί σε *ακριβώς έναν* εργάτη.
2.  **Περιορισμός Ικανότητας:** Για κάθε εργάτη, το άθροισμα της απαιτούμενης προσπάθειας όλων των εργασιών που του έχουν ανατεθεί δεν πρέπει να υπερβαίνει τη μέγιστη ικανότητά του.

**Στόχος Βελτιστοποίησης:**
Ελαχιστοποιήστε το συνολικό κόστος, το οποίο είναι το άθροισμα του κόστους ενεργοποίησης για όλους τους εργάτες που έχουν αναλάβει έστω και μία εργασία, και του κόστους εκτέλεσης για όλες τις εργασίες (βασισμένο στον εργάτη που ανατέθηκε η καθεμία).

**Ζητούμενα:**

Α) Να μοντελοποιήσετε το παραπάνω πρόβλημα στη γλώσσα προγραμματισμού περιορισμών MiniZinc, ορίζοντας κατάλληλα:
*   τις παραμέτρους (δεδομένα εισόδου).
*   τις μεταβλητές απόφασης (ποιος εργάτης αναλαμβάνει κάθε εργασία).
*   τις βοηθητικές μεταβλητές που χρειάζονται για τον υπολογισμό των περιορισμών και του κόστους.
*   τους περιορισμούς (μεταφράζοντας τους 2 κανόνες).
*   την αντικειμενική συνάρτηση (στόχος βελτιστοποίησης).
*   κατάλληλη έξοδο (`output`) για την εμφάνιση της λύσης.
Χρησιμοποιήστε τους κατάλληλους καθολικούς περιορισμούς (global constraints) όπου ενδείκνυται (π.χ., `sum`, `forall`, `exists`).

Β) (Προαιρετικό) Για συγκεκριμένα δεδομένα εισόδου (π.χ., ορίστε τιμές για τους πίνακες, παρόμοιο με την πρώτη άσκηση), εκτελέστε το μοντέλο σας και αναφέρετε την βέλτιστη ανάθεση εργασιών (π.χ., Εργασία 1 στον Εργάτη X, Εργασία 2 στον Εργάτη Y, κλπ.) και το ελάχιστο συνολικό κόστος.

---
---

**Λύση σε MiniZinc και Ανάλυση:**

Ακολουθεί ένας κώδικας MiniZinc που μοντελοποιεί το πρόβλημα της Κατανομής Εργασιών σε Εργάτες. Περιλαμβάνει παραδείγματα δεδομένων για 4 εργάτες και 6 εργασίες, όπως στην πρώτη άσκηση για λόγους αναλογίας.

```minizinc
% Include the globals file for constraints like sum, forall, exists
include "globals.mzn";

% --- Parameters (Input Data) ---

% Number of available workers
int: num_workers = 4;
set of int: WORKERS = 1..num_workers;

% Number of tasks to complete (one task per original client/service)
int: num_tasks = 6;
set of int: TASKS = 1..num_tasks;

% Capacity of each worker
array[WORKERS] of int: worker_capacity = [100, 40, 60, 60]; % Example values

% Activation cost for each worker (if they are assigned at least one task)
array[WORKERS] of int: worker_activation_cost = [860, 350, 440, 580]; % Example values

% Effort required for each task
array[TASKS] of int: task_requirement = [12, 17, 5, 13, 20, 25]; % Example values (ClientDemands analogy)

% Cost of executing task i by worker j
% Rows are tasks, columns are workers
array[TASKS, WORKERS] of int: task_execution_cost = [| 
  127, 66, 44, 55 | % Task 1 costs for each worker
  53, 89, 68, 46 |  % Task 2 costs
  117, 40, 18, 61 | % Task 3 costs
  20, 68, 44, 78 |  % Task 4 costs
  42, 89, 65, 78 |  % Task 5 costs
  57, 55, 49, 31   % Task 6 costs
|]; % Example values (NetworkingCost analogy, but this is total cost, not per unit)

% --- Decision Variables ---

% For each task, which worker is it assigned to?
% task_assigned_to[i] is the worker assigned to task i
array[TASKS] of var WORKERS: task_assigned_to;

% Is worker j active (assigned at least one task)?
array[WORKERS] of var bool: worker_active;

% Total requirement assigned to each worker
array[WORKERS] of var int: worker_total_requirement;

% --- Constraints ---

% Constraint 1: Each task is assigned to exactly one worker.
% This is implicitly handled by the declaration: array[TASKS] of var WORKERS: task_assigned_to;
% MiniZinc ensures each element of this array takes exactly one value from the domain WORKERS.

% Define which workers are active
constraint forall(j in WORKERS)(
    worker_active[j] <-> exists(i in TASKS)(task_assigned_to[i] == j)
);

% Calculate the total requirement for each worker
constraint forall(j in WORKERS)(
    worker_total_requirement[j] = sum(i in TASKS where task_assigned_to[i] == j)(task_requirement[i])
);

% Constraint 2: Capacity constraint for each worker
constraint forall(j in WORKERS)(
    worker_total_requirement[j] <= worker_capacity[j]
);

% Calculate the total activation cost
var int: total_activation_cost = sum(j in WORKERS)(bool2int(worker_active[j]) * worker_activation_cost[j]);

% Calculate the total execution cost for all tasks
var int: total_execution_cost = sum(i in TASKS)(task_execution_cost[i, task_assigned_to[i]]);

% Calculate the total cost
var int: total_cost = total_activation_cost + total_execution_cost;

% --- Solve ---

% Minimize the total cost
solve minimize total_cost;

% --- Output ---

% Show the assignment and the total cost
output [
  "Task assignment: ", show(task_assigned_to), ";\n",
  "Total cost = ", show(total_cost), ";\n"
];

```

**Εξήγηση Κώδικα και Βήματα Επίλυσης:**

Αυτός ο κώδικας MiniZinc μοντελοποιεί το πρόβλημα κατανομής εργασιών σε εργάτες ως ένα πρόβλημα βελτιστοποίησης περιορισμών.

1.  **`include "globals.mzn";`**: Εισάγει την τυπική βιβλιοθήκη του MiniZinc. Είναι απαραίτητη για τη χρήση συναρτήσεων όπως `sum`, `forall`, `exists`, `bool2int`, οι οποίες χρησιμοποιούνται στους περιορισμούς και στον υπολογισμό του κόστους.

2.  **Δήλωση Παραμέτρων (`% --- Parameters ---`)**:
    *   `int: num_workers;`, `set of int: WORKERS = 1..num_workers;`: Ορίζουν τον αριθμό των εργατών και ένα σύνολο δεικτών (1, 2, ...) για αυτούς. **Γιατί:** Αυτά είναι τα βασικά μεγέθη του προβλήματος και χρησιμοποιούνται για τις διαστάσεις των πινάκων και τη δεικτοδότηση.
    *   `int: num_tasks;`, `set of int: TASKS = 1..num_tasks;`: Ομοίως, ορίζουν τον αριθμό των εργασιών και ένα σύνολο δεικτών για αυτές. **Γιατί:** Χρησιμοποιούνται για τις διαστάσεις των πινάκων και τη δεικτοδότηση.
    *   `array[WORKERS] of int: worker_capacity;`: Ορίζει έναν πίνακα που αποθηκεύει τη μέγιστη ικανότητα κάθε εργάτη. **Γιατί:** Αυτά είναι σταθερά δεδομένα εισόδου, απαραίτητα για τον περιορισμό ικανότητας.
    *   `array[WORKERS] of int: worker_activation_cost;`: Ορίζει έναν πίνακα με το σταθερό κόστος ενεργοποίησης για κάθε εργάτη. **Γιατί:** Σταθερά δεδομένα εισόδου, απαραίτητα για τον υπολογισμό του συνολικού κόστους.
    *   `array[TASKS] of int: task_requirement;`: Ορίζει έναν πίνακα με την απαιτούμενη προσπάθεια για κάθε εργασία. **Γιατί:** Σταθερά δεδομένα εισόδου, απαραίτητα για τον περιορισμό ικανότητας και αναλογικό με το ClientDemands.
    *   `array[TASKS, WORKERS] of int: task_execution_cost;`: Ορίζει έναν πίνακα δύο διαστάσεων όπου `task_execution_cost[i, j]` είναι το κόστος εκτέλεσης της εργασίας `i` από τον εργάτη `j`. **Γιατί:** Σταθερά δεδομένα εισόδου, απαραίτητα για τον υπολογισμό του συνολικού κόστους εκτέλεσης εργασιών. Αναλογικό με το NetworkingCost, αλλά εδώ είναι το *συνολικό* κόστος ανάθεσης, όχι ανά μονάδα απαίτησης.

3.  **Δηλώσεις Μεταβλητών Απόφασης (`% --- Decision Variables ---`)**:
    *   `array[TASKS] of var WORKERS: task_assigned_to;`: Αυτός είναι ο κύριος πίνακας μεταβλητών απόφασης. Για κάθε εργασία `i` στο σύνολο `TASKS`, η μεταβλητή `task_assigned_to[i]` θα πάρει ως τιμή έναν εργάτη από το σύνολο `WORKERS`. **Γιατί:** Αυτό ακριβώς θέλουμε να αποφασίσει ο επιλύτης: ποιος εργάτης θα αναλάβει την κάθε εργασία. Η δήλωση εξασφαλίζει αυτόματα τον Περιορισμό 1 (Πλήρης Ανάθεση).
    *   `array[WORKERS] of var bool: worker_active;`: Ένας πίνακας μεταβλητών απόφασης τύπου boolean. `worker_active[j]` είναι `true` αν ο εργάτης `j` αναλάβει έστω και μία εργασία, αλλιώς `false`. **Γιατί:** Χρησιμοποιείται για τον υπολογισμό του κόστους ενεργοποίησης των εργατών. Αν και είναι `var bool`, η τιμή του *καθορίζεται* από τις τιμές του `task_assigned_to`.
    *   `array[WORKERS] of var int: worker_total_requirement;`: Ένας πίνακας μεταβλητών απόφασης τύπου ακέραιου. `worker_total_requirement[j]` θα πάρει την τιμή του συνολικού αθροίσματος προσπάθειας των εργασιών που έχουν ανατεθεί στον εργάτη `j`. **Γιατί:** Χρησιμοποιείται για τον Περιορισμό 2 (Περιορισμός Ικανότητας). Αν και είναι `var int`, η τιμή του *καθορίζεται* από τις τιμές του `task_assigned_to` και τις παραμέτρους `task_requirement`.

4.  **Περιορισμοί (`% --- Constraints ---`)**:
    *   `constraint forall(j in WORKERS)( worker_active[j] <-> exists(i in TASKS)(task_assigned_to[i] == j) );`:
        *   `forall(j in WORKERS)(...)`: Αυτός ο περιορισμός ισχύει για κάθε εργάτη `j`.
        *   `worker_active[j] <-> ...`: Η μεταβλητή `worker_active[j]` είναι αληθής (true) αν και μόνο αν ισχύει η συνθήκη στα δεξιά του `<->`.
        *   `exists(i in TASKS)(task_assigned_to[i] == j)`: Αυτή η συνθήκη είναι αληθής αν *υπάρχει* τουλάχιστον μία εργασία `i` στο σύνολο `TASKS` τέτοια ώστε η μεταβλητή `task_assigned_to[i]` (ο εργάτης στον οποίο ανατέθηκε η εργασία i) να είναι ίση με τον συγκεκριμένο εργάτη `j`.
        *   **Γιατί το κάνει:** Ορίζει ακριβώς πότε ένας εργάτης θεωρείται "ενεργός" (όταν του έχει ανατεθεί έστω και μία εργασία), κάτι που είναι απαραίτητο για τον υπολογισμό του κόστους ενεργοποίησης.
    *   `constraint forall(j in WORKERS)( worker_total_requirement[j] = sum(i in TASKS where task_assigned_to[i] == j)(task_requirement[i]) );`:
        *   `forall(j in WORKERS)(...)`: Αυτός ο περιορισμός ισχύει για κάθε εργάτη `j`.
        *   `worker_total_requirement[j] = sum(...)`: Η μεταβλητή `worker_total_requirement[j]` ορίζεται ίση με το άθροισμα...
        *   `sum(i in TASKS where task_assigned_to[i] == j)(task_requirement[i])`: ...όλων των τιμών `task_requirement[i]` (απαιτούμενη προσπάθεια εργασίας i) για κάθε εργασία `i` στο σύνολο `TASKS` *για την οποία* (`where`) ο εργάτης `j` έχει ανατεθεί (`task_assigned_to[i] == j`).
        *   **Γιατί το κάνει:** Υπολογίζει τη συνολική προσπάθεια που ανατίθεται σε κάθε εργάτη, κάτι που είναι απαραίτητο για τον Περιορισμό 2.
    *   `constraint forall(j in WORKERS)( worker_total_requirement[j] <= worker_capacity[j] );`:
        *   `forall(j in WORKERS)(...)`: Αυτός ο περιορισμός ισχύει για κάθε εργάτη `j`.
        *   `worker_total_requirement[j] <= worker_capacity[j]`: Η συνολική προσπάθεια που ανατέθηκε στον εργάτη `j` πρέπει να είναι μικρότερη ή ίση με την ικανότητα του εργάτη `j`.
        *   **Γιατί το κάνει:** Αυτός είναι ο Περιορισμός 2 του προβλήματος. Διασφαλίζει ότι κανένας εργάτης δεν επιβαρύνεται με περισσότερη προσπάθεια από όση μπορεί να διαχειριστεί.

5.  **Υπολογισμός Κόστους (Βοηθητικές Μεταβλητές και Εκφράσεις)**:
    *   `var int: total_activation_cost = sum(j in WORKERS)(bool2int(worker_active[j]) * worker_activation_cost[j]);`:
        *   `sum(j in WORKERS)(...)`: Αθροίζει για κάθε εργάτη `j`.
        *   `bool2int(worker_active[j])`: Μετατρέπει τη boolean τιμή `worker_active[j]` σε ακέραιο (1 αν true, 0 αν false).
        *   `... * worker_activation_cost[j]`: Πολλαπλασιάζει την ικανότητα του εργάτη (0 ή 1) με το κόστος ενεργοποίησής του. Το αποτέλεσμα είναι το κόστος ενεργοποίησης μόνο αν ο εργάτης είναι ενεργός.
        *   **Γιατί το κάνει:** Υπολογίζει το συνολικό κόστος ενεργοποίησης αθροίζοντας τα κόστη μόνο για τους ενεργούς εργάτες.
    *   `var int: total_execution_cost = sum(i in TASKS)(task_execution_cost[i, task_assigned_to[i]]);`:
        *   `sum(i in TASKS)(...)`: Αθροίζει για κάθε εργασία `i`.
        *   `task_execution_cost[i, task_assigned_to[i]]`: Προσπελαύνει τον πίνακα κόστους εκτέλεσης. Η πρώτη διάσταση είναι η εργασία `i`, και η δεύτερη διάσταση είναι ο δείκτης του εργάτη στον οποίο ανατέθηκε η εργασία `i` (η τιμή της μεταβλητής απόφασης `task_assigned_to[i]`). Έτσι βρίσκουμε το κόστος εκτέλεσης της συγκεκριμένης εργασίας `i` από τον συγκεκριμένο εργάτη στον οποίο ανατέθηκε.
        *   **Γιατί το κάνει:** Υπολογίζει το συνολικό κόστος εκτέλεσης αθροίζοντας το κόστος εκτέλεσης κάθε εργασίας με βάση τον εργάτη που της ανατέθηκε.
    *   `var int: total_cost = total_activation_cost + total_execution_cost;`:
        *   **Γιατί το κάνει:** Ορίζει τη συνολική μεταβλητή κόστους ως το άθροισμα των δύο επιμέρους κόστων, όπως ζητά η εκφώνηση. Αυτή είναι η μεταβλητή που θα ελαχιστοποιηθεί.

6.  **Στόχος Επίλυσης (`% --- Solve ---`)**:
    *   `solve minimize total_cost;`: Δίνει εντολή στον επιλύτη να βρει μια ανάθεση εργασιών (`task_assigned_to`) που ικανοποιεί όλους τους περιορισμούς (οι μεταβλητές `worker_active`, `worker_total_requirement` και `total_cost` θα λάβουν τις αντίστοιχες τιμές τους βάσει αυτής της ανάθεσης) και ταυτόχρονα ελαχιστοποιεί την τιμή της μεταβλητής `total_cost`. **Γιατί:** Αυτός είναι ο στόχος βελτιστοποίησης της άσκησης.

7.  **Έξοδος (`% --- Output ---`)**:
    *   `output [...]`: Καθορίζει τη μορφή της εξόδου.
    *   `"Task assignment: ", show(task_assigned_to), ";\n"`: Τυπώνει το κείμενο "Task assignment: " ακολουθούμενο από την τιμή του πίνακα `task_assigned_to` (η ανάθεση εργασιών σε εργάτες) και μια νέα γραμμή.
    *   `"Total cost = ", show(total_cost), ";\n"`: Τυπώνει το κείμενο "Total cost = " ακολουθούμενο από την ελάχιστη τιμή που βρέθηκε για τη μεταβλητή `total_cost` και μια νέα γραμμή.
    *   **Γιατί το κάνει:** Παρουσιάζει την κύρια πληροφορία της βέλτιστης λύσης στον χρήστη: πώς έγινε η ανάθεση και ποιο είναι το ελάχιστο κόστος που επιτεύχθηκε.

**Συνοπτικά τα Βήματα Επίλυσης που υλοποιεί ο κώδικας:**

Ο κώδικας ζητά από τον επιλύτη MiniZinc να βρει μια αντιστοίχιση κάθε εργασίας σε έναν εργάτη (`task_assigned_to`), έτσι ώστε:

1.  Η συνολική προσπάθεια των εργασιών που ανατίθενται σε κάθε εργάτη να μην υπερβαίνει την ικανότητά του.
2.  Ανάμεσα σε όλες τις επιτρεπτές αντιστοιχίσεις, να βρει εκείνη που ελαχιστοποιεί το συνολικό κόστος, το οποίο υπολογίζεται ως το άθροισμα του σταθερού κόστους για κάθε εργάτη που χρησιμοποιήθηκε (έστω και για μία εργασία) και του μεταβλητού κόστους εκτέλεσης κάθε εργασίας (που εξαρτάται από τον εργάτη στον οποίο ανατέθηκε).
3.  Τέλος, να εμφανίσει αυτή τη βέλτιστη αντιστοίχιση και το ελάχιστο κόστος.
