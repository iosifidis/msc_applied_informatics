# **Εκφώνηση Άσκησης: Χρονοπρογραμματισμός Πυρηνικών Αντιδραστήρων (Constraint Programming με MiniZinc)**

**Σενάριο:**
Είστε υπεύθυνος/η για τον βέλτιστο χρονοπρογραμματισμό της λειτουργίας μιας σειράς πυρηνικών αντιδραστήρων σε ένα εργοστάσιο παραγωγής ενέργειας. Κάθε αντιδραστήρας έχει μια μέγιστη ισχύ παραγωγής και πρέπει να παράγει μια συγκεκριμένη συνολική ποσότητα ενέργειας. Το εργοστάσιο έχει μια μέγιστη συνολική παραγωγή ισχύος που δεν μπορεί να ξεπεραστεί ανά πάσα στιγμή. Επιπλέον, για λόγους ασφάλειας ή συντήρησης, ορισμένα ζεύγη αντιδραστήρων δεν επιτρέπεται να λειτουργούν ταυτόχρονα. Σκοπός σας είναι να προγραμματίσετε τη λειτουργία όλων των αντιδραστήρων ώστε να παράξουν την απαιτούμενη ενέργεια, να τηρηθούν οι περιορισμοί ισχύος και ασφάλειας, και να ελαχιστοποιηθεί ο συνολικός χρόνος λειτουργίας μέχρι να παραχθεί η συνολική απαιτούμενη ενέργεια από όλους.

**Δεδομένα Εισόδου:**

*   Ο αριθμός των αντιδραστήρων (`no_plants`).
*   Για κάθε αντιδραστήρα `i` (από 1 έως `no_plants`):
    *   Η μέγιστη ισχύς παραγωγής του (σε μονάδες ισχύος ανά μονάδα χρόνου) (`supply[i]`).
    *   Η συνολική ποσότητα ενέργειας που πρέπει να παράγει (`needs[i]`).
*   Το εργοστάσιο έχει μια **συνολική μέγιστη ισχύ 120 μονάδων**. Αν πολλοί αντιδραστήρες λειτουργούν ταυτόχρονα, το άθροισμα των ισχύων παραγωγής τους *όλων* των αντιδραστήρων που λειτουργούν τη συγκεκριμένη στιγμή δεν μπορεί να ξεπερνά τις 120 μονάδες.
*   Υπάρχουν ορισμένα ζεύγη αντιδραστήρων (`not_sim`) που, για λόγους ασφάλειας ή συντήρησης, **δεν επιτρέπεται να λειτουργούν ταυτόχρονα**, ούτε καν για μία στιγμή. Όταν η λειτουργία του ενός αντιδραστήρα τελειώσει, μπορεί να αρχίσει η λειτουργία του άλλου. Ο αριθμός αυτών των ζευγών δίνεται από την παράμετρο `problems`.

**Υπολογισμός Διάρκειας Λειτουργίας:**
Η διάρκεια λειτουργίας ενός αντιδραστήρα `i` στην μέγιστη ισχύ του υπολογίζεται διαιρώντας τη συνολική ενέργεια που πρέπει να παράγει (`needs[i]`) με τη μέγιστη ισχύ παραγωγής του ανά μονάδα χρόνου (`supply[i]`). Επειδή η παραγωγή ενέργειας πρέπει να ολοκληρωθεί πλήρως (ή για λόγους απλοποίησης του μοντέλου), η διάρκεια πρέπει να είναι ο **ακέραιος αριθμός μονάδων χρόνου που προκύπτει από την προς τα πάνω στρογγυλοποίηση** αυτής της διαίρεσης. Θεωρούμε ότι ο αντιδραστήρας λειτουργεί στη μέγιστη ισχύ του για όλη αυτή τη διάρκεια.

**Περιορισμοί (Κανόνες Λειτουργίας):**
Ο χρονοπρογραμματισμός λειτουργίας όλων των αντιδραστήρων πρέπει να σέβεται τους εξής κανόνες:

1.  **Πλήρης Παραγωγή:** Κάθε αντιδραστήρας `i` πρέπει να λειτουργήσει για την υπολογισμένη διάρκεια (προς τα πάνω στρογγυλοποιημένη ανάγκη ενέργειας / μέγιστη ισχύ) αδιάκοπα, ξεκινώντας από κάποια ώρα έναρξης.
2.  **Περιορισμός Συνολικής Ισχύος:** Σε οποιαδήποτε χρονική στιγμή, το άθροισμα της ισχύος παραγωγής (`supply[i]`) όλων των αντιδραστήρων που λειτουργούν τη συγκεκριμένη στιγμή δεν πρέπει να υπερβαίνει τη μέγιστη συνολική ισχύ του εργοστασίου (120 μονάδες).
3.  **Απαγόρευση Ταυτόχρονης Λειτουργίας:** Για κάθε ζεύγος αντιδραστήρων `(r1, r2)` που περιλαμβάνεται στα απαγορευμένα ζεύγη (`not_sim`), δεν πρέπει να υπάρχει χρονική επικάλυψη στη λειτουργία τους. Αυτό σημαίνει ότι είτε η λειτουργία του `r1` πρέπει να τελειώσει πριν αρχίσει η λειτουργία του `r2`, είτε η λειτουργία του `r2` πρέπει να τελειώσει πριν αρχίσει η λειτουργία του `r1`.

**Στόχος Βελτιστοποίησης:**
Βρείτε έναν χρονοπρογραμματισμό (δηλαδή, καθορίστε την ώρα έναρξης για κάθε αντιδραστήρα) ο οποίος να ικανοποιεί όλους τους παραπάνω περιορισμούς, και ταυτόχρονα να **ελαχιστοποιεί τον συνολικό χρόνο** που απαιτείται από την αρχή του προγραμματισμού (χρόνος 0) μέχρι την ολοκλήρωση της λειτουργίας του τελευταίου αντιδραστήρα.

**Ζητούμενα:**

- Να μοντελοποιήσετε το παραπάνω πρόβλημα στη γλώσσα προγραμματισμού περιορισμών MiniZinc, ορίζοντας κατάλληλα:   
    *   τις παραμέτρους (δεδομένα εισόδου).   
    *   τις μεταβλητές απόφασης (πότε αρχίζει να λειτουργεί ο κάθε αντιδραστήρας).   
    *   τους περιορισμούς (μεταφράζοντας τους 3 κανόνες λειτουργίας).   
    *   την αντικειμενική συνάρτηση (στόχος βελτιστοποίησης).   
    *    κατάλληλη έξοδο (`output`) για την εμφάνιση της λύσης.   
    Χρησιμοποιήστε τους κατάλληλους καθολικούς περιορισμούς (global constraints) όπου ενδείκνυται (π.χ., `cumulative`, `forall`).   

---

```
% Include the globals file
include "globals.mzn";

% Declare the number of plants
int: no_plants;

% Define the set of plants
set of int: PLANTS = 1..no_plants;

% Define the time frame
set of int: TIME = 0..100;

% Declare arrays for plant supply and needs
array[PLANTS] of int: supply;
array[PLANTS] of int: needs;

% Define variables for plant supply and end time
array[PLANTS] of var int: plant_supply = [supply[i] | i in PLANTS];
array[PLANTS] of var TIME: end_time = [end[i] | i in PLANTS];

% Declare the number of problems and define the not_sim array
int: problems;
array[1..problems, 1..2] of PLANTS: not_sim; 

% Declare variables for start and end times
array[PLANTS] of var TIME: start; 
array[PLANTS] of var TIME: end; 

% Declare a variable for the end of supply time
var TIME: end_of_supply; 

% Define variables for the rounded-up needs/supply ratio
array[PLANTS] of var TIME: ceil_needs_supply = [ceil(needs[i] / supply[i]) | i in PLANTS];

% Constraint to ensure end time is calculated correctly
constraint forall(i in PLANTS)(
    end[i] = start[i] + ceil(needs[i] / supply[i])
);

% Constraint to ensure cumulative water supply does not exceed total_water_supply
constraint cumulative(start, ceil_needs_supply, plant_supply, 120);

% Constraint to enforce restrictions on simultaneous supply for certain plants
constraint forall(i in 1..problems)(
    (start[not_sim[i, 1]] + ceil_needs_supply[not_sim[i, 1]] <= start[not_sim[i, 2]]) \/
    (start[not_sim[i, 2]] + ceil_needs_supply[not_sim[i, 2]] <= start[not_sim[i, 1]])
);

% Constraint to ensure end_of_supply reflects the maximum end time of all plants
constraint end_of_supply = max(end_time);


% Output the start times and end_of_supply time
output ["start = \(start);\nend_of_supply = \(end_of_supply);"];
```

Δοκιμή με plants1.dzn

```
no_plants = 5;
supply = [50,40,60,70,90];
needs = [100,80,180,280,270];

problems = 1;
not_sim = [|1,3|];

```

---

**Ανάλυση Κώδικα και Βήματα Επίλυσης:**

Ο κώδικας MiniZinc μοντελοποιεί ένα πρόβλημα χρονοπρογραμματισμού εργασιών (λειτουργία αντιδραστήρων) σε έναν πόρο (το εργοστάσιο με τη συνολική μέγιστη ισχύ) με συγκεκριμένους περιορισμούς.

1.  **`include "globals.mzn";`**: Εισάγει την τυπική βιβλιοθήκη. Απαραίτητη για `cumulative`, `forall`, `max`.

2.  **Δήλωση Παραμέτρων**:
    *   `int: no_plants;`, `set of int: PLANTS = 1..no_plants;`: Αριθμός και σύνολο αναγνωριστικών για τους αντιδραστήρες.  
    *   `set of int: TIME = 0..100;`: Ορίζει το χρονικό ορίζοντα.  
    *   `array[PLANTS] of int: supply;`: Η **μέγιστη ισχύ παραγωγής** του κάθε αντιδραστήρα. Είναι η *απαίτηση* πόρου (συνολικής ισχύος εργοστασίου) από κάθε αντιδραστήρα όταν λειτουργεί.  
    *   `array[PLANTS] of int: needs;`: Η **συνολική ενέργεια** που πρέπει να παραχθεί από κάθε αντιδραστήρα.  
    *   `int: problems;`, `array[1..problems, 1..2] of PLANTS: not_sim;`: Αριθμός και λίστα ζευγών αντιδραστήρων που δεν μπορούν να λειτουργούν ταυτόχρονα.

3.  **Δήλωση Μεταβλητών**:
    *   `array[PLANTS] of var int: plant_supply = [supply[i] | i in PLANTS];`: **Όπως και πριν, αυτή η δήλωση είναι πιθανότατα λάθος ή ασαφής.** Αν το `supply` είναι η σταθερή μέγιστη ισχύ του αντιδραστήρα, τότε αυτός ο πίνακας `plant_supply` θα έπρεπε να είναι παράμετρος (`par`) ή απλώς να χρησιμοποιείται ο πίνακας `supply` απευθείας. Στην ανάλυση του `cumulative` θα το εξηγήσουμε ως την *απαίτηση πόρου* της εργασίας (λειτουργίας αντιδραστήρα).
    *   `array[PLANTS] of var TIME: start;`: Ώρα έναρξης λειτουργίας για κάθε αντιδραστήρα. **Το κύριο ζητούμενο**.
    *   `array[PLANTS] of var TIME: end;`: Ώρα λήξης λειτουργίας για κάθε αντιδραστήρα. Υπολογίζεται από την ώρα έναρξης και τη διάρκεια.
    *   `var TIME: end_of_supply;`: Συνολικός χρόνος ολοκλήρωσης όλων των λειτουργιών. **Στόχος ελαχιστοποίησης**.
    *   `array[PLANTS] of var TIME: ceil_needs_supply = [ceil(needs[i] / supply[i]) | i in PLANTS];`: **Και εδώ, η διάρκεια είναι σταθερή.** Αυτό θα έπρεπε να είναι πίνακας παραμέτρων (`par`) ή απλώς `int`. Είναι η *διάρκεια* της εργασίας (πόσες μονάδες χρόνου πρέπει να λειτουργήσει ο αντιδραστήρας).
    *   `array[PLANTS] of var TIME: end_time = [end[i] | i in PLANTS];`: **Περιττή δήλωση**, απλώς αντίγραφο του πίνακα `end`.

4.  **Περιορισμοί**:
    *   `constraint forall(i in PLANTS)( end[i] = start[i] + ceil(needs[i] / supply[i]) );`: Καθορίζει την ώρα λήξης με βάση την ώρα έναρξης και τη διάρκεια (η οποία υπολογίζεται από τα δεδομένα εισόδου `needs[i]` και `supply[i]`).
    *   `constraint cumulative(start, ceil_needs_supply, plant_supply, 120);`:
        *   **Εξήγηση:** Ο περιορισμός `cumulative` εδώ μοντελοποιεί την απαίτηση της **συνολικής μέγιστης ισχύος του εργοστασίου**.
        *   `start`: Πότε αρχίζει να λειτουργεί ο κάθε αντιδραστήρας.
        *   `ceil_needs_supply`: Για πόση ώρα πρέπει να λειτουργήσει ο κάθε αντιδραστήρας (η διάρκεια της "εργασίας").
        *   `plant_supply`: Πόση *ισχύ* (πόρο) απαιτεί ο κάθε αντιδραστήρας όσο λειτουργεί. Αυτό αντιστοιχεί στην `supply[i]`.
        *   `120`: Η συνολική *χωρητικότητα* του πόρου (η μέγιστη ισχύς του εργοστασίου).
        *   **Γιατί το κάνει:** Επιβάλλει ότι σε κάθε χρονική στιγμή, το άθροισμα της *ισχύος* όλων των αντιδραστήρων που λειτουργούν ταυτόχρονα δεν ξεπερνά τη μέγιστη συνολική ισχύ του εργοστασίου (120).
    *   `constraint forall(i in 1..problems)( (start[not_sim[i, 1]] + ceil_needs_supply[not_sim[i, 1]] <= start[not_sim[i, 2]]) \/ (start[not_sim[i, 2]] + ceil_needs_supply[not_sim[i, 2]] <= start[not_sim[i, 1]]) );`:
        *   **Εξήγηση:** Για κάθε ζεύγος αντιδραστήρων στον πίνακα `not_sim`, επιβάλλει ότι οι χρονικές περίοδοι λειτουργίας τους δεν επικαλύπτονται.
        *   **Γιατί το κάνει:** Υλοποιεί τον περιορισμό ασφάλειας/συντήρησης που απαγορεύει τη ταυτόχρονη λειτουργία συγκεκριμένων ζευγών αντιδραστήρων (disjunctive constraint για συγκεκριμένα ζεύγη).
    *   `constraint end_of_supply = max(end_time);`: Ορίζει την `end_of_supply` ως την μέγιστη ώρα λήξης από όλους τους αντιδραστήρες.

5.  **Στόχος Επίλυσης**:
    *   `solve minimize end_of_supply;`: Βρες τον χρονοπρογραμματισμό (τιμές για τις `start`) που ελαχιστοποιεί τη μέγιστη ώρα λήξης όλων των αντιδραστήρων. **Γιατί:** Αυτός είναι ο στόχος βελτιστοποίησης: ελαχιστοποίηση του συνολικού χρόνου παραγωγής.

6.  **Έξοδος**:
    *   `output ["start = \(start);\nend_of_supply = \(end_of_supply);"];`: Τυπώνει τις ώρες έναρξης των αντιδραστήρων και τον ελάχιστο χρόνο ολοκλήρωσης.

**Συνοπτικά τα Βήματα Επίλυσης που υλοποιεί ο κώδικας (για NuclearPlants):**

Ο κώδικας ζητά από τον επιλύτη MiniZinc να βρει ώρες έναρξης λειτουργίας (`start`) για κάθε αντιδραστήρα, έτσι ώστε:

1.  Κάθε αντιδραστήρας να λειτουργήσει για τη σταθερή, υπολογισμένη διάρκεια που απαιτείται για να παραχθεί η ζητούμενη ενέργεια (`needs` / `supply`, στρογγυλοποιημένο προς τα πάνω).
2.  Σε καμία χρονική στιγμή, το άθροισμα της μέγιστης ισχύος (`supply`) των αντιδραστήρων που λειτουργούν ταυτόχρονα να μην ξεπερνά τη μέγιστη ισχύ του εργοστασίου (120).
3.  Για ορισμένα ζεύγη αντιδραστήρων, η λειτουργία του ενός να ολοκληρώνεται πριν αρχίσει η λειτουργία του άλλου.
4.  Ανάμεσα σε όλους τους χρονοπρογραμματισμούς που ικανοποιούν τους παραπάνω κανόνες, να βρει εκείνον που ελαχιστοποιεί τον συνολικό χρόνο μέχρι να τελειώσει και ο τελευταίος αντιδραστήρας. Τέλος, να τυπώσει τις ώρες έναρξης και τον ελάχιστο συνολικό χρόνο.
