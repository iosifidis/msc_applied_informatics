# **Άσκηση: Βέλτιστη Στοίβαξη Τούβλων (Constraint Programming με MiniZinc)**

**Σενάριο:**
Είστε υπεύθυνος/η για ένα παιχνίδι κατασκευών. Έχετε στη διάθεσή σας μια συλλογή από 10 μοναδικά αριθμημένα τουβλάκια (με ID από 1 έως 10). Κάθε τουβλάκι έχει συγκεκριμένο ύψος και πλάτος, όπως δίνονται στον παρακάτω πίνακα.
Ο στόχος σας είναι να κατασκευάσετε **δύο (2) ξεχωριστούς πύργους (στοίβες)**, χρησιμοποιώντας **ακριβώς τρία (3) τουβλάκια** για τον καθένα, επιλέγοντας από τα 10 διαθέσιμα, έτσι ώστε να ικανοποιούνται συγκεκριμένες συνθήκες ισορροπίας και σταθερότητας, και ταυτόχρονα να ελαχιστοποιείται το ύψος.

**Δεδομένα Εισόδου:**
Έχετε 10 διαθέσιμα τουβλάκια με τις εξής διαστάσεις:

| Τουβλάκι (ID) | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| **Ύψος** | 2 | 1 | 3 | 1 | 4 | 2 | 5 | 5 | 4 | 2 |
| **Πλάτος** | 3 | 2 | 3 | 2 | 2 | 1 | 3 | 2 | 3 | 3 |

 Κάθε πύργος πρέπει να έχει ακριβώς 3 τουβλάκια.

**Περιορισμοί (Κανόνες Κατασκευής):**
Η κατασκευή των δύο πύργων πρέπει να σέβεται τους εξής κανόνες:

1.  **Μοναδικότητα:** Κάθε τουβλάκι (από τα 10 διαθέσιμα) μπορεί να χρησιμοποιηθεί το πολύ μία φορά. Δηλαδή, τα 6 τουβλάκια που θα επιλεγούν συνολικά για τους δύο πύργους (3+3) πρέπει να είναι όλα διαφορετικά μεταξύ τους. Κανένα τουβλάκι δεν μπορεί να βρίσκεται και στους δύο πύργους ταυτόχρονα, ούτε να χρησιμοποιηθεί πάνω από μία φορά στον ίδιο πύργο.
2.  **Ισορροπία Ύψους:** Οι δύο πύργοι που θα κατασκευαστούν πρέπει να έχουν *ακριβώς το ίδιο* συνολικό ύψος. (Το συνολικό ύψος ενός πύργου είναι το άθροισμα των υψών των 3 τουβλακίων που τον αποτελούν).
3.  **Σταθερότητα:** Για να είναι σταθερός ένας πύργος, κανένα τουβλάκι δεν επιτρέπεται να είναι φαρδύτερο από το τουβλάκι που βρίσκεται ακριβώς από κάτω του. Με άλλα λόγια, το πλάτος των τουβλακίων σε κάθε πύργο πρέπει είτε να μειώνεται είτε να παραμένει σταθερό, καθώς πηγαίνουμε από τη βάση προς την κορυφή. Αυτός ο κανόνας πρέπει να ισχύει και για τους δύο πύργους.

**Στόχος Βελτιστοποίησης:**
Ανάμεσα σε όλους τους δυνατούς, έγκυρους συνδυασμούς που ικανοποιούν τους παραπάνω περιορισμούς (Μοναδικότητα, Ισορροπία Ύψους, Σταθερότητα), βρείτε τον συνδυασμό που **ελαχιστοποιεί** το (κοινό) ύψος των δύο πύργων.

**Ζητούμενα:**

- Να μοντελοποιήσετε το παραπάνω πρόβλημα στη γλώσσα προγραμματισμού περιορισμών MiniZinc, ορίζοντας κατάλληλα:
    *   τις παραμέτρους (δεδομένα εισόδου).
    *   τις μεταβλητές απόφασης (ποια τουβλάκια τοποθετούνται σε κάθε θέση κάθε πύργου).
    *   τους περιορισμούς (μεταφράζοντας τους 3 κανόνες κατασκευής).
    *   την αντικειμενική συνάρτηση (στόχος βελτιστοποίησης).
    *    κατάλληλη έξοδο (`output`) για την εμφάνιση της λύσης.
    Χρησιμοποιήστε τους κατάλληλους καθολικούς περιορισμούς (global constraints) όπου ενδείκνυται (π.χ., `all_different`, `sum`, `forall`).

**Παραδοτέο:** Ο κώδικας MiniZinc.
---
---

```
include "globals.mzn";

% Define parameters
int: num_blocks = 10;
set of int: BLOCKS = 1..num_blocks;
int: stack_blocks = 3;
set of int: STACK = 1..stack_blocks;

% Heights and widths of the blocks
array[BLOCKS] of int: height = [2,1,3,1,4,2,5,5,4,2];
array[BLOCKS] of int: width =  [3,2,3,2,2,1,3,2,3,3];

% Decision variables: which block goes into which stack
array[STACK] of var BLOCKS: stack1;
array[STACK] of var BLOCKS: stack2;

% Constraints

% Ensure each block is used only once in either stack
constraint all_different(stack1 ++ stack2);

% Ensure the total height of both stacks is the same
constraint sum(i in STACK)(height[stack1[i]]) = sum(i in STACK)(height[stack2[i]]);

% Ensure each block in stack1 has equal or greater width than the one below it
constraint forall(i in 1..(stack_blocks-1))(
    width[stack1[i]] >= width[stack1[i+1]]
);

% Ensure each block in stack2 has equal or greater width than the one below it
constraint forall(i in 1..(stack_blocks-1))(
    width[stack2[i]] >= width[stack2[i+1]]
);

% Solve the problem
solve minimize sum(i in STACK)(height[stack1[i]]) + sum(j in STACK)(height[stack2[j]]);

% Output the solution
output ["stack1 = \(stack1);\nstack2 = \(stack2);\n"];
```

Είναι ένα χαρακτηριστικό παράδειγμα μοντελοποίησης ενός προβλήματος με περιορισμούς στο MiniZinc.

**Τι κάνει ο κώδικας συνοπτικά:**

Αυτός ο κώδικας μοντελοποιεί ένα πρόβλημα στοίβαξης αντικειμένων. Σκοπός είναι να επιλέξουμε 6 (2 * 3) διαφορετικά τουβλάκια από ένα σύνολο 10 διαθέσιμων τουβλακίων και να φτιάξουμε **δύο στοίβες**, καθεμία με **3 τουβλάκια**. Οι δύο στοίβες πρέπει να έχουν την **ίδια συνολική ύψος**, κάθε στοίβα πρέπει να είναι **σταθερή** (κάθε τουβλάκι είναι ίσο ή πιο φαρδύ από αυτό που βρίσκεται ακριβώς από κάτω του), και ο τελικός στόχος είναι να **ελαχιστοποιηθεί το συνολικό ύψος** των δύο στοιβάδων (άρα και η ύψος της κάθε στοίβας αφού είναι ίσες).

**Ανάλυση Κώδικα ανά τμήμα:**

1.  **`include "globals.mzn";`**
    *   **Τι κάνει:** Αυτή η γραμμή εισάγει την τυπική βιβλιοθήκη καθολικών περιορισμών του MiniZinc.
    *   **Γιατί το κάνει:** Πολλοί χρήσιμοι και αποδοτικοί περιορισμοί (όπως `all_different`, `sum`, `forall`) είναι προκαθορισμένοι σε αυτή τη βιβλιοθήκη. Για να τους χρησιμοποιήσουμε στο μοντέλο μας, πρέπει να τους εισάγουμε.

2.  **Ορισμός Παραμέτρων (`% Define parameters`)**
    *   `int: num_blocks = 10;`: Ορίζει μια παράμετρο (`par` implicitly, since no `var`) με όνομα `num_blocks` και την τιμή 10. Αυτός είναι ο συνολικός αριθμός των διαθέσιμων τουβλακίων.
    *   `set of int: BLOCKS = 1..num_blocks;`: Ορίζει ένα σύνολο ακεραίων με όνομα `BLOCKS` που περιέχει τους αριθμούς από 1 έως `num_blocks`. Αυτό το σύνολο θα χρησιμοποιηθεί για να αναφερθούμε στα τουβλάκια (ως δείκτες ή ταυτότητες).
    *   `int: stack_blocks = 3;`: Ορίζει μια παράμετρο `stack_blocks` με τιμή 3. Αυτός είναι ο αριθμός των τουβλακίων που θα έχει *κάθε* στοίβα.
    *   `set of int: STACK = 1..stack_blocks;`: Ορίζει ένα σύνολο ακεραίων `STACK` που περιέχει τους αριθμούς από 1 έως `stack_blocks`. Αυτό το σύνολο θα χρησιμοποιηθεί για να αναφερθούμε στις *θέσεις* μέσα σε κάθε στοίβα (π.χ., θέση 1 είναι το κάτω τουβλάκι, θέση 2 το μεσαίο, θέση 3 το πάνω, με βάση τον τρόπο που είναι γραμμένοι οι περιορισμοί σταθερότητας).
    *   `array[BLOCKS] of int: height = [2,1,3,1,4,2,5,5,4,2];`: Ορίζει έναν πίνακα παραμέτρων `height`, δεικτοδοτημένο από το σύνολο `BLOCKS`. Η τιμή `height[i]` δίνει το ύψος του τουβλακίου με δείκτη `i`. Π.χ., το τουβλάκι 1 έχει ύψος 2, το τουβλάκι 2 έχει ύψος 1, κ.ο.κ.
    *   `array[BLOCKS] of int: width = [3,2,3,2,2,1,3,2,3,3];`: Ορίζει έναν πίνακα παραμέτρων `width`, παρόμοιο με τον `height`, που αποθηκεύει το πλάτος του κάθε τουβλακίου.
    *   **Γιατί το κάνει:** Οι παράμετροι δίνουν τις συγκεκριμένες πληροφορίες εισόδου για το πρόβλημα (πόσα τουβλάκια υπάρχουν, πόσα σε κάθε στοίβα, ποιες είναι οι ιδιότητές τους). Αυτές οι τιμές είναι σταθερές για μια συγκεκριμένη εκτέλεση του μοντέλου.

3.  **Δηλώσεις Μεταβλητών Απόφασης (`% Decision variables`)**
    *   `array[STACK] of var BLOCKS: stack1;`: Ορίζει έναν πίνακα μεταβλητών απόφασης (`var`) με όνομα `stack1`, δεικτοδοτημένο από το σύνολο `STACK`. Κάθε στοιχείο `stack1[i]` είναι μια μεταβλητή της οποίας η τιμή (που θα αποφασιστεί από τον επιλύτη) προέρχεται από το σύνολο `BLOCKS`. Αυτό σημαίνει ότι `stack1[1]` θα είναι ο δείκτης του τουβλακίου στη θέση 1 της στοίβας 1, `stack1[2]` ο δείκτης του τουβλακίου στη θέση 2, και `stack1[3]` ο δείκτης του τουβλακίου στη θέση 3.
    *   `array[STACK] of var BLOCKS: stack2;`: Ορίζει έναν παρόμοιο πίνακα μεταβλητών απόφασης για τη δεύτερη στοίβα.
    *   **Γιατί το κάνει:** Οι μεταβλητές απόφασης αντιπροσωπεύουν αυτό που ο επιλύτης πρέπει να βρει: ποιους συγκεκριμένους δείκτες τουβλακίων (από το 1 έως το 10) θα αναθέσει σε κάθε θέση (από το 1 έως το 3) των δύο στοιβάδων.

4.  **Περιορισμοί (`% Constraints`)**
    *   `constraint all_different(stack1 ++ stack2);`:
        *   `stack1 ++ stack2`: Ενώνει τους δύο πίνακες `stack1` και `stack2` σε μια ενιαία λίστα (συνολικά 3+3=6 στοιχεία).
        *   `all_different(...)`: Ένας καθολικός περιορισμός που επιβάλλει όλες οι τιμές στη λίστα να είναι διαφορετικές μεταξύ τους.
        *   **Γιατί το κάνει:** Αυτό διασφαλίζει ότι τα 6 τουβλάκια που επιλέγονται συνολικά για τις δύο στοίβες είναι όλα μοναδικά. Δεν μπορεί, για παράδειγμα, το ίδιο τουβλάκι (π.χ., το τουβλάκι 5) να χρησιμοποιηθεί και στη στοίβα 1 και στη στοίβα 2, ή δύο φορές στην ίδια στοίβα.
    *   `constraint sum(i in STACK)(height[stack1[i]]) = sum(i in STACK)(height[stack2[i]]);`:
        *   `sum(i in STACK)(...)`: Μια έκφραση άθροισης που υπολογίζει το άθροισμα των τιμών της εσωτερικής έκφρασης για κάθε `i` στο σύνολο `STACK` (δηλαδή, για `i`=1, 2, 3).
        *   `height[stack1[i]]`: Προσπελαύνει το ύψος του τουβλακίου που βρίσκεται στη θέση `i` της στοίβας 1. `stack1[i]` μας δίνει τον *δείκτη* του τουβλακίου, και μετά χρησιμοποιούμε αυτόν τον δείκτη στον πίνακα `height` για να βρούμε το ύψος του.
        *   **Γιατί το κάνει:** Αυτός ο περιορισμός επιβάλλει την κύρια απαίτηση του προβλήματος: το συνολικό άθροισμα των υψών των τουβλακίων στην πρώτη στοίβα να είναι ακριβώς ίσο με το συνολικό άθροισμα των υψών των τουβλακίων στη δεύτερη στοίβα.
    *   `constraint forall(i in 1..(stack_blocks-1))( width[stack1[i]] >= width[stack1[i+1]] );`:
        *   `forall(i in 1..(stack_blocks-1))(...)`: Ένας καθολικός περιορισμός που επιβάλλει την εσωτερική λογική έκφραση να είναι αληθής για *κάθε* τιμή του `i` στο δεδομένο εύρος (από 1 έως `stack_blocks-1`, δηλαδή 1..2).
        *   `width[stack1[i]] >= width[stack1[i+1]]`: Συγκρίνει το πλάτος του τουβλακίου στη θέση `i` της στοίβας 1 με το πλάτος του τουβλακίου στην αμέσως επόμενη θέση `i+1`. Δεδομένου ότι το σύνολο `STACK` είναι 1..3 και ο έλεγχος γίνεται μέχρι το `stack_blocks-1` (2), αυτό ελέγχει για:
            *   `i = 1`: `width[stack1[1]] >= width[stack1[2]]` (το τουβλάκι στη θέση 1 - κάτω - είναι πιο φαρδύ ή ίσο με αυτό στη θέση 2)
            *   `i = 2`: `width[stack1[2]] >= width[stack1[3]]` (το τουβλάκι στη θέση 2 είναι πιο φαρδύ ή ίσο με αυτό στη θέση 3 - πάνω)
        *   **Γιατί το κάνει:** Αυτός ο περιορισμός επιβάλλει τη συνθήκη "σταθερότητας" ή "φαρδύτερη βάση" για την πρώτη στοίβα. Κάθε τουβλάκι πρέπει να είναι τουλάχιστον τόσο φαρδύ όσο το τουβλάκι που βρίσκεται ακριβώς από πάνω του.
    *   `constraint forall(i in 1..(stack_blocks-1))( width[stack2[i]] >= width[stack2[i+1]] );`: Ο ίδιος περιορισμός σταθερότητας εφαρμόζεται στη δεύτερη στοίβα.
        *   **Γιατί το κάνει:** Για να διασφαλιστεί ότι και η δεύτερη στοίβα είναι σταθερή.

5.  **Στόχος Επίλυσης (`% Solve the problem`)**
    *   `solve minimize sum(i in STACK)(height[stack1[i]]) + sum(j in STACK)(height[stack2[j]]);`:
        *   `solve minimize ...`: Ορίζει τον στόχο του επιλύτη. Αντί απλώς να βρει μια λύση (`solve satisfy`), αναζητά μια λύση που να **ελαχιστοποιεί** την τιμή της διδόμενης έκφρασης.
        *   `sum(i in STACK)(height[stack1[i]]) + sum(j in STACK)(height[stack2[j]])`: Υπολογίζει το άθροισμα των υψών της στοίβας 1 και το άθροισμα των υψών της στοίβας 2. Δεδομένου ότι έχουμε τον περιορισμό ότι αυτά τα δύο αθροίσματα πρέπει να είναι ίσα, η ελαχιστοποίηση του συνολικού αθροίσματος είναι ισοδύναμη με την ελαχιστοποίηση του ύψους της κάθε στοίβας ξεχωριστά.
        *   **Γιατί το κάνει:** Αυτή είναι η βελτιστοποίηση που ζητείται. Μεταξύ όλων των δυνατών τρόπων να φτιάξουμε δύο ίσες, σταθερές στοίβες χρησιμοποιώντας 6 διαφορετικά τουβλάκια, θέλουμε να βρούμε εκείνον που έχει τη μικρότερη δυνατή ύψος.

6.  **Έξοδος (`% Output the solution`)**
    *   `output ["stack1 = \(stack1);\nstack2 = \(stack2);\n"];`:
        *   `output [...]`: Καθορίζει τι θα τυπωθεί στην κονσόλα όταν ο επιλύτης βρει μια βέλτιστη λύση.
        *   `"stack1 = \(stack1);"`: Δημιουργεί ένα αλφαριθμητικό. Το `\(stack1)` είναι ένας τρόπος να ενσωματώσουμε την *τιμή* της μεταβλητής απόφασης `stack1` (που θα είναι ο πίνακας των δεικτών τουβλακίων) μέσα στο αλφαριθμητικό.
        *   `\n`: Εισάγει αλλαγή γραμμής για καλύτερη μορφοποίηση.
        *   **Γιατί το κάνει:** Για να δούμε ποια τουβλάκια (με τους δείκτες τους) επέλεξε ο επιλύτης για κάθε θέση σε κάθε στοίβα στην βέλτιστη λύση που βρήκε.

Συνοψίζοντας, ο κώδικας χρησιμοποιεί το MiniZinc για να ορίσει τις διαθέσιμες επιλογές (τουβλάκια), τι πρέπει να αποφασιστεί (ποια τουβλάκια πάνε πού στις στοίβες), ποιες συνθήκες πρέπει να ικανοποιούνται (μοναδικά τουβλάκια, ίση ύψος στοιβάδων, σταθερότητα) και ποιο κριτήριο βελτιστοποίησης υπάρχει (ελαχιστοποίηση της συνολικής ύψους). Ο επιλύτης MiniZinc παίρνει αυτή την περιγραφή και ψάχνει αποτελεσματικά στον χώρο των πιθανών αναθέσεων των μεταβλητών απόφασης για να βρει μια λύση που να ικανοποιεί όλους τους περιορισμούς και να είναι βέλτιστη ως προς τον στόχο ελαχιστοποίησης.
